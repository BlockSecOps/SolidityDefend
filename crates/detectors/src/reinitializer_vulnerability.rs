use anyhow::Result;
use std::any::Any;

use crate::detector::{BaseDetector, Detector, DetectorCategory};
use crate::types::{AnalysisContext, Confidence, DetectorId, Finding, Severity};

/// Detector for re-initialization vulnerabilities
///
/// Detects contracts that may be vulnerable to re-initialization attacks after upgrades.
/// This vulnerability led to the AllianceBlock staking exploit in 2024.
///
/// Vulnerable patterns:
/// 1. Custom initialization tracking instead of OpenZeppelin's Initializable:
/// ```solidity
/// contract UpgradeableV2 is Initializable {
///     bool private initialized; // Custom tracking can be corrupted
///     function initialize() public {
///         require(!initialized);
///         initialized = true;
///     }
/// }
/// ```
///
/// 2. Using reinitializer without proper version guards:
/// ```solidity
/// function initializeV2() public reinitializer(2) {
///     // If version tracking is corrupted, can be called multiple times
/// }
/// ```
pub struct ReinitializerVulnerabilityDetector {
    base: BaseDetector,
}

impl Default for ReinitializerVulnerabilityDetector {
    fn default() -> Self {
        Self::new()
    }
}

impl ReinitializerVulnerabilityDetector {
    pub fn new() -> Self {
        Self {
            base: BaseDetector::new(
                DetectorId::new("reinitializer-vulnerability"),
                "Re-initialization Vulnerability".to_string(),
                "Detects contracts vulnerable to re-initialization attacks after upgrades. \
                 Custom initialization tracking or improper reinitializer usage can allow \
                 attackers to re-initialize contracts and take control."
                    .to_string(),
                vec![
                    DetectorCategory::Upgradeable,
                    DetectorCategory::AccessControl,
                ],
                Severity::Critical,
            ),
        }
    }

    /// Check if contract uses custom initialization tracking (not OpenZeppelin's)
    fn has_custom_init_tracking(&self, source: &str) -> Option<u32> {
        let patterns = [
            "bool private initialized",
            "bool internal initialized",
            "bool public initialized",
            "bool _initialized",
            "bool isInitialized",
            "bool private _initialized",
            "bool internal _initialized",
        ];

        for pattern in patterns {
            if let Some(pos) = source.find(pattern) {
                let line = source[..pos].matches('\n').count() as u32 + 1;
                return Some(line);
            }
        }
        None
    }

    /// Check if contract uses reinitializer modifier
    fn has_reinitializer(&self, source: &str) -> Vec<(u32, String)> {
        let mut findings = Vec::new();

        // Match reinitializer(N) pattern
        let re_pattern = "reinitializer(";
        let lines: Vec<&str> = source.lines().collect();

        for (line_num, line) in lines.iter().enumerate() {
            if line.contains(re_pattern) {
                // Extract the function name
                if let Some(func_start) = line.find("function ") {
                    let func_section = &line[func_start + 9..];
                    if let Some(paren_pos) = func_section.find('(') {
                        let func_name = func_section[..paren_pos].trim().to_string();
                        findings.push((line_num as u32 + 1, func_name));
                    }
                }
            }
        }

        findings
    }

    /// Check for initialize function with custom require check
    fn has_custom_require_init_check(&self, source: &str) -> Option<(u32, String)> {
        let lines: Vec<&str> = source.lines().collect();

        for (line_num, line) in lines.iter().enumerate() {
            // Check for require(!initialized) pattern without OpenZeppelin's initializer
            if line.contains("require(!initialized")
                || line.contains("require(!_initialized")
                || line.contains("require(initialized == false")
                || line.contains("require(_initialized == false")
                || line.contains("require(!isInitialized")
            {
                // Check if this is inside an initialize function
                // Look back to find the function declaration
                for i in (0..line_num).rev() {
                    if lines[i].contains("function ") {
                        if lines[i].contains("initialize") {
                            let func_line = lines[i];
                            if let Some(func_start) = func_line.find("function ") {
                                let func_section = &func_line[func_start + 9..];
                                if let Some(paren_pos) = func_section.find('(') {
                                    let func_name = func_section[..paren_pos].trim().to_string();
                                    return Some((line_num as u32 + 1, func_name));
                                }
                            }
                        }
                        break;
                    }
                }
            }
        }
        None
    }

    /// Check if contract has proper version tracking for reinitializer
    fn has_proper_version_tracking(&self, source: &str) -> bool {
        // Check for OpenZeppelin's pattern with _getInitializedVersion
        source.contains("_getInitializedVersion()")
            || source.contains("_initializedVersion")
            // Check for reinitializer with proper version constant
            || (source.contains("reinitializer(") && source.contains("uint64 private constant"))
    }

    /// Check if contract appears to be upgradeable
    fn is_upgradeable_contract(&self, source: &str) -> bool {
        source.contains("Initializable")
            || source.contains("UUPSUpgradeable")
            || source.contains("Upgradeable")
            || source.contains("initializer")
            || source.contains("reinitializer")
    }

    /// Get contract name from source
    fn get_contract_name(&self, ctx: &AnalysisContext) -> String {
        ctx.contract.name.name.to_string()
    }
}

impl Detector for ReinitializerVulnerabilityDetector {
    fn id(&self) -> DetectorId {
        self.base.id.clone()
    }

    fn name(&self) -> &str {
        &self.base.name
    }

    fn description(&self) -> &str {
        &self.base.description
    }

    fn categories(&self) -> Vec<DetectorCategory> {
        self.base.categories.clone()
    }

    fn default_severity(&self) -> Severity {
        self.base.default_severity
    }

    fn is_enabled(&self) -> bool {
        self.base.enabled
    }

    fn detect(&self, ctx: &AnalysisContext<'_>) -> Result<Vec<Finding>> {
        let mut findings = Vec::new();
        // FP Reduction: Skip interface contracts (no implementation to exploit)
        if crate::utils::is_interface_contract(ctx) {
            return Ok(findings);
        }

        // FP Reduction: Skip library contracts (cannot hold state or receive Ether)
        if crate::utils::is_library_contract(ctx) {
            return Ok(findings);
        }

        let source = &ctx.source_code;
        let contract_name = self.get_contract_name(ctx);

        // Only check upgradeable contracts
        if !self.is_upgradeable_contract(source) {
            return Ok(findings);
        }

        // Check for custom initialization tracking
        if let Some(line) = self.has_custom_init_tracking(source) {
            let message = format!(
                "Contract '{}' uses custom initialization tracking variable instead of OpenZeppelin's \
                 Initializable pattern. Custom tracking can be corrupted by storage collision during \
                 upgrades, allowing re-initialization attacks. This was the root cause of the \
                 AllianceBlock staking exploit in 2024.",
                contract_name
            );

            let finding = self
                .base
                .create_finding(ctx, message, line, 1, 20)
                .with_cwe(665) // CWE-665: Improper Initialization
                .with_confidence(Confidence::High)
                .with_fix_suggestion(
                    "Use OpenZeppelin's Initializable contract instead of custom tracking:\n\n\
                     import \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n\
                     contract MyContract is Initializable {\n\
                         function initialize() public initializer {\n\
                             // initialization logic\n\
                         }\n\
                     }"
                    .to_string(),
                );

            findings.push(finding);
        }

        // Check for custom require-based initialization check
        if let Some((line, func_name)) = self.has_custom_require_init_check(source) {
            let message = format!(
                "Function '{}' in contract '{}' uses a custom require check for initialization \
                 instead of OpenZeppelin's initializer modifier. This pattern is vulnerable to \
                 storage collision attacks during upgrades.",
                func_name, contract_name
            );

            let finding = self
                .base
                .create_finding(ctx, message, line, 1, 30)
                .with_cwe(665) // CWE-665: Improper Initialization
                .with_confidence(Confidence::High)
                .with_fix_suggestion(format!(
                    "Replace custom require check with OpenZeppelin's initializer modifier:\n\n\
                     function {}() public initializer {{\n\
                         // initialization logic\n\
                     }}",
                    func_name
                ));

            findings.push(finding);
        }

        // Check for reinitializer usage without proper version tracking
        let reinitializer_usages = self.has_reinitializer(source);
        if !reinitializer_usages.is_empty() && !self.has_proper_version_tracking(source) {
            for (line, func_name) in reinitializer_usages {
                let message = format!(
                    "Function '{}' in contract '{}' uses reinitializer modifier without proper \
                     version tracking. If the version state is corrupted during an upgrade, \
                     the reinitializer can be called multiple times.",
                    func_name, contract_name
                );

                let finding = self
                    .base
                    .create_finding(ctx, message, line, 1, 20)
                    .with_cwe(665) // CWE-665: Improper Initialization
                    .with_cwe(284) // CWE-284: Improper Access Control
                    .with_confidence(Confidence::Medium)
                    .with_fix_suggestion(
                        "Ensure proper version tracking and use _getInitializedVersion() \
                         to verify state before reinitializing. Consider adding explicit \
                         version constant tracking:\n\n\
                         uint64 private constant VERSION = 2;\n\
                         function initializeV2() public reinitializer(VERSION) {\n\
                             require(_getInitializedVersion() < VERSION);\n\
                             // upgrade logic\n\
                         }"
                        .to_string(),
                    );

                findings.push(finding);
            }
        }

        let findings = crate::utils::filter_fp_findings(findings, ctx);
        Ok(findings)
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_detector_properties() {
        let detector = ReinitializerVulnerabilityDetector::new();
        assert_eq!(detector.name(), "Re-initialization Vulnerability");
        assert_eq!(detector.default_severity(), Severity::Critical);
        assert!(detector.is_enabled());
    }

    #[test]
    fn test_custom_init_tracking_detection() {
        let detector = ReinitializerVulnerabilityDetector::new();

        let vulnerable_code = r#"
            contract Vulnerable is Initializable {
                bool private initialized;
                function initialize() public {
                    require(!initialized);
                    initialized = true;
                }
            }
        "#;
        assert!(detector.has_custom_init_tracking(vulnerable_code).is_some());

        let safe_code = r#"
            contract Safe is Initializable {
                function initialize() public initializer {
                    // uses OpenZeppelin's initializer
                }
            }
        "#;
        assert!(detector.has_custom_init_tracking(safe_code).is_none());
    }

    #[test]
    fn test_reinitializer_detection() {
        let detector = ReinitializerVulnerabilityDetector::new();

        let code_with_reinitializer = r#"
            contract Upgradeable is Initializable {
                function initializeV2() public reinitializer(2) {
                    // upgrade logic
                }
            }
        "#;
        let results = detector.has_reinitializer(code_with_reinitializer);
        assert!(!results.is_empty());

        let code_without_reinitializer = r#"
            contract Simple {
                function initialize() public {
                    // no reinitializer
                }
            }
        "#;
        let results = detector.has_reinitializer(code_without_reinitializer);
        assert!(results.is_empty());
    }

    #[test]
    fn test_custom_require_check_detection() {
        let detector = ReinitializerVulnerabilityDetector::new();

        let vulnerable_code = r#"
            contract Vulnerable {
                bool initialized;
                function initialize() public {
                    require(!initialized, "Already initialized");
                    initialized = true;
                }
            }
        "#;
        assert!(
            detector
                .has_custom_require_init_check(vulnerable_code)
                .is_some()
        );
    }

    #[test]
    fn test_is_upgradeable() {
        let detector = ReinitializerVulnerabilityDetector::new();

        assert!(detector.is_upgradeable_contract("contract X is Initializable {}"));
        assert!(detector.is_upgradeable_contract("contract X is UUPSUpgradeable {}"));
        assert!(detector.is_upgradeable_contract("function init() initializer {}"));
        assert!(!detector.is_upgradeable_contract("contract SimpleToken {}"));
    }
}
