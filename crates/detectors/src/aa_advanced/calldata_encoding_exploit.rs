//! AA Calldata Encoding Exploit Detector
//!
//! Detects calldata manipulation vulnerabilities after signature validation in
//! ERC-4337 Account Abstraction wallets. This was a critical vulnerability
//! discovered in production AA wallets in 2024.

use anyhow::Result;
use std::any::Any;

use crate::detector::{BaseDetector, Detector, DetectorCategory};
use crate::types::{AnalysisContext, DetectorId, Finding, Severity};

pub struct AACalldataEncodingExploitDetector {
    base: BaseDetector,
}

impl AACalldataEncodingExploitDetector {
    pub fn new() -> Self {
        Self {
            base: BaseDetector::new(
                DetectorId("aa-calldata-encoding-exploit".to_string()),
                "AA Calldata Encoding Exploit".to_string(),
                "Detects calldata manipulation after signature validation in AA wallets".to_string(),
                vec![DetectorCategory::DeFi],
                Severity::Critical,
            ),
        }
    }
}

impl Default for AACalldataEncodingExploitDetector {
    fn default() -> Self {
        Self::new()
    }
}

impl Detector for AACalldataEncodingExploitDetector {
    fn id(&self) -> DetectorId {
        self.base.id.clone()
    }

    fn name(&self) -> &str {
        &self.base.name
    }

    fn description(&self) -> &str {
        &self.base.description
    }

    fn categories(&self) -> Vec<DetectorCategory> {
        self.base.categories.clone()
    }

    fn default_severity(&self) -> Severity {
        self.base.default_severity
    }

    fn is_enabled(&self) -> bool {
        self.base.enabled
    }

    fn detect(&self, ctx: &AnalysisContext<'_>) -> Result<Vec<Finding>> {
        let mut findings = Vec::new();
        let lower = ctx.source_code.to_lowercase();

        // Check for ERC-4337 UserOperation handling
        let is_aa_wallet = lower.contains("useroperation")
            || lower.contains("validateuserop")
            || lower.contains("executeuserop")
            || lower.contains("handleops");

        if !is_aa_wallet {
            return Ok(findings);
        }

        // Pattern 1: Calldata decoded after signature validation
        let has_validate = lower.contains("validateuserop") || lower.contains("_validateuserop");
        let has_execute = lower.contains("execute(") || lower.contains("executeuserop");

        // Check for signature validation (used in multiple patterns)
        let has_signature_check = lower.contains("signature")
            && (lower.contains("ecrecover") || lower.contains("verify"));

        if has_validate && has_execute {
            // Check if calldata is decoded/modified between validation and execution
            let has_calldata_decode = lower.contains("abi.decode(calldata")
                || lower.contains("abi.decode(userop.calldata")
                || lower.contains("calldatacopy(");

            if has_calldata_decode && has_signature_check {
                let finding = self.base.create_finding(
                    ctx,
                    "Calldata decoded after signature validation - signature may not cover executed calldata".to_string(),
                    1,
                    1,
                    ctx.source_code.len() as u32,
                )
                .with_fix_suggestion(
                    "Ensure signature covers the final executed calldata. Use hash of complete UserOperation struct including calldata.".to_string()
                );

                findings.push(finding);
            }
        }

        // Pattern 2: UserOperation fields modified after validation
        let lines: Vec<&str> = ctx.source_code.lines().collect();
        let mut found_validate_line = None;
        let mut found_modification = false;

        for (i, line) in lines.iter().enumerate() {
            let line_lower = line.to_lowercase();

            // Find validateUserOp function
            if line_lower.contains("validateuserop") && line_lower.contains("function") {
                found_validate_line = Some(i);
            }

            // After validation, check for UserOp field modifications
            if let Some(val_line) = found_validate_line {
                if i > val_line && i < val_line + 50 {
                    if (line_lower.contains("userop.calldata =")
                        || line_lower.contains("userop.sender =")
                        || line_lower.contains("userop.nonce =")
                        || line_lower.contains("calldata ="))
                        && !line_lower.contains("//")
                    {
                        found_modification = true;
                        let finding = self.base.create_finding(
                            ctx,
                            "UserOperation fields modified after validation - signature may become invalid".to_string(),
                            (i + 1) as u32,
                            1,
                            line.len() as u32,
                        )
                        .with_fix_suggestion(
                            "Do not modify UserOperation fields after signature validation. Create new struct if needed.".to_string()
                        );

                        findings.push(finding);
                        break;
                    }
                }
            }
        }

        // Pattern 3: Calldata passed to external contract without hash check
        if has_execute {
            let has_external_call = lower.contains("call{")
                || lower.contains(".call(")
                || lower.contains("delegatecall");

            let has_calldata_hash_check = lower.contains("keccak256(calldata)")
                || lower.contains("keccak256(userop.calldata)")
                || lower.contains("calldatahash");

            if has_external_call && !has_calldata_hash_check && has_signature_check {
                let finding = self.base.create_finding(
                    ctx,
                    "Calldata passed to external call without hash verification - encoding manipulation possible".to_string(),
                    1,
                    1,
                    ctx.source_code.len() as u32,
                )
                .with_fix_suggestion(
                    "Verify calldata hash before passing to external calls. Include calldata hash in signed message.".to_string()
                );

                findings.push(finding);
            }
        }

        // Pattern 4: ABI encoding inside execute without validation
        if has_execute {
            let has_abi_encode = lower.contains("abi.encode(")
                || lower.contains("abi.encodewithselector(")
                || lower.contains("abi.encodewithsignature(");

            if has_abi_encode && has_signature_check {
                let finding = self.base.create_finding(
                    ctx,
                    "ABI encoding performed inside execute - final calldata differs from signed calldata".to_string(),
                    1,
                    1,
                    ctx.source_code.len() as u32,
                )
                .with_fix_suggestion(
                    "Encode calldata before signature validation, not during execution. Sign the final encoded bytes.".to_string()
                );

                findings.push(finding);
            }
        }

        Ok(findings)
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}
