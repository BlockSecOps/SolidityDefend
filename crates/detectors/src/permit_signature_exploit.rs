//! Permit Signature Exploitation Detection
//!
//! Detects EIP-2612 permit() and EIP-712 signature systems with insufficient validation,
//! enabling frontrunning, signature theft, and approval manipulation.

use anyhow::Result;
use std::any::Any;

use crate::detector::{BaseDetector, Detector, DetectorCategory};
use crate::types::{AnalysisContext, DetectorId, Finding, Severity};

pub struct PermitSignatureExploitDetector {
    base: BaseDetector,
}

impl PermitSignatureExploitDetector {
    pub fn new() -> Self {
        Self {
            base: BaseDetector::new(
                DetectorId("permit-signature-exploit".to_string()),
                "Permit Signature Exploitation".to_string(),
                "Detects EIP-2612 permit() and EIP-712 signatures with insufficient validation that enable frontrunning, signature theft, and approval manipulation".to_string(),
                vec![
                    DetectorCategory::Auth,
                    DetectorCategory::Validation,
                    DetectorCategory::MEV,
                ],
                Severity::High,
            ),
        }
    }

    fn check_permit_patterns(&self, ctx: &AnalysisContext) -> Vec<(String, u32, String)> {
        let mut findings = Vec::new();
        let source = &ctx.source_code;
        let source_lower = source.to_lowercase();

        // Check if contract implements permit
        let has_permit = source_lower.contains("function permit")
            || source_lower.contains("eip2612")
            || source_lower.contains("eip712");

        if !has_permit {
            return findings;
        }

        // Pattern 1: Missing deadline validation
        if source_lower.contains("permit") {
            let has_deadline_param = source_lower.contains("deadline")
                || source_lower.contains("expiry")
                || source_lower.contains("validuntil");

            let validates_deadline = (source_lower.contains("require") || source_lower.contains("if"))
                && (source_lower.contains("block.timestamp")
                    || source_lower.contains("timestamp"))
                && (source_lower.contains("deadline") || source_lower.contains("expiry"));

            if has_deadline_param && !validates_deadline {
                findings.push((
                    "Permit with deadline parameter but no validation (expired signatures accepted)".to_string(),
                    0,
                    "Validate deadline: require(block.timestamp <= deadline, \"Permit expired\"); Prevents use of expired permit signatures.".to_string(),
                ));
            }

            if !has_deadline_param {
                findings.push((
                    "Permit without deadline parameter (signatures never expire)".to_string(),
                    0,
                    "Add deadline: function permit(address owner, address spender, uint256 value, uint256 deadline, ...) external; require(block.timestamp <= deadline);".to_string(),
                ));
            }
        }

        // Pattern 2: Missing or insufficient nonce tracking
        if source_lower.contains("permit") {
            let has_nonce_param = source_lower.contains("nonce");
            let has_nonce_storage = source_lower.contains("nonces[")
                || source_lower.contains("_nonces")
                || source_lower.contains("mapping")
                && source_lower.contains("nonce");

            let increments_nonce = source_lower.contains("nonce")
                && (source_lower.contains("++") || source_lower.contains("+="));

            if !has_nonce_param {
                findings.push((
                    "Permit without nonce parameter (signature replay risk)".to_string(),
                    0,
                    "Add nonce: Include nonce in permit signature: bytes32 digest = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));".to_string(),
                ));
            }

            if has_nonce_param && !has_nonce_storage {
                findings.push((
                    "Permit with nonce parameter but no nonce storage/tracking".to_string(),
                    0,
                    "Track nonces: mapping(address => uint256) public nonces; Increment after each permit use.".to_string(),
                ));
            }

            if has_nonce_storage && !increments_nonce {
                findings.push((
                    "Permit nonce storage exists but never incremented (replay possible)".to_string(),
                    0,
                    "Increment nonce: nonces[owner]++; Or: uint256 nonce = nonces[owner]++; Include in digest.".to_string(),
                ));
            }
        }

        // Pattern 3: Permit callable by anyone (frontrunning risk)
        if source_lower.contains("function permit")
            && (source_lower.contains("external") || source_lower.contains("public"))
        {
            // This is actually standard behavior, but should be flagged as information
            findings.push((
                "Permit function is public (frontrunning risk - by design but users should be aware)".to_string(),
                0,
                "Note: This is standard EIP-2612 behavior. Users should be aware that anyone can submit their permit signature. Implement deadline protection and consider: (1) Off-chain signature aggregation, (2) Meta-transaction relayers, (3) User education about signature safety.".to_string(),
            ));
        }

        // Pattern 4: Weak ecrecover validation
        if source_lower.contains("permit") && source_lower.contains("ecrecover") {
            let checks_zero_address = (source_lower.contains("require") || source_lower.contains("if"))
                && source_lower.contains("address(0)")
                && (source_lower.contains("signer")
                    || source_lower.contains("recover")
                    || source_lower.contains("owner"));

            if !checks_zero_address {
                findings.push((
                    "Permit ecrecover without zero address check (invalid signature = address(0))".to_string(),
                    0,
                    "Validate recovered address: address recoveredAddress = ecrecover(digest, v, r, s); require(recoveredAddress != address(0) && recoveredAddress == owner, \"Invalid signature\");".to_string(),
                ));
            }
        }

        // Pattern 5: Missing domain separator or incorrect implementation
        if source_lower.contains("permit") {
            let has_domain_separator = source_lower.contains("domain_separator")
                || source_lower.contains("domainseparator")
                || source_lower.contains("eip712domain");

            let includes_chainid = source_lower.contains("chainid")
                || source_lower.contains("chain.id")
                || source_lower.contains("block.chainid");

            let includes_contract_address = source_lower.contains("address(this)")
                && source_lower.contains("keccak256");

            if !has_domain_separator {
                findings.push((
                    "Permit without domain separator (cross-contract signature reuse)".to_string(),
                    0,
                    "Implement EIP-712 domain separator: bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(EIP712_DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes(version)), block.chainid, address(this)));".to_string(),
                ));
            }

            if has_domain_separator && !includes_chainid {
                findings.push((
                    "Domain separator without chain ID (cross-chain replay risk)".to_string(),
                    0,
                    "Include chain ID in domain separator: block.chainid should be part of the domain separator calculation to prevent cross-chain replay.".to_string(),
                ));
            }

            if has_domain_separator && !includes_contract_address {
                findings.push((
                    "Domain separator without contract address (cross-contract replay risk)".to_string(),
                    0,
                    "Include contract address: address(this) should be part of the domain separator to prevent cross-contract replay.".to_string(),
                ));
            }
        }

        // Pattern 6: Unlimited approval in permit
        if source_lower.contains("permit") && source_lower.contains("approve") {
            let checks_max_approval = source_lower.contains("type(uint256).max")
                || source_lower.contains("2**256 - 1")
                || source_lower.contains("unlimited");

            if !checks_max_approval {
                findings.push((
                    "Permit allows unlimited approvals without warning".to_string(),
                    0,
                    "Warn about unlimited approvals: Consider emitting event or requiring explicit confirmation for type(uint256).max approvals. Document the risks of unlimited approvals.".to_string(),
                ));
            }
        }

        // Pattern 7: No signature cancellation mechanism
        if source_lower.contains("permit") {
            let has_cancellation = source_lower.contains("invalidatenonce")
                || source_lower.contains("cancelpermit")
                || source_lower.contains("revoke")
                || (source_lower.contains("function") && source_lower.contains("cancel"));

            if !has_cancellation {
                findings.push((
                    "No mechanism to cancel/invalidate leaked permit signatures".to_string(),
                    0,
                    "Add cancellation: function invalidateNonce(uint256 nonce) external { require(nonce >= nonces[msg.sender]); nonces[msg.sender] = nonce + 1; } Allows users to invalidate leaked signatures.".to_string(),
                ));
            }
        }

        // Pattern 8: Batch permit without atomicity
        if (source_lower.contains("permitbatch")
            || source_lower.contains("multipermit")
            || source_lower.contains("permit[]"))
            && source_lower.contains("for")
        {
            let has_revert_on_failure = source_lower.contains("require")
                || source_lower.contains("revert");

            if !has_revert_on_failure {
                findings.push((
                    "Batch permit without atomic execution (partial execution risk)".to_string(),
                    0,
                    "Ensure atomicity: All permits in batch should succeed or all fail. Use require() to revert on any failure. Consider try/catch for controlled partial execution.".to_string(),
                ));
            }
        }

        // Pattern 9: Missing signature format validation
        if source_lower.contains("permit") {
            let validates_v_value = (source_lower.contains("require") || source_lower.contains("if"))
                && source_lower.contains("v")
                && (source_lower.contains("27") || source_lower.contains("28"));

            if !validates_v_value {
                findings.push((
                    "Permit without signature format validation (v value should be 27 or 28)".to_string(),
                    0,
                    "Validate signature format: require(v == 27 || v == 28, \"Invalid v value\"); Ensures signature format compliance.".to_string(),
                ));
            }
        }

        // Pattern 10: Permit with external call after approval
        if source_lower.contains("permit") && source_lower.contains(".call") {
            findings.push((
                "Permit followed by external call (reentrancy risk)".to_string(),
                0,
                "Reentrancy risk: Permit updates approval state, then makes external call. Use Checks-Effects-Interactions pattern or reentrancy guard. Consider if external call is necessary in permit().".to_string(),
            ));
        }

        findings
    }
}

impl Default for PermitSignatureExploitDetector {
    fn default() -> Self {
        Self::new()
    }
}

impl Detector for PermitSignatureExploitDetector {
    fn id(&self) -> DetectorId {
        self.base.id.clone()
    }

    fn name(&self) -> &str {
        &self.base.name
    }

    fn description(&self) -> &str {
        &self.base.description
    }

    fn default_severity(&self) -> Severity {
        self.base.default_severity
    }

    fn categories(&self) -> Vec<DetectorCategory> {
        self.base.categories.clone()
    }

    fn is_enabled(&self) -> bool {
        self.base.enabled
    }

    fn detect(&self, ctx: &AnalysisContext<'_>) -> Result<Vec<Finding>> {
        let mut findings = Vec::new();

        let issues = self.check_permit_patterns(ctx);

        for (message, line_offset, remediation) in issues {
            let severity = if message.contains("replay")
                || message.contains("without zero address check")
                || message.contains("cross-chain")
            {
                Severity::Critical
            } else if message.contains("deadline")
                || message.contains("nonce")
                || message.contains("domain separator")
            {
                Severity::High
            } else {
                Severity::Medium
            };

            let finding = self
                .base
                .create_finding_with_severity(ctx, message, line_offset, 0, 20, severity)
                .with_fix_suggestion(remediation)
                .with_cwe(345); // CWE-345: Insufficient Verification of Data Authenticity

            findings.push(finding);
        }

        Ok(findings)
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::test_utils::*;

    #[test]
    fn test_detector_properties() {
        let detector = PermitSignatureExploitDetector::new();
        assert_eq!(detector.id().to_string(), "permit-signature-exploit");
        assert_eq!(detector.name(), "Permit Signature Exploitation");
        assert_eq!(detector.default_severity(), Severity::High);
        assert!(detector.is_enabled());
    }

    #[test]
    fn test_detects_missing_deadline_validation() {
        let detector = PermitSignatureExploitDetector::new();
        let source = r#"
            contract Token {
                function permit(
                    address owner,
                    address spender,
                    uint256 value,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) external {
                    // Missing: require(block.timestamp <= deadline)
                    bytes32 digest = getDigest(owner, spender, value, deadline);
                    address recoveredAddress = ecrecover(digest, v, r, s);
                    _approve(owner, spender, value);
                }
            }
        "#;

        let ctx = create_test_context(source);
        let result = detector.detect(&ctx).unwrap();
        assert!(!result.is_empty());
        assert!(result.iter().any(|f| f.message.contains("deadline")));
    }

    #[test]
    fn test_detects_missing_nonce() {
        let detector = PermitSignatureExploitDetector::new();
        let source = r#"
            contract Token {
                function permit(
                    address owner,
                    address spender,
                    uint256 value,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) external {
                    // Missing: nonce parameter and tracking
                    bytes32 digest = keccak256(abi.encodePacked(owner, spender, value, deadline));
                    address recoveredAddress = ecrecover(digest, v, r, s);
                    require(block.timestamp <= deadline);
                    _approve(owner, spender, value);
                }
            }
        "#;

        let ctx = create_test_context(source);
        let result = detector.detect(&ctx).unwrap();
        assert!(!result.is_empty());
        assert!(result.iter().any(|f| f.message.contains("nonce")));
    }

    #[test]
    fn test_detects_missing_zero_address_check() {
        let detector = PermitSignatureExploitDetector::new();
        let source = r#"
            contract Token {
                mapping(address => uint256) public nonces;

                function permit(
                    address owner,
                    address spender,
                    uint256 value,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) external {
                    require(block.timestamp <= deadline);
                    bytes32 digest = getDigest(owner, spender, value, nonces[owner]++, deadline);
                    address recoveredAddress = ecrecover(digest, v, r, s);
                    // Missing: require(recoveredAddress != address(0))
                    require(recoveredAddress == owner);
                    _approve(owner, spender, value);
                }
            }
        "#;

        let ctx = create_test_context(source);
        let result = detector.detect(&ctx).unwrap();
        assert!(!result.is_empty());
        assert!(result
            .iter()
            .any(|f| f.message.contains("zero address")));
    }

    #[test]
    fn test_detects_missing_domain_separator() {
        let detector = PermitSignatureExploitDetector::new();
        let source = r#"
            contract Token {
                function permit(
                    address owner,
                    address spender,
                    uint256 value,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) external {
                    // Missing: domain separator with chain ID and contract address
                    bytes32 digest = keccak256(abi.encode(owner, spender, value, nonces[owner]++, deadline));
                    address recoveredAddress = ecrecover(digest, v, r, s);
                    require(recoveredAddress != address(0) && recoveredAddress == owner);
                    _approve(owner, spender, value);
                }
            }
        "#;

        let ctx = create_test_context(source);
        let result = detector.detect(&ctx).unwrap();
        assert!(!result.is_empty());
        assert!(result
            .iter()
            .any(|f| f.message.contains("domain separator")));
    }

    #[test]
    fn test_detects_no_cancellation_mechanism() {
        let detector = PermitSignatureExploitDetector::new();
        let source = r#"
            contract Token {
                mapping(address => uint256) public nonces;

                function permit(
                    address owner,
                    address spender,
                    uint256 value,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) external {
                    require(block.timestamp <= deadline);
                    bytes32 digest = getDomainSeparatedDigest(owner, spender, value, nonces[owner]++, deadline);
                    address recoveredAddress = ecrecover(digest, v, r, s);
                    require(recoveredAddress != address(0) && recoveredAddress == owner);
                    _approve(owner, spender, value);
                }
                // Missing: function to invalidate nonces / cancel permits
            }
        "#;

        let ctx = create_test_context(source);
        let result = detector.detect(&ctx).unwrap();
        assert!(!result.is_empty());
        assert!(result
            .iter()
            .any(|f| f.message.contains("cancel") || f.message.contains("invalidate")));
    }

    #[test]
    fn test_detects_public_permit_frontrunning() {
        let detector = PermitSignatureExploitDetector::new();
        let source = r#"
            contract Token {
                function permit(
                    address owner,
                    address spender,
                    uint256 value,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) external {
                    // Public function - anyone can call with victim's signature
                }
            }
        "#;

        let ctx = create_test_context(source);
        let result = detector.detect(&ctx).unwrap();
        assert!(!result.is_empty());
        assert!(result
            .iter()
            .any(|f| f.message.contains("frontrunning") || f.message.contains("public")));
    }

    #[test]
    fn test_safe_permit_implementation() {
        let detector = PermitSignatureExploitDetector::new();
        let source = r#"
            contract SafeToken {
                mapping(address => uint256) public nonces;
                bytes32 public DOMAIN_SEPARATOR;

                constructor() {
                    DOMAIN_SEPARATOR = keccak256(abi.encode(
                        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
                        keccak256(bytes("SafeToken")),
                        keccak256(bytes("1")),
                        block.chainid,
                        address(this)
                    ));
                }

                function permit(
                    address owner,
                    address spender,
                    uint256 value,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) external {
                    require(block.timestamp <= deadline, "Permit expired");
                    require(v == 27 || v == 28, "Invalid v");

                    bytes32 structHash = keccak256(abi.encode(
                        keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"),
                        owner,
                        spender,
                        value,
                        nonces[owner]++,
                        deadline
                    ));

                    bytes32 digest = keccak256(abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR, structHash));
                    address recoveredAddress = ecrecover(digest, v, r, s);
                    require(recoveredAddress != address(0) && recoveredAddress == owner, "Invalid signature");

                    _approve(owner, spender, value);
                }

                function invalidateNonce(uint256 nonce) external {
                    require(nonce >= nonces[msg.sender], "Invalid nonce");
                    nonces[msg.sender] = nonce + 1;
                }
            }
        "#;

        let ctx = create_test_context(source);
        let result = detector.detect(&ctx).unwrap();
        // Should have minimal findings (only informational about public permit)
        assert!(result.len() <= 2);
    }
}
