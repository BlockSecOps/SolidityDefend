//! Permit Signature Exploitation Detection
//!
//! Detects EIP-2612 permit() and EIP-712 signature systems with insufficient validation,
//! enabling frontrunning, signature theft, and approval manipulation.

use anyhow::Result;
use std::any::Any;

use crate::detector::{BaseDetector, Detector, DetectorCategory};
use crate::types::{AnalysisContext, DetectorId, Finding, Severity};

pub struct PermitSignatureExploitDetector {
    base: BaseDetector,
}

impl PermitSignatureExploitDetector {
    pub fn new() -> Self {
        Self {
            base: BaseDetector::new(
                DetectorId("permit-signature-exploit".to_string()),
                "Permit Signature Exploitation".to_string(),
                "Detects EIP-2612 permit() and EIP-712 signatures with insufficient validation that enable frontrunning, signature theft, and approval manipulation".to_string(),
                vec![
                    DetectorCategory::Auth,
                    DetectorCategory::Validation,
                    DetectorCategory::MEV,
                ],
                Severity::High,
            ),
        }
    }

    fn check_permit_patterns(&self, ctx: &AnalysisContext) -> Vec<(String, u32, String)> {
        let mut findings = Vec::new();
        let source = &ctx.source_code;
        let source_lower = source.to_lowercase();

        // Check if contract implements permit
        let has_permit = source_lower.contains("function permit")
            || source_lower.contains("eip2612")
            || source_lower.contains("eip712");

        if !has_permit {
            return findings;
        }

        // Pattern 1: Missing deadline validation
        if source_lower.contains("permit") {
            let has_deadline_param = source_lower.contains("deadline")
                || source_lower.contains("expiry")
                || source_lower.contains("validuntil");

            // Look for actual deadline validation with statement terminators, not comments
            // Real code has comma (error message) or semicolon after the validation
            let validates_deadline = source_lower.contains("timestamp <= deadline,")
                || source_lower.contains("timestamp <= deadline;")
                || source_lower.contains("timestamp <= expiry,")
                || source_lower.contains("timestamp <= expiry;")
                || source_lower.contains("deadline >= timestamp,")
                || source_lower.contains("deadline >= timestamp;")
                || source_lower.contains("expiry >= timestamp,");

            if has_deadline_param && !validates_deadline {
                findings.push((
                    "Permit with deadline parameter but no validation (expired signatures accepted)".to_string(),
                    0,
                    "Validate deadline: require(block.timestamp <= deadline, \"Permit expired\"); Prevents use of expired permit signatures.".to_string(),
                ));
            }

            if !has_deadline_param {
                findings.push((
                    "Permit without deadline parameter (signatures never expire)".to_string(),
                    0,
                    "Add deadline: function permit(address owner, address spender, uint256 value, uint256 deadline, ...) external; require(block.timestamp <= deadline);".to_string(),
                ));
            }
        }

        // Pattern 2: Missing or insufficient nonce tracking
        if source_lower.contains("permit") {
            let has_nonce_param = source_lower.contains("nonce");
            let has_nonce_storage = source_lower.contains("nonces[")
                || source_lower.contains("_nonces")
                || source_lower.contains("mapping") && source_lower.contains("nonce");

            let increments_nonce = source_lower.contains("nonce")
                && (source_lower.contains("++") || source_lower.contains("+="));

            if !has_nonce_param {
                findings.push((
                    "Permit without nonce parameter (signature replay risk)".to_string(),
                    0,
                    "Add nonce: Include nonce in permit signature: bytes32 digest = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));".to_string(),
                ));
            }

            if has_nonce_param && !has_nonce_storage {
                findings.push((
                    "Permit with nonce parameter but no nonce storage/tracking".to_string(),
                    0,
                    "Track nonces: mapping(address => uint256) public nonces; Increment after each permit use.".to_string(),
                ));
            }

            if has_nonce_storage && !increments_nonce {
                findings.push((
                    "Permit nonce storage exists but never incremented (replay possible)".to_string(),
                    0,
                    "Increment nonce: nonces[owner]++; Or: uint256 nonce = nonces[owner]++; Include in digest.".to_string(),
                ));
            }
        }

        // Pattern 3: Permit callable by anyone (frontrunning risk)
        // Skip this check - it's standard EIP-2612 behavior and not a vulnerability
        // if source_lower.contains("function permit")
        //     && (source_lower.contains("external") || source_lower.contains("public"))
        // {
        //     findings.push((...));
        // }

        // Pattern 4: Weak ecrecover validation
        if source_lower.contains("permit") && source_lower.contains("ecrecover") {
            // Look for actual zero address validation in code, not comments
            // Real code has comparison operators (!=, ==) with address(0) in boolean expressions
            let checks_zero_address = source_lower.contains("!= address(0) &&")
                || source_lower.contains("address(0) !=")
                    && (source_lower.contains("recover") || source_lower.contains("signer"))
                    && source_lower.contains("&&")
                || source_lower.contains("== address(0)") && source_lower.contains("revert")
                || source_lower.contains("recoveredaddress != address(0),");

            if !checks_zero_address {
                findings.push((
                    "Permit ecrecover without zero address check (invalid signature = address(0))".to_string(),
                    0,
                    "Validate recovered address: address recoveredAddress = ecrecover(digest, v, r, s); require(recoveredAddress != address(0) && recoveredAddress == owner, \"Invalid signature\");".to_string(),
                ));
            }
        }

        // Pattern 5: Missing domain separator or incorrect implementation
        if source_lower.contains("permit") {
            let has_domain_separator = source_lower.contains("domain_separator")
                || source_lower.contains("domainseparator")
                || source_lower.contains("eip712domain");

            let includes_chainid = source_lower.contains("chainid")
                || source_lower.contains("chain.id")
                || source_lower.contains("block.chainid");

            let includes_contract_address =
                source_lower.contains("address(this)") && source_lower.contains("keccak256");

            if !has_domain_separator {
                findings.push((
                    "Permit without domain separator (cross-contract signature reuse)".to_string(),
                    0,
                    "Implement EIP-712 domain separator: bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(EIP712_DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes(version)), block.chainid, address(this)));".to_string(),
                ));
            }

            if has_domain_separator && !includes_chainid {
                findings.push((
                    "Domain separator without chain ID (cross-chain replay risk)".to_string(),
                    0,
                    "Include chain ID in domain separator: block.chainid should be part of the domain separator calculation to prevent cross-chain replay.".to_string(),
                ));
            }

            if has_domain_separator && !includes_contract_address {
                findings.push((
                    "Domain separator without contract address (cross-contract replay risk)".to_string(),
                    0,
                    "Include contract address: address(this) should be part of the domain separator to prevent cross-contract replay.".to_string(),
                ));
            }
        }

        // Pattern 6: Unlimited approval in permit
        // Skip this check - standard EIP-2612 allows any approval amount, not a vulnerability
        // if source_lower.contains("permit") && source_lower.contains("approve") {
        //     ...
        // }

        // Pattern 7: No signature cancellation mechanism
        // Skip this check - nonce increment is sufficient for EIP-2612 security
        // Cancellation is nice-to-have but not required
        if false {
            // Disabled
            let has_cancellation = source_lower.contains("function invalidatenonce")
                || source_lower.contains("function cancelpermit")
                || source_lower.contains("function revokePermit")
                || source_lower.contains("function revoke")
                    && (source_lower.contains("nonce") || source_lower.contains("permit"));

            if !has_cancellation {
                findings.push((
                    "No mechanism to cancel/invalidate leaked permit signatures".to_string(),
                    0,
                    "Add cancellation: function invalidateNonce(uint256 nonce) external { require(nonce >= nonces[msg.sender]); nonces[msg.sender] = nonce + 1; } Allows users to invalidate leaked signatures.".to_string(),
                ));
            }
        }

        // Pattern 8: Batch permit without atomicity
        if (source_lower.contains("permitbatch")
            || source_lower.contains("multipermit")
            || source_lower.contains("permit[]"))
            && source_lower.contains("for")
        {
            let has_revert_on_failure =
                source_lower.contains("require") || source_lower.contains("revert");

            if !has_revert_on_failure {
                findings.push((
                    "Batch permit without atomic execution (partial execution risk)".to_string(),
                    0,
                    "Ensure atomicity: All permits in batch should succeed or all fail. Use require() to revert on any failure. Consider try/catch for controlled partial execution.".to_string(),
                ));
            }
        }

        // Pattern 9: Missing signature format validation
        if source_lower.contains("permit") {
            let validates_v_value = (source_lower.contains("require")
                || source_lower.contains("if"))
                && source_lower.contains("v")
                && (source_lower.contains("27") || source_lower.contains("28"));

            // If zero address check exists after ecrecover, it implicitly validates v
            let has_zero_address_check = source_lower.contains("recoveredaddress != address(0)")
                || (source_lower.contains("!= address(0)") && source_lower.contains("ecrecover"));

            if !validates_v_value && !has_zero_address_check {
                findings.push((
                    "Permit without signature format validation (v value should be 27 or 28)".to_string(),
                    0,
                    "Validate signature format: require(v == 27 || v == 28, \"Invalid v value\"); Ensures signature format compliance.".to_string(),
                ));
            }
        }

        // Pattern 10: Permit with external call after approval
        if source_lower.contains("permit") && source_lower.contains(".call") {
            findings.push((
                "Permit followed by external call (reentrancy risk)".to_string(),
                0,
                "Reentrancy risk: Permit updates approval state, then makes external call. Use Checks-Effects-Interactions pattern or reentrancy guard. Consider if external call is necessary in permit().".to_string(),
            ));
        }

        findings
    }

    /// Phase 54 FP Reduction: Check for ERC-2771 trusted forwarder pattern
    fn is_trusted_forwarder_pattern(&self, source: &str) -> bool {
        // ERC-2771 Meta Transaction patterns
        source.contains("ERC2771Context")
            || source.contains("trustedForwarder")
            || source.contains("_trustedForwarder")
            || source.contains("isTrustedForwarder")
            || source.contains("ERC2771Recipient")
            || source.contains("_msgSender()")
                && source.contains("_msgData()")
                && source.contains("trustedForwarder")
    }

    /// Phase 54 FP Reduction: Check if contract is a relayer/forwarder
    fn is_relayer_contract(&self, source: &str) -> bool {
        let source_lower = source.to_lowercase();

        // Common relayer/forwarder patterns
        source_lower.contains("relayer")
            || source_lower.contains("forwarder")
            || source_lower.contains("metatransaction")
            || source_lower.contains("meta_transaction")
            || source_lower.contains("gasless")
            || source_lower.contains("meta-tx")
            || source.contains("Relayer")
            || source.contains("Forwarder")
            || source.contains("GelatoRelay")
            || source.contains("BiconomyForwarder")
    }

    /// Phase 54 FP Reduction: Check if contract only consumes permits (doesn't implement)
    /// Consumers just call token.permit(), they don't need to implement full EIP-2612
    fn is_permit_consumer_only(&self, source: &str) -> bool {
        let source_lower = source.to_lowercase();

        // Check if it's consuming permit (calling permit on external token)
        let uses_permit = source.contains(".permit(")
            || source.contains("IERC20Permit(")
            || source.contains("ERC20Permit(");

        // Check if it implements permit (has the function definition)
        let implements_permit =
            source_lower.contains("function permit(") && source_lower.contains("ecrecover");

        // If it uses permit but doesn't implement it, it's a consumer
        uses_permit && !implements_permit
    }
}

impl Default for PermitSignatureExploitDetector {
    fn default() -> Self {
        Self::new()
    }
}

impl Detector for PermitSignatureExploitDetector {
    fn id(&self) -> DetectorId {
        self.base.id.clone()
    }

    fn name(&self) -> &str {
        &self.base.name
    }

    fn description(&self) -> &str {
        &self.base.description
    }

    fn default_severity(&self) -> Severity {
        self.base.default_severity
    }

    fn categories(&self) -> Vec<DetectorCategory> {
        self.base.categories.clone()
    }

    fn is_enabled(&self) -> bool {
        self.base.enabled
    }

    fn detect(&self, ctx: &AnalysisContext<'_>) -> Result<Vec<Finding>> {
        let mut findings = Vec::new();
        let source = &ctx.source_code;

        // Phase 53 FP Reduction: Skip Permit2 and related protocols
        // These ARE permit implementations - not exploits of permits
        let is_permit_protocol = source.contains("Permit2")
            || source.contains("IAllowanceTransfer")
            || source.contains("ISignatureTransfer")
            || source.contains("PermitHash")
            || source.contains("@uniswap/permit2")
            || source.contains("permit2");

        if is_permit_protocol {
            return Ok(findings);
        }

        // Phase 54 FP Reduction: Skip ERC-2771 trusted forwarder patterns
        if self.is_trusted_forwarder_pattern(source) {
            return Ok(findings);
        }

        // Phase 54 FP Reduction: Skip if contract is a relayer/forwarder
        if self.is_relayer_contract(source) {
            return Ok(findings);
        }

        // Phase 54 FP Reduction: Check if this is a permit consumer, not implementation
        // Permit consumers just use permit(), they don't implement it
        if self.is_permit_consumer_only(source) {
            return Ok(findings);
        }

        let issues = self.check_permit_patterns(ctx);

        for (message, line_offset, remediation) in issues {
            let severity = if message.contains("replay")
                || message.contains("without zero address check")
                || message.contains("cross-chain")
            {
                Severity::Critical
            } else if message.contains("deadline")
                || message.contains("nonce")
                || message.contains("domain separator")
            {
                Severity::High
            } else {
                Severity::Medium
            };

            let finding = self
                .base
                .create_finding_with_severity(ctx, message, line_offset, 0, 20, severity)
                .with_fix_suggestion(remediation)
                .with_cwe(345); // CWE-345: Insufficient Verification of Data Authenticity

            findings.push(finding);
        }

        Ok(findings)
    }

    fn as_any(&self) -> &dyn Any {
        self
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::test_utils::*;

    #[test]
    fn test_detector_properties() {
        let detector = PermitSignatureExploitDetector::new();
        assert_eq!(detector.id().to_string(), "permit-signature-exploit");
        assert_eq!(detector.name(), "Permit Signature Exploitation");
        assert_eq!(detector.default_severity(), Severity::High);
        assert!(detector.is_enabled());
    }

    #[test]
    fn test_detects_missing_deadline_validation() {
        let detector = PermitSignatureExploitDetector::new();
        let source = r#"
            contract Token {
                function permit(
                    address owner,
                    address spender,
                    uint256 value,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) external {
                    // Missing: require(block.timestamp <= deadline)
                    bytes32 digest = getDigest(owner, spender, value, deadline);
                    address recoveredAddress = ecrecover(digest, v, r, s);
                    _approve(owner, spender, value);
                }
            }
        "#;

        let ctx = create_test_context(source);
        let result = detector.detect(&ctx).unwrap();
        assert!(!result.is_empty());
        assert!(result.iter().any(|f| f.message.contains("deadline")));
    }

    #[test]
    fn test_detects_missing_nonce() {
        let detector = PermitSignatureExploitDetector::new();
        let source = r#"
            contract Token {
                function permit(
                    address owner,
                    address spender,
                    uint256 value,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) external {
                    // Missing: nonce parameter and tracking
                    bytes32 digest = keccak256(abi.encodePacked(owner, spender, value, deadline));
                    address recoveredAddress = ecrecover(digest, v, r, s);
                    require(block.timestamp <= deadline);
                    _approve(owner, spender, value);
                }
            }
        "#;

        let ctx = create_test_context(source);
        let result = detector.detect(&ctx).unwrap();
        assert!(!result.is_empty());
        assert!(result.iter().any(|f| f.message.contains("nonce")));
    }

    #[test]
    fn test_detects_missing_zero_address_check() {
        let detector = PermitSignatureExploitDetector::new();
        let source = r#"
            contract Token {
                mapping(address => uint256) public nonces;

                function permit(
                    address owner,
                    address spender,
                    uint256 value,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) external {
                    require(block.timestamp <= deadline);
                    bytes32 digest = getDigest(owner, spender, value, nonces[owner]++, deadline);
                    address recoveredAddress = ecrecover(digest, v, r, s);
                    // Missing: require(recoveredAddress != address(0))
                    require(recoveredAddress == owner);
                    _approve(owner, spender, value);
                }
            }
        "#;

        let ctx = create_test_context(source);
        let result = detector.detect(&ctx).unwrap();
        assert!(!result.is_empty());
        assert!(result.iter().any(|f| f.message.contains("zero address")));
    }

    #[test]
    fn test_detects_missing_domain_separator() {
        let detector = PermitSignatureExploitDetector::new();
        let source = r#"
            contract Token {
                function permit(
                    address owner,
                    address spender,
                    uint256 value,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) external {
                    // Missing: domain separator with chain ID and contract address
                    bytes32 digest = keccak256(abi.encode(owner, spender, value, nonces[owner]++, deadline));
                    address recoveredAddress = ecrecover(digest, v, r, s);
                    require(recoveredAddress != address(0) && recoveredAddress == owner);
                    _approve(owner, spender, value);
                }
            }
        "#;

        let ctx = create_test_context(source);
        let result = detector.detect(&ctx).unwrap();
        assert!(!result.is_empty());
        assert!(
            result
                .iter()
                .any(|f| f.message.contains("domain separator"))
        );
    }

    #[test]
    fn test_detects_no_cancellation_mechanism() {
        // Pattern intentionally disabled: Nonce increment is sufficient for EIP-2612
        // Cancellation mechanism is nice-to-have but not required
        let detector = PermitSignatureExploitDetector::new();
        let source = r#"
            contract Token {
                mapping(address => uint256) public nonces;

                function permit(
                    address owner,
                    address spender,
                    uint256 value,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) external {
                    require(block.timestamp <= deadline);
                    bytes32 digest = getDomainSeparatedDigest(owner, spender, value, nonces[owner]++, deadline);
                    address recoveredAddress = ecrecover(digest, v, r, s);
                    require(recoveredAddress != address(0) && recoveredAddress == owner);
                    _approve(owner, spender, value);
                }
                // Nonce increment provides replay protection (cancellation optional)
            }
        "#;

        let ctx = create_test_context(source);
        let result = detector.detect(&ctx).unwrap();
        // Should not require explicit cancellation mechanism if nonce is incremented
        let has_cancellation_finding = result
            .iter()
            .any(|f| f.message.contains("cancel") || f.message.contains("invalidate"));
        assert!(
            !has_cancellation_finding,
            "Cancellation not required when nonce is incremented"
        );
    }

    #[test]
    fn test_detects_public_permit_frontrunning() {
        // Pattern intentionally disabled: Public permit is standard EIP-2612, not a vulnerability
        // This test now verifies that compliant ERC-2612 implementations are NOT flagged
        let detector = PermitSignatureExploitDetector::new();
        let source = r#"
            contract Token {
                function permit(
                    address owner,
                    address spender,
                    uint256 value,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) external {
                    // Public function - standard EIP-2612 behavior
                }
            }
        "#;

        let ctx = create_test_context(source);
        let result = detector.detect(&ctx).unwrap();
        // Should not flag public permit as it's standard EIP-2612
        let has_public_permit_finding = result
            .iter()
            .any(|f| f.message.contains("frontrunning") || f.message.contains("public"));
        assert!(
            !has_public_permit_finding,
            "Public permit should not be flagged (EIP-2612 standard)"
        );
    }

    #[test]
    fn test_safe_permit_implementation() {
        let detector = PermitSignatureExploitDetector::new();
        let source = r#"
            contract SafeToken {
                mapping(address => uint256) public nonces;
                bytes32 public DOMAIN_SEPARATOR;

                constructor() {
                    DOMAIN_SEPARATOR = keccak256(abi.encode(
                        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
                        keccak256(bytes("SafeToken")),
                        keccak256(bytes("1")),
                        block.chainid,
                        address(this)
                    ));
                }

                function permit(
                    address owner,
                    address spender,
                    uint256 value,
                    uint256 deadline,
                    uint8 v,
                    bytes32 r,
                    bytes32 s
                ) external {
                    require(block.timestamp <= deadline, "Permit expired");
                    require(v == 27 || v == 28, "Invalid v");

                    bytes32 structHash = keccak256(abi.encode(
                        keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"),
                        owner,
                        spender,
                        value,
                        nonces[owner]++,
                        deadline
                    ));

                    bytes32 digest = keccak256(abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR, structHash));
                    address recoveredAddress = ecrecover(digest, v, r, s);
                    require(recoveredAddress != address(0) && recoveredAddress == owner, "Invalid signature");

                    _approve(owner, spender, value);
                }

                function invalidateNonce(uint256 nonce) external {
                    require(nonce >= nonces[msg.sender], "Invalid nonce");
                    nonces[msg.sender] = nonce + 1;
                }
            }
        "#;

        let ctx = create_test_context(source);
        let result = detector.detect(&ctx).unwrap();
        // Should have minimal findings (only informational about public permit)
        assert!(result.len() <= 2);
    }
}
