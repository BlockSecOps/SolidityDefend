â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ”’ BlockSecOps.com - Enterprise-Grade DevSecOps Platform for Smart Contracts
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Found 4037 issues in 1 file:
ğŸ”¥ CRITICAL: Function 'changeOwner' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:19:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'changeOwner'

ğŸ”¥ CRITICAL: Function 'initialize' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:34:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'initialize'

âš ï¸  HIGH: Initializer function 'initialize' lacks access control and can be called by anyone
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:34:14
   â”œâ”€ Detector: unprotected-initializer
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier to 'initialize' or ensure it can only be called once during deployment

ğŸ”¥ CRITICAL: State variables modified after external call - potential reentrancy affecting state machine
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:28:9
   â”œâ”€ Detector: invalid-state-transition
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Use checks-effects-interactions pattern or reentrancy guards

âš ï¸  HIGH: State variable 'initialized' is modified without proper validation or state checks
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:38:9
   â”œâ”€ Detector: invalid-state-transition
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Add proper validation before modifying state variables

âš ï¸  HIGH: Address parameter '_newOwner' in function 'changeOwner' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:19:34
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_newOwner != address(0), "Zero address not allowed");

âš ï¸  HIGH: Address parameter '_recipient' in function 'withdrawAll' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:34
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_recipient != address(0), "Zero address not allowed");

âš ï¸  HIGH: Address parameter '_owner' in function 'initialize' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:34:33
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_owner != address(0), "Zero address not allowed");

âš¡ MEDIUM: Address parameter '_target' in function 'execute' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:42:30
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_target != address(0), "Zero address not allowed");

âš ï¸  HIGH: Parameter '_newOwner' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:19:34
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_newOwner != address(0), "Invalid address");

ğŸ“ LOW: Parameter '_recipient' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:34
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_recipient != address(0), "Invalid address");

âš ï¸  HIGH: Parameter '_owner' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:34:33
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_owner != address(0), "Invalid address");

ğŸ“ LOW: Parameter '_target' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:42:30
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_target != address(0), "Invalid address");

âš¡ MEDIUM: External call in function 'withdrawAll' does not check return value
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:14
   â”œâ”€ Detector: unchecked-external-call
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check the return value of external calls in function 'withdrawAll'

ğŸ”¥ CRITICAL: Function 'withdrawAll' uses tx.origin for authentication/authorization. This is vulnerable to phishing attacks where a malicious contract can call this function while tx.origin remains the victim's address. Use msg.sender instead for access control.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:14
   â”œâ”€ Detector: tx-origin-authentication
   â”œâ”€ CWE: CWE-477
   â””â”€ Fix: Replace 'tx.origin' with 'msg.sender' in function 'withdrawAll'. If you need to track the original sender across multiple calls, pass the address as a function parameter or use a trusted registry.

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:14:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

âš¡ MEDIUM: Function 'execute' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:42:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

ğŸ”¥ CRITICAL: Function 'execute' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:42:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'execute'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'execute' contains dangerous delegatecall pattern. Delegatecall target is controlled by function parameters or user input, allowing arbitrary code execution Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:42:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'execute'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

âš ï¸  HIGH: Function 'withdrawAll' may be vulnerable to withdrawal DOS attack. Withdrawal requires successful external call. Failing calls can permanently block withdrawals. Consider using pull-over-push pattern Attacker can block withdrawals, causing funds to be locked indefinitely.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:14
   â”œâ”€ Detector: vault-withdrawal-dos
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Protect 'withdrawAll' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.

âš ï¸  HIGH: Function 'withdrawAll' may be vulnerable to hook reentrancy attack. Uses raw transfer() instead of SafeERC20. No protection against malicious token implementations with callback hooks ERC-777/ERC-1363 token callbacks can re-enter and manipulate vault state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:14
   â”œâ”€ Detector: vault-hook-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Protect 'withdrawAll' from hook reentrancy. Solutions: (1) Add nonReentrant modifier from OpenZeppelin ReentrancyGuard, (2) Follow checks-effects-interactions (CEI) pattern strictly, (3) Update state BEFORE external calls with callbacks, (4) Validate token doesn't implement hooks (ERC-777/ERC-1363/callbacks), (5) Use reentrancy guard on all vault entry points, (6) Consider EIP-1153 transient storage for gas-efficient protection (Solidity 0.8.24+), (7) Use SafeERC20 wrapper library for token operations.

âš ï¸  HIGH: Function 'withdrawAll' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'withdrawAll'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function '' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:49:5
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in ''. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function 'execute' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:42:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'execute'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš¡ MEDIUM: Function 'withdrawAll' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:14
   â”œâ”€ Detector: gas-griefing
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Mitigate gas griefing in 'withdrawAll'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.

ğŸ“ LOW: Function 'initialize' contains excessive gas usage pattern. Multiple storage reads detected (5). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:34:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'initialize'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:32:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Function 'initialize' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:34:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

âš ï¸  HIGH: Contract has centralization risk. Contract uses single owner without multi-signature protection. Single private key compromise leads to total contract control Single point of failure can lead to fund loss, governance attacks, or complete system compromise.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:1:0
   â”œâ”€ Detector: centralization-risk
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.

âš¡ MEDIUM: Function 'withdrawAll' contains variable shadowing. Parameter 'owner' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'withdrawAll'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš ï¸  HIGH: Account abstraction initialization lacks signature verification. Initialization function lacks signature verification Missing signature verification allows anyone to initialize the account with arbitrary parameters, leading to account takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:34:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: Implement secure initialization: (1) Add initWithSig function requiring user signature, (2) Verify signature matches expected owner, (3) Use nonce to prevent replay attacks, (4) Implement one-time initialization flag, (5) Consider ERC-4337 EntryPoint-only initialization.

âš ï¸  HIGH: Initialization sets owner without validation. Owner assignment without address(0) check or signature verification Unvalidated owner parameter allows initialization with attacker-controlled address.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:15:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate owner parameter: (1) Require owner != address(0), (2) Verify signature from owner address, (3) Emit OwnerSet event, (4) Consider two-step ownership transfer, (5) Validate owner in constructor or initWithSig.

âš ï¸  HIGH: Initialization sets owner without validation. Owner assignment without address(0) check or signature verification Unvalidated owner parameter allows initialization with attacker-controlled address.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:21:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate owner parameter: (1) Require owner != address(0), (2) Verify signature from owner address, (3) Emit OwnerSet event, (4) Consider two-step ownership transfer, (5) Validate owner in constructor or initWithSig.

âš ï¸  HIGH: Delegation contract missing recovery mechanism. No recovery mechanism found - users cannot undo delegation Without recovery, hardware wallet users lose access if delegation target is compromised or becomes incompatible.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:1:0
   â”œâ”€ Detector: hardware-wallet-delegation
   â”œâ”€ CWE: CWE-672
   â””â”€ Fix: Implement delegation recovery: (1) Add removeDelegation function, (2) Allow switching delegation targets, (3) Implement emergency mode fallback, (4) Support direct EOA transactions, (5) Require hardware wallet signature for changes.

âš ï¸  HIGH: Delegation target not validated for interface compatibility. Missing interface validation can cause hardware wallet to delegate to incompatible code, bricking the account.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:1:0
   â”œâ”€ Detector: hardware-wallet-delegation
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate delegation target: (1) Check supportsInterface for EIP-165, (2) Verify required functions exist, (3) Test delegation in simulation first, (4) Implement delegation preview/confirmation, (5) Maintain whitelist of verified delegation targets.

âš¡ MEDIUM: Token transfer lacks return data size validation - vulnerable to return bomb DOS
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:1:1
   â”œâ”€ Detector: erc20-transfer-return-bomb
   â””â”€ Fix: Check returndatasize() and reject if excessive (>64 bytes): require(returndatasize() <= 64)

âš¡ MEDIUM: No withdrawal fee accounting (fee bypass risk) in 'withdrawAll'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Calculate fee: uint256 fee = (amount * withdrawalFee) / FEE_DENOMINATOR; uint256 amountAfterFee = amount - fee;

âš ï¸  HIGH: Asset calculation missing totalSupply/totalAssets in 'withdrawAll'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Calculate assets: assets = (shares * totalAssets()) / totalSupply();

âš¡ MEDIUM: No slippage protection on withdrawal in 'withdrawAll'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add slippage: require(assets >= minAssets, "Slippage too high");

âš¡ MEDIUM: Function 'withdrawAll' is missing transaction deadline. Missing transaction deadline. Withdrawal operation 'withdrawAll' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'withdrawAll'. Implement: (1) Add 'deadline' parameter: function withdrawAll(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

âš¡ MEDIUM: Function 'execute' is missing transaction deadline. Missing transaction deadline. Order execution operation 'execute' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:42:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'execute'. Implement: (1) Add 'deadline' parameter: function execute(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

ğŸ“ LOW: Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:2:0
   â”œâ”€ Detector: floating-pragma
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.

ğŸ”¥ CRITICAL: Contract 'VulnerableWallet' declares storage variables directly without using Diamond Storage pattern. This creates collision risk when multiple facets share the same proxy storage. Direct storage at sequential slots (0, 1, 2...) will collide across facets, corrupting state and causing critical failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:10:10
   â”œâ”€ Detector: diamond-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Implement Diamond Storage pattern for 'VulnerableWallet': (1) Create a library with 'bytes32 constant STORAGE_POSITION = keccak256("diamond.storage.vulnerablewallet")' (2) Define a struct containing all storage variables, (3) Create a function returning 'Storage storage ds' using assembly to set slot to STORAGE_POSITION, (4) Access all storage through this function instead of direct variables, (5) Use unique namespace per facet to guarantee isolation.

âš ï¸  HIGH: Contract 'VulnerableWallet' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:10:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

ğŸ”¥ CRITICAL: Function 'execute' performs delegatecall with user-controlled target. Delegatecall target is derived from function parameters or user input, allowing callers to specify arbitrary code to execute. This allows arbitrary code execution in the contract's storage context, enabling complete takeover and fund theft.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:42:14
   â”œâ”€ Detector: delegatecall-user-controlled
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Remove user control over delegatecall target in 'execute'. Use a whitelist of approved addresses: mapping(address => bool) approvedTargets; Or avoid delegatecall entirely and use regular external calls.

ğŸ”¥ CRITICAL: Classic reentrancy pattern with transient storage risk in 'withdrawAll'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:0
   â”œâ”€ Detector: transient-storage-reentrancy
   â””â”€ Fix: State update after external call is vulnerable to reentrancy:

Current pattern (VULNERABLE):
1. Read balance
2. Call transfer() â† attacker can reenter here with transient storage!
3. Update balance to 0

Secure pattern:
1. Read balance
2. Update balance to 0 â† do this FIRST
3. Call transfer()

With EIP-1153, even 2300 gas is enough to modify transient state and re-enter.

ğŸ”¥ CRITICAL: Unprotected initialization in 'initialize' - vulnerable to front-running takeover ($1.54M August 2025 attack)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:34:0
   â”œâ”€ Detector: eip7702-init-frontrun
   â””â”€ Fix: EIP-7702 Front-Running Attack:

Current code (VULNERABLE):
function initialize(...) public {
require(owner == address(0));
owner = newOwner;  // âŒ Attacker can front-run!
}

Attack sequence:
1. User signs EIP-7702 authorization
2. Attacker sees authorization in mempool
3. Attacker front-runs with initialize(attackerAddress)
4. User's delegation is now controlled by attacker
5. Attacker drains all assets

Fix 1: Authorization-based initialization
function initialize(address _owner, bytes memory signature) public {
require(owner == address(0));

// âœ… Verify user signed this specific initialization
bytes32 hash = keccak256(abi.encodePacked(_owner, address(this)));
address signer = ECDSA.recover(hash, signature);
require(signer == _owner, "Invalid signature");

owner = _owner;
}

Fix 2: Constructor initialization (if possible)
constructor(address _owner) {
owner = _owner;  // âœ… Set during deployment
}

Fix 3: Factory pattern with immediate initialization
contract DelegateFactory {
function createDelegate() public returns (address) {
Delegate delegate = new Delegate(msg.sender);
return address(delegate);
}
}

Fix 4: Commit-reveal with time-lock
mapping(bytes32 => uint256) public commitments;

function commitInit(bytes32 commitment) public {
commitments[commitment] = block.timestamp;
}

function initialize(address _owner, bytes32 salt) public {
bytes32 commitment = keccak256(abi.encodePacked(_owner, salt));
require(commitments[commitment] > 0, "No commitment");
require(block.timestamp >= commitments[commitment] + 10 minutes);

owner = _owner;
}

Real-World Loss: $1.54M (August 2025)

ğŸ”¥ CRITICAL: Missing access control in 'execute' - allows arbitrary execution
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:42:0
   â”œâ”€ Detector: eip7702-delegate-access-control
   â””â”€ Fix: Fix: Add owner/authorization check:

address public owner;

function execute(address target, bytes calldata data) external payable {
require(msg.sender == owner, "Not authorized");
(bool success, ) = target.call{value: msg.value}(data);
require(success, "Call failed");
}

âš¡ MEDIUM: EIP-7702 delegate uses storage - verify no collision with EOA state
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:1:0
   â”œâ”€ Detector: eip7702-storage-collision
   â””â”€ Fix: Use EIP-7201 namespaced storage to avoid collisions:

bytes32 private constant STORAGE_LOCATION = 
keccak256("myprotocol.delegate.storage");

struct DelegateStorage {
address owner;
mapping(address => uint256) balances;
}

function _getStorage() private pure returns (DelegateStorage storage $) {
assembly { $.slot := STORAGE_LOCATION }
}

âš ï¸  HIGH: tx.origin usage breaks with EIP-7702 delegation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:1:0
   â”œâ”€ Detector: eip7702-txorigin-bypass
   â””â”€ Fix: EIP-7702 breaks tx.origin assumptions:

Before: tx.origin == msg.sender for EOAs
After EIP-7702: tx.origin != msg.sender (msg.sender is delegate)

Fix: Use msg.sender instead:
require(msg.sender == owner, "Not owner");

âš¡ MEDIUM: Auction/bidding without commit-reveal - bids can be front-run
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:1:0
   â”œâ”€ Detector: missing-commit-reveal
   â””â”€ Fix: Implement commit-reveal pattern:

mapping(address => bytes32) public commitments;
mapping(address => uint256) public bids;
uint256 public commitDeadline;
uint256 public revealDeadline;

// Phase 1: Commit (hide bid amount)
function commitBid(bytes32 commitment) external {
require(block.timestamp < commitDeadline);
commitments[msg.sender] = commitment;
}

// Phase 2: Reveal (after commit deadline)
function revealBid(uint256 amount, bytes32 salt) external payable {
require(block.timestamp >= commitDeadline);
require(block.timestamp < revealDeadline);

bytes32 commitment = keccak256(abi.encode(amount, salt));
require(commitment == commitments[msg.sender], "Invalid reveal");
require(msg.value == amount, "Amount mismatch");

bids[msg.sender] = amount;
}

âš ï¸  HIGH: Potential division before multiplication - causes precision loss (OWASP 2025)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:1:0
   â”œâ”€ Detector: logic-error-patterns
   â””â”€ Fix: âŒ PRECISION LOSS ($63.8M in losses):
uint256 reward = (amount / totalSupply) * rewardRate;
// Result: 0 if amount < totalSupply!

âœ… CORRECT ORDER:
uint256 reward = (amount * rewardRate) / totalSupply;
// Maximizes precision, multiply before divide

âœ… BEST: Use fixed-point math:
uint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;

Real incidents:
- Cork Protocol: $11M (May 2025) - Division rounding
- SIR.trading: $355K (March 2025) - Reward calculation
- Multiple 2024 incidents: $63.8M total

âš¡ MEDIUM: Reward distribution logic detected - verify precision and rounding
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:1:0
   â”œâ”€ Detector: logic-error-patterns
   â””â”€ Fix: Common reward distribution errors:

1. Integer division truncation:
âŒ reward = balance / users;  // Loses remainder
âœ… reward = balance * 1e18 / users / 1e18;

2. Accumulating rounding errors:
âŒ Track individual rewards that sum != total
âœ… Use lastUser = total - sum(others)

3. Division before multiplication:
âŒ (balance / total) * multiplier
âœ… (balance * multiplier) / total

4. Missing remainder handling:
uint256 perUser = total / userCount;
uint256 remainder = total % userCount;
// Handle remainder explicitly!

âš¡ MEDIUM: Array access without length validation - can cause out-of-bounds access
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ MISSING ARRAY VALIDATION (OWASP 2025 - $14.6M impact):
function process(uint256[] calldata ids) external {
for (uint256 i = 0; i < ids.length; i++) {
// What if ids is empty? Or too large?
}
}

âœ… VALIDATE ARRAY LENGTH:
function process(uint256[] calldata ids) external {
// Check minimum length
require(ids.length > 0, "Empty array");

// Check maximum length (prevent DoS)
require(ids.length <= MAX_BATCH_SIZE, "Batch too large");

for (uint256 i = 0; i < ids.length; i++) {
// Safe to access ids[i]
}
}

âœ… VALIDATE ARRAY MATCHING:
function batchTransfer(
address[] calldata recipients,
uint256[] calldata amounts
) external {
// Arrays must match in length
require(
recipients.length == amounts.length,
"Length mismatch"
);
require(recipients.length > 0, "Empty arrays");
require(recipients.length <= MAX_BATCH, "Too many");

for (uint256 i = 0; i < recipients.length; i++) {
// Safe parallel access
}
}

âš¡ MEDIUM: Transfer function without zero-value check - validate non-zero amounts
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ MISSING ZERO-VALUE CHECK:
function transfer(address to, uint256 amount) external {
_transfer(msg.sender, to, amount);
// What if amount is 0? Wastes gas, may break accounting
}

âœ… VALIDATE NON-ZERO:
function transfer(address to, uint256 amount) external {
require(amount > 0, "Zero amount");
require(to != address(0), "Zero address");
_transfer(msg.sender, to, amount);
}

âœ… COMPLETE VALIDATION:
function deposit(uint256 amount) external payable {
// For ERC20 deposits
require(amount > 0, "Zero amount");
require(amount <= MAX_DEPOSIT, "Exceeds maximum");

// For native ETH deposits
if (msg.value > 0) {
require(msg.value == amount, "Value mismatch");
}

// Proceed with deposit
}

âš¡ MEDIUM: Address parameter without zero-address validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ MISSING ADDRESS VALIDATION:
function setOwner(address newOwner) external {
owner = newOwner;  // What if newOwner is address(0)?
}

âœ… VALIDATE ADDRESS:
function setOwner(address newOwner) external onlyOwner {
require(newOwner != address(0), "Zero address");
require(newOwner != owner, "Same address");
owner = newOwner;
}

âœ… VALIDATE MULTIPLE ADDRESSES:
function initialize(
address _token,
address _oracle,
address _treasury
) external {
require(_token != address(0), "Zero token");
require(_oracle != address(0), "Zero oracle");
require(_treasury != address(0), "Zero treasury");

// Check for duplicates if needed
require(_token != _oracle, "Token == oracle");
require(_token != _treasury, "Token == treasury");

token = _token;
oracle = _oracle;
treasury = _treasury;
}

âš ï¸  HIGH: tx.origin used in access control - vulnerable to phishing attacks
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:1:0
   â”œâ”€ Detector: enhanced-access-control
   â””â”€ Fix: âŒ NEVER use tx.origin for access control:
function withdraw() public {
require(tx.origin == owner, "Not owner");
// Vulnerable to phishing!
}

Attack scenario:
1. Attacker deploys malicious contract
2. Owner calls attacker contract
3. Attacker contract calls victim.withdraw()
4. tx.origin is still owner, check passes!
5. Funds drained

âœ… ALWAYS use msg.sender:
function withdraw() public {
require(msg.sender == owner, "Not owner");
// Safe: msg.sender is immediate caller
}

The difference:
- msg.sender: Immediate caller (can be contract)
- tx.origin: Original EOA that started the transaction

Valid use of tx.origin:
- Reject contract calls: require(tx.origin == msg.sender)
- But NEVER for access control decisions

âš ï¸  HIGH: Liquidity removal without time-lock protection - vulnerable to JIT attacks
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:1:1
   â”œâ”€ Detector: jit-liquidity-sandwich
   â””â”€ Fix: Add a minimum lock time for liquidity positions (e.g., 1 block or epoch-based system) to prevent JIT liquidity attacks

ğŸ”¥ CRITICAL: Function 'withdrawAll' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'withdrawAll'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

ğŸ”¥ CRITICAL: Function 'withdrawAll' in contract 'VulnerableWallet' contains transfer patterns that could drain an account's balance. If used as an EIP-7702 delegation target, this could allow attackers to steal all user funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:28:1
   â”œâ”€ Detector: eip7702-delegation-phishing
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Review transfer logic to ensure it cannot be abused:

1. Add explicit amount limits
2. Require user confirmation for large transfers
3. Implement withdrawal patterns instead of push patterns
4. Add rate limiting for transfers

ğŸ”¥ CRITICAL: Function 'endAuction' in contract 'VulnerableWallet' contains transfer patterns that could drain an account's balance. If used as an EIP-7702 delegation target, this could allow attackers to steal all user funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:97:1
   â”œâ”€ Detector: eip7702-delegation-phishing
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Review transfer logic to ensure it cannot be abused:

1. Add explicit amount limits
2. Require user confirmation for large transfers
3. Implement withdrawal patterns instead of push patterns
4. Add rate limiting for transfers

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'VulnerableWallet' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:11:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'uint256)' (uint) in contract 'VulnerableWallet' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:12:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'initialized' (bool) in contract 'VulnerableWallet' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:32:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'changeOwner' in contract 'VulnerableWallet' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:21:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'initialize' in contract 'VulnerableWallet' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:37:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'withdrawAll' in contract 'VulnerableWallet' has sweeper-like naming and contains asset transfers. If used as an EIP-7702 delegation target, this could allow draining all assets from the delegating EOA.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: If this is a legitimate rescue function:

1. Add strict access control (onlyOwner, multi-sig)
2. Add timelock delays for large withdrawals
3. Emit events for all asset movements
4. Consider withdrawal limits
5. Document the function's intended use

NEVER use as EIP-7702 delegation target without safeguards.

ğŸ”¥ CRITICAL: Function 'withdrawAll' in contract 'VulnerableWallet' transfers the entire ETH balance. This pattern could be exploited in EIP-7702 delegation to drain all ETH from a user's account.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:28:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: Avoid transferring full balance:

1. Use specific amounts instead of address(this).balance
2. Add withdrawal limits and rate limiting
3. Require multi-sig approval for large transfers

ğŸ”¥ CRITICAL: Function 'endAuction' in contract 'VulnerableWallet' transfers the entire ETH balance. This pattern could be exploited in EIP-7702 delegation to drain all ETH from a user's account.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:97:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: Avoid transferring full balance:

1. Use specific amounts instead of address(this).balance
2. Add withdrawal limits and rate limiting
3. Require multi-sig approval for large transfers

âš ï¸  HIGH: Function 'execute' in contract 'VulnerableWallet' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:42:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

ğŸ”¥ CRITICAL: Function 'withdrawAll' in contract 'VulnerableWallet' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

âš ï¸  HIGH: Function 'bid' in contract 'VulnerableWallet' accepts bids without manipulation protection. Searchers can game the bidding process.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:88:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add bid manipulation protections:

1. Implement sealed-bid auctions with commit-reveal
2. Add minimum bid increments
3. Use time-weighted bidding
4. Implement bid bonds to prevent spam

âš ï¸  HIGH: Function 'claimReward' in contract 'VulnerableWallet' uses first-price auction without sealed bids. Bidders can see and outbid each other, enabling last-moment sniping.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:80:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Use sealed-bid or second-price auctions:

// Sealed-bid commit-reveal
function commitBid(bytes32 hash) external;
function revealBid(uint256 amount, bytes32 salt) external;

// Or second-price (Vickrey) auction
winner pays second-highest bid

âš ï¸  HIGH: Function 'claimReward' in contract 'VulnerableWallet' uses first-price auction without sealed bids. Bidders can see and outbid each other, enabling last-moment sniping.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:81:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Use sealed-bid or second-price auctions:

// Sealed-bid commit-reveal
function commitBid(bytes32 hash) external;
function revealBid(uint256 amount, bytes32 salt) external;

// Or second-price (Vickrey) auction
winner pays second-highest bid

âš ï¸  HIGH: Function 'bid' in contract 'VulnerableWallet' uses first-price auction without sealed bids. Bidders can see and outbid each other, enabling last-moment sniping.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:89:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Use sealed-bid or second-price auctions:

// Sealed-bid commit-reveal
function commitBid(bytes32 hash) external;
function revealBid(uint256 amount, bytes32 salt) external;

// Or second-price (Vickrey) auction
winner pays second-highest bid

âš ï¸  HIGH: Function 'bid' in contract 'VulnerableWallet' uses first-price auction without sealed bids. Bidders can see and outbid each other, enabling last-moment sniping.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:90:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Use sealed-bid or second-price auctions:

// Sealed-bid commit-reveal
function commitBid(bytes32 hash) external;
function revealBid(uint256 amount, bytes32 salt) external;

// Or second-price (Vickrey) auction
winner pays second-highest bid

âš ï¸  HIGH: Function 'bid' in contract 'VulnerableWallet' uses first-price auction without sealed bids. Bidders can see and outbid each other, enabling last-moment sniping.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:91:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Use sealed-bid or second-price auctions:

// Sealed-bid commit-reveal
function commitBid(bytes32 hash) external;
function revealBid(uint256 amount, bytes32 salt) external;

// Or second-price (Vickrey) auction
winner pays second-highest bid

âš ï¸  HIGH: Function 'withdrawAll' in contract 'VulnerableWallet' uses tx.origin for authentication. This has its own security implications and may be deprecated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:26:1
   â”œâ”€ Detector: extcodesize-check-bypass
   â”œâ”€ CWE: CWE-670
   â””â”€ Fix: tx.origin has security implications:

1. Vulnerable to phishing attacks
2. Incompatible with smart wallets/AA
3. May be deprecated in future EIPs

Consider alternative security mechanisms.

âš ï¸  HIGH: Constructor in contract 'VulnerableWallet' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:14:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableWallet' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:62:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableWallet' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:84:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableWallet' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:14:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Function 'withdrawAll' in contract 'VulnerableWallet' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdrawAll' in contract 'VulnerableWallet' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimReward' in contract 'VulnerableWallet' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:68:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimReward' in contract 'VulnerableWallet' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:68:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdrawAll' in contract 'VulnerableWallet' allows instant withdrawals without queuing. This bypasses the challenge/dispute mechanism.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:1
   â”œâ”€ Detector: challenge-period-bypass
   â”œâ”€ CWE: CWE-367
   â””â”€ Fix: Implement withdrawal queue:

1. Separate withdrawal request from finalization
2. Queue withdrawals with timestamp
3. Require challenge period before claiming
4. Track pending withdrawals per user

âš ï¸  HIGH: Function 'withdrawAll' in contract 'VulnerableWallet' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:28:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'endAuction' in contract 'VulnerableWallet' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:97:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'execute' in contract 'VulnerableWallet' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:42:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

ğŸ”¥ CRITICAL: Function 'claimReward' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:68:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'claimReward'

âš ï¸  HIGH: Function 'claimReward' relies on a single oracle source, creating centralization risk
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:68:14
   â”œâ”€ Detector: single-oracle-source
   â”œâ”€ CWE: CWE-693
   â””â”€ Fix: Use multiple oracle sources and implement price aggregation in function 'claimReward'

âš¡ MEDIUM: External call in function 'claimReward' does not check return value
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:68:14
   â”œâ”€ Detector: unchecked-external-call
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check the return value of external calls in function 'claimReward'

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:62:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

âš ï¸  HIGH: Function 'claimReward' may be vulnerable to withdrawal DOS attack. No circuit breaker or emergency withdrawal mechanism. Vault cannot be paused during attacks or emergencies Attacker can block withdrawals, causing funds to be locked indefinitely.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:68:14
   â”œâ”€ Detector: vault-withdrawal-dos
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Protect 'claimReward' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.

âš ï¸  HIGH: Function 'claimReward' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:68:14
   â”œâ”€ Detector: validator-front-running
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate validator front-running in 'claimReward'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.

âš¡ MEDIUM: Function 'claimReward' contains variable shadowing. Parameter 'attackerAddress' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:68:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'claimReward'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš ï¸  HIGH: Reward calculation doesn't account for totalSupply in 'claimReward'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:68:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Calculate rewards: rewardPerToken = (rewardRate * timeDelta * 1e18) / totalSupply;

âš ï¸  HIGH: No timestamp tracking for reward accrual in 'claimReward'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:68:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Track time: lastUpdateTime = block.timestamp; Use for accurate reward calculation

ğŸ”¥ CRITICAL: Missing reward debt tracking (double-claim risk) in 'claimReward'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:68:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Track debt: userRewardDebt[user] = (userBalance * rewardPerToken) / 1e18;

âš¡ MEDIUM: Reward calculation without precision multiplier (rounding errors) in 'claimReward'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:68:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add precision: Use 1e18 multiplier for reward calculations to minimize rounding errors

âš¡ MEDIUM: Function 'claimReward' is missing transaction deadline. Missing transaction deadline. Claim operation 'claimReward' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:68:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'claimReward'. Implement: (1) Add 'deadline' parameter: function claimReward(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

ğŸ”¥ CRITICAL: Contract 'PhishingAttacker' declares storage variables directly without using Diamond Storage pattern. This creates collision risk when multiple facets share the same proxy storage. Direct storage at sequential slots (0, 1, 2...) will collide across facets, corrupting state and causing critical failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:58:10
   â”œâ”€ Detector: diamond-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Implement Diamond Storage pattern for 'PhishingAttacker': (1) Create a library with 'bytes32 constant STORAGE_POSITION = keccak256("diamond.storage.phishingattacker")' (2) Define a struct containing all storage variables, (3) Create a function returning 'Storage storage ds' using assembly to set slot to STORAGE_POSITION, (4) Access all storage through this function instead of direct variables, (5) Use unique namespace per facet to guarantee isolation.

âš ï¸  HIGH: Contract 'PhishingAttacker' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:58:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

ğŸ”¥ CRITICAL: Function 'claimReward' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:68:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'claimReward'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

ğŸ”¥ CRITICAL: Function 'withdrawAll' in contract 'PhishingAttacker' contains transfer patterns that could drain an account's balance. If used as an EIP-7702 delegation target, this could allow attackers to steal all user funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:28:1
   â”œâ”€ Detector: eip7702-delegation-phishing
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Review transfer logic to ensure it cannot be abused:

1. Add explicit amount limits
2. Require user confirmation for large transfers
3. Implement withdrawal patterns instead of push patterns
4. Add rate limiting for transfers

ğŸ”¥ CRITICAL: Function 'endAuction' in contract 'PhishingAttacker' contains transfer patterns that could drain an account's balance. If used as an EIP-7702 delegation target, this could allow attackers to steal all user funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:97:1
   â”œâ”€ Detector: eip7702-delegation-phishing
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Review transfer logic to ensure it cannot be abused:

1. Add explicit amount limits
2. Require user confirmation for large transfers
3. Implement withdrawal patterns instead of push patterns
4. Add rate limiting for transfers

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'PhishingAttacker' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:11:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'uint256)' (uint) in contract 'PhishingAttacker' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:12:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'initialized' (bool) in contract 'PhishingAttacker' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:32:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'changeOwner' in contract 'PhishingAttacker' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:21:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'initialize' in contract 'PhishingAttacker' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:37:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'withdrawAll' in contract 'PhishingAttacker' has sweeper-like naming and contains asset transfers. If used as an EIP-7702 delegation target, this could allow draining all assets from the delegating EOA.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: If this is a legitimate rescue function:

1. Add strict access control (onlyOwner, multi-sig)
2. Add timelock delays for large withdrawals
3. Emit events for all asset movements
4. Consider withdrawal limits
5. Document the function's intended use

NEVER use as EIP-7702 delegation target without safeguards.

ğŸ”¥ CRITICAL: Function 'withdrawAll' in contract 'PhishingAttacker' transfers the entire ETH balance. This pattern could be exploited in EIP-7702 delegation to drain all ETH from a user's account.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:28:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: Avoid transferring full balance:

1. Use specific amounts instead of address(this).balance
2. Add withdrawal limits and rate limiting
3. Require multi-sig approval for large transfers

ğŸ”¥ CRITICAL: Function 'endAuction' in contract 'PhishingAttacker' transfers the entire ETH balance. This pattern could be exploited in EIP-7702 delegation to drain all ETH from a user's account.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:97:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: Avoid transferring full balance:

1. Use specific amounts instead of address(this).balance
2. Add withdrawal limits and rate limiting
3. Require multi-sig approval for large transfers

âš ï¸  HIGH: Function 'execute' in contract 'PhishingAttacker' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:42:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

ğŸ”¥ CRITICAL: Function 'withdrawAll' in contract 'PhishingAttacker' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

âš ï¸  HIGH: Function 'bid' in contract 'PhishingAttacker' accepts bids without manipulation protection. Searchers can game the bidding process.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:88:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add bid manipulation protections:

1. Implement sealed-bid auctions with commit-reveal
2. Add minimum bid increments
3. Use time-weighted bidding
4. Implement bid bonds to prevent spam

âš ï¸  HIGH: Function 'claimReward' in contract 'PhishingAttacker' uses first-price auction without sealed bids. Bidders can see and outbid each other, enabling last-moment sniping.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:80:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Use sealed-bid or second-price auctions:

// Sealed-bid commit-reveal
function commitBid(bytes32 hash) external;
function revealBid(uint256 amount, bytes32 salt) external;

// Or second-price (Vickrey) auction
winner pays second-highest bid

âš ï¸  HIGH: Function 'claimReward' in contract 'PhishingAttacker' uses first-price auction without sealed bids. Bidders can see and outbid each other, enabling last-moment sniping.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:81:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Use sealed-bid or second-price auctions:

// Sealed-bid commit-reveal
function commitBid(bytes32 hash) external;
function revealBid(uint256 amount, bytes32 salt) external;

// Or second-price (Vickrey) auction
winner pays second-highest bid

âš ï¸  HIGH: Function 'bid' in contract 'PhishingAttacker' uses first-price auction without sealed bids. Bidders can see and outbid each other, enabling last-moment sniping.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:89:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Use sealed-bid or second-price auctions:

// Sealed-bid commit-reveal
function commitBid(bytes32 hash) external;
function revealBid(uint256 amount, bytes32 salt) external;

// Or second-price (Vickrey) auction
winner pays second-highest bid

âš ï¸  HIGH: Function 'bid' in contract 'PhishingAttacker' uses first-price auction without sealed bids. Bidders can see and outbid each other, enabling last-moment sniping.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:90:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Use sealed-bid or second-price auctions:

// Sealed-bid commit-reveal
function commitBid(bytes32 hash) external;
function revealBid(uint256 amount, bytes32 salt) external;

// Or second-price (Vickrey) auction
winner pays second-highest bid

âš ï¸  HIGH: Function 'bid' in contract 'PhishingAttacker' uses first-price auction without sealed bids. Bidders can see and outbid each other, enabling last-moment sniping.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:91:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Use sealed-bid or second-price auctions:

// Sealed-bid commit-reveal
function commitBid(bytes32 hash) external;
function revealBid(uint256 amount, bytes32 salt) external;

// Or second-price (Vickrey) auction
winner pays second-highest bid

âš ï¸  HIGH: Function 'withdrawAll' in contract 'PhishingAttacker' uses tx.origin for authentication. This has its own security implications and may be deprecated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:26:1
   â”œâ”€ Detector: extcodesize-check-bypass
   â”œâ”€ CWE: CWE-670
   â””â”€ Fix: tx.origin has security implications:

1. Vulnerable to phishing attacks
2. Incompatible with smart wallets/AA
3. May be deprecated in future EIPs

Consider alternative security mechanisms.

âš ï¸  HIGH: Constructor in contract 'PhishingAttacker' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:14:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'PhishingAttacker' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:62:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'PhishingAttacker' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:84:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Constructor in contract 'PhishingAttacker' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:14:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Function 'withdrawAll' in contract 'PhishingAttacker' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdrawAll' in contract 'PhishingAttacker' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimReward' in contract 'PhishingAttacker' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:68:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimReward' in contract 'PhishingAttacker' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:68:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdrawAll' in contract 'PhishingAttacker' allows instant withdrawals without queuing. This bypasses the challenge/dispute mechanism.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:1
   â”œâ”€ Detector: challenge-period-bypass
   â”œâ”€ CWE: CWE-367
   â””â”€ Fix: Implement withdrawal queue:

1. Separate withdrawal request from finalization
2. Queue withdrawals with timestamp
3. Require challenge period before claiming
4. Track pending withdrawals per user

âš ï¸  HIGH: Function 'withdrawAll' in contract 'PhishingAttacker' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:28:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'endAuction' in contract 'PhishingAttacker' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:97:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'execute' in contract 'PhishingAttacker' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:42:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

ğŸ”¥ CRITICAL: Function 'setBeneficiary' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:101:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'setBeneficiary'

ğŸ”¥ CRITICAL: State variables modified after external call - potential reentrancy affecting state machine
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:97:9
   â”œâ”€ Detector: invalid-state-transition
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Use checks-effects-interactions pattern or reentrancy guards

âš ï¸  HIGH: Address parameter '_beneficiary' in function 'setBeneficiary' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:101:37
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_beneficiary != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter '_beneficiary' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:101:37
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_beneficiary != address(0), "Invalid address");

âš¡ MEDIUM: External call in function 'endAuction' does not check return value
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:95:14
   â”œâ”€ Detector: unchecked-external-call
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check the return value of external calls in function 'endAuction'

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:84:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

âš ï¸  HIGH: Function 'endAuction' is vulnerable to block stuffing attacks. Auction closes in single block without multi-block finalization period, vulnerable to block stuffing to prevent last-minute bids Attackers can fill blocks with transactions to prevent legitimate users from executing time-sensitive operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:95:14
   â”œâ”€ Detector: block-stuffing-vulnerable
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate block stuffing in 'endAuction'. Implement: (1) Grace periods extending deadlines, (2) Multi-block operation windows, (3) Commit-reveal with extended reveal period, (4) Allow batch processing across multiple blocks, (5) Emergency pause mechanisms.

âš ï¸  HIGH: Function 'bid' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:88:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'bid'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function 'endAuction' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:95:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'endAuction'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš¡ MEDIUM: Function 'endAuction' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:95:14
   â”œâ”€ Detector: gas-griefing
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Mitigate gas griefing in 'endAuction'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.

âš ï¸  HIGH: Function 'bid' lacks front-running protection. Bidding function 'bid' lacks commit-reveal scheme. Attackers can see your bid and outbid you Front-runners can extract MEV by observing mempool and inserting their transactions before yours.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:88:14
   â”œâ”€ Detector: front-running-mitigation
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add front-running protection to 'bid'. Implement: (1) Commit-reveal scheme with time delay, (2) Deadline parameter for transaction validity, (3) Minimum output amount (slippage protection), (4) Batch auctions or frequent batch auctions (FBA), (5) Private mempool (Flashbots Protect), (6) Time-weighted average pricing (TWAP).

âš¡ MEDIUM: Function 'bid' contains variable shadowing. Parameter 'highestBid' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:88:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'bid'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Function 'endAuction' contains variable shadowing. Parameter 'beneficiary' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:95:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'endAuction'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš ï¸  HIGH: Contract 'VulnerableAuction' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:79:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

ğŸ”¥ CRITICAL: Classic reentrancy pattern with transient storage risk in 'endAuction'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:95:0
   â”œâ”€ Detector: transient-storage-reentrancy
   â””â”€ Fix: State update after external call is vulnerable to reentrancy:

Current pattern (VULNERABLE):
1. Read balance
2. Call transfer() â† attacker can reenter here with transient storage!
3. Update balance to 0

Secure pattern:
1. Read balance
2. Update balance to 0 â† do this FIRST
3. Call transfer()

With EIP-1153, even 2300 gas is enough to modify transient state and re-enter.

ğŸ”¥ CRITICAL: Function 'endAuction' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:95:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'endAuction'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

ğŸ”¥ CRITICAL: Function 'withdrawAll' in contract 'VulnerableAuction' contains transfer patterns that could drain an account's balance. If used as an EIP-7702 delegation target, this could allow attackers to steal all user funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:28:1
   â”œâ”€ Detector: eip7702-delegation-phishing
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Review transfer logic to ensure it cannot be abused:

1. Add explicit amount limits
2. Require user confirmation for large transfers
3. Implement withdrawal patterns instead of push patterns
4. Add rate limiting for transfers

ğŸ”¥ CRITICAL: Function 'endAuction' in contract 'VulnerableAuction' contains transfer patterns that could drain an account's balance. If used as an EIP-7702 delegation target, this could allow attackers to steal all user funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:97:1
   â”œâ”€ Detector: eip7702-delegation-phishing
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Review transfer logic to ensure it cannot be abused:

1. Add explicit amount limits
2. Require user confirmation for large transfers
3. Implement withdrawal patterns instead of push patterns
4. Add rate limiting for transfers

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'VulnerableAuction' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:11:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'uint256)' (uint) in contract 'VulnerableAuction' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:12:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'initialized' (bool) in contract 'VulnerableAuction' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:32:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'changeOwner' in contract 'VulnerableAuction' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:21:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'initialize' in contract 'VulnerableAuction' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:37:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'withdrawAll' in contract 'VulnerableAuction' has sweeper-like naming and contains asset transfers. If used as an EIP-7702 delegation target, this could allow draining all assets from the delegating EOA.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: If this is a legitimate rescue function:

1. Add strict access control (onlyOwner, multi-sig)
2. Add timelock delays for large withdrawals
3. Emit events for all asset movements
4. Consider withdrawal limits
5. Document the function's intended use

NEVER use as EIP-7702 delegation target without safeguards.

ğŸ”¥ CRITICAL: Function 'withdrawAll' in contract 'VulnerableAuction' transfers the entire ETH balance. This pattern could be exploited in EIP-7702 delegation to drain all ETH from a user's account.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:28:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: Avoid transferring full balance:

1. Use specific amounts instead of address(this).balance
2. Add withdrawal limits and rate limiting
3. Require multi-sig approval for large transfers

ğŸ”¥ CRITICAL: Function 'endAuction' in contract 'VulnerableAuction' transfers the entire ETH balance. This pattern could be exploited in EIP-7702 delegation to drain all ETH from a user's account.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:97:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: Avoid transferring full balance:

1. Use specific amounts instead of address(this).balance
2. Add withdrawal limits and rate limiting
3. Require multi-sig approval for large transfers

âš ï¸  HIGH: Function 'execute' in contract 'VulnerableAuction' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:42:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

ğŸ”¥ CRITICAL: Function 'withdrawAll' in contract 'VulnerableAuction' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

âš ï¸  HIGH: Function 'bid' in contract 'VulnerableAuction' accepts bids without manipulation protection. Searchers can game the bidding process.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:88:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add bid manipulation protections:

1. Implement sealed-bid auctions with commit-reveal
2. Add minimum bid increments
3. Use time-weighted bidding
4. Implement bid bonds to prevent spam

âš ï¸  HIGH: Function 'claimReward' in contract 'VulnerableAuction' uses first-price auction without sealed bids. Bidders can see and outbid each other, enabling last-moment sniping.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:80:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Use sealed-bid or second-price auctions:

// Sealed-bid commit-reveal
function commitBid(bytes32 hash) external;
function revealBid(uint256 amount, bytes32 salt) external;

// Or second-price (Vickrey) auction
winner pays second-highest bid

âš ï¸  HIGH: Function 'claimReward' in contract 'VulnerableAuction' uses first-price auction without sealed bids. Bidders can see and outbid each other, enabling last-moment sniping.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:81:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Use sealed-bid or second-price auctions:

// Sealed-bid commit-reveal
function commitBid(bytes32 hash) external;
function revealBid(uint256 amount, bytes32 salt) external;

// Or second-price (Vickrey) auction
winner pays second-highest bid

âš ï¸  HIGH: Function 'bid' in contract 'VulnerableAuction' uses first-price auction without sealed bids. Bidders can see and outbid each other, enabling last-moment sniping.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:89:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Use sealed-bid or second-price auctions:

// Sealed-bid commit-reveal
function commitBid(bytes32 hash) external;
function revealBid(uint256 amount, bytes32 salt) external;

// Or second-price (Vickrey) auction
winner pays second-highest bid

âš ï¸  HIGH: Function 'bid' in contract 'VulnerableAuction' uses first-price auction without sealed bids. Bidders can see and outbid each other, enabling last-moment sniping.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:90:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Use sealed-bid or second-price auctions:

// Sealed-bid commit-reveal
function commitBid(bytes32 hash) external;
function revealBid(uint256 amount, bytes32 salt) external;

// Or second-price (Vickrey) auction
winner pays second-highest bid

âš ï¸  HIGH: Function 'bid' in contract 'VulnerableAuction' uses first-price auction without sealed bids. Bidders can see and outbid each other, enabling last-moment sniping.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:91:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Use sealed-bid or second-price auctions:

// Sealed-bid commit-reveal
function commitBid(bytes32 hash) external;
function revealBid(uint256 amount, bytes32 salt) external;

// Or second-price (Vickrey) auction
winner pays second-highest bid

âš ï¸  HIGH: Function 'withdrawAll' in contract 'VulnerableAuction' uses tx.origin for authentication. This has its own security implications and may be deprecated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:26:1
   â”œâ”€ Detector: extcodesize-check-bypass
   â”œâ”€ CWE: CWE-670
   â””â”€ Fix: tx.origin has security implications:

1. Vulnerable to phishing attacks
2. Incompatible with smart wallets/AA
3. May be deprecated in future EIPs

Consider alternative security mechanisms.

âš ï¸  HIGH: Constructor in contract 'VulnerableAuction' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:14:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableAuction' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:62:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableAuction' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:84:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableAuction' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:14:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Function 'withdrawAll' in contract 'VulnerableAuction' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdrawAll' in contract 'VulnerableAuction' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimReward' in contract 'VulnerableAuction' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:68:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimReward' in contract 'VulnerableAuction' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:68:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdrawAll' in contract 'VulnerableAuction' allows instant withdrawals without queuing. This bypasses the challenge/dispute mechanism.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:25:1
   â”œâ”€ Detector: challenge-period-bypass
   â”œâ”€ CWE: CWE-367
   â””â”€ Fix: Implement withdrawal queue:

1. Separate withdrawal request from finalization
2. Queue withdrawals with timestamp
3. Require challenge period before claiming
4. Track pending withdrawals per user

âš ï¸  HIGH: Function 'withdrawAll' in contract 'VulnerableAuction' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:28:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'endAuction' in contract 'VulnerableAuction' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:97:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'execute' in contract 'VulnerableAuction' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/AccessControl.sol:42:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš¡ MEDIUM: Address parameter '_target' in function 'execute' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:30
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_target != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter '_target' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:30
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_target != address(0), "Invalid address");

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:15:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

âš¡ MEDIUM: Function 'execute' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

ğŸ”¥ CRITICAL: Function 'forward' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:21:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'forward'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'execute' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'execute'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'forward' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:21:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'forward'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'execute' contains dangerous delegatecall pattern. Delegatecall target is controlled by function parameters or user input, allowing arbitrary code execution Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'execute'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:15:5
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'forward' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:21:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'forward'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

âš ï¸  HIGH: Function 'forward' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:21:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'forward'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš ï¸  HIGH: Function 'execute' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'execute'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

ğŸ“ LOW: Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:148:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Function 'initialize' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:157:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

âš ï¸  HIGH: Contract has centralization risk. Contract uses single owner without multi-signature protection. Single private key compromise leads to total contract control Single point of failure can lead to fund loss, governance attacks, or complete system compromise.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:1:0
   â”œâ”€ Detector: centralization-risk
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.

ğŸ“ LOW: Deprecated function or pattern detected: 'selfdestruct'. selfdestruct is deprecated. Consider alternative contract upgrade patterns
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:1:0
   â”œâ”€ Detector: deprecated-functions
   â”œâ”€ CWE: CWE-477
   â””â”€ Fix: Replace deprecated 'selfdestruct'. selfdestruct is deprecated. Consider alternative contract upgrade patterns

âš ï¸  HIGH: Account abstraction initialization lacks signature verification. Initialization function lacks signature verification Missing signature verification allows anyone to initialize the account with arbitrary parameters, leading to account takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:157:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: Implement secure initialization: (1) Add initWithSig function requiring user signature, (2) Verify signature matches expected owner, (3) Use nonce to prevent replay attacks, (4) Implement one-time initialization flag, (5) Consider ERC-4337 EntryPoint-only initialization.

âš ï¸  HIGH: Initialization sets owner without validation. Owner assignment without address(0) check or signature verification Unvalidated owner parameter allows initialization with attacker-controlled address.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:16:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate owner parameter: (1) Require owner != address(0), (2) Verify signature from owner address, (3) Emit OwnerSet event, (4) Consider two-step ownership transfer, (5) Validate owner in constructor or initWithSig.

âš ï¸  HIGH: Initialization sets owner without validation. Owner assignment without address(0) check or signature verification Unvalidated owner parameter allows initialization with attacker-controlled address.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:46:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate owner parameter: (1) Require owner != address(0), (2) Verify signature from owner address, (3) Emit OwnerSet event, (4) Consider two-step ownership transfer, (5) Validate owner in constructor or initWithSig.

âš ï¸  HIGH: Initialization sets owner without validation. Owner assignment without address(0) check or signature verification Unvalidated owner parameter allows initialization with attacker-controlled address.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:64:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate owner parameter: (1) Require owner != address(0), (2) Verify signature from owner address, (3) Emit OwnerSet event, (4) Consider two-step ownership transfer, (5) Validate owner in constructor or initWithSig.

âš ï¸  HIGH: EIP-7702 delegation initialized without safety checks. Delegation without validation of target contract Unsafe delegation initialization can brick the account if delegating to incompatible or malicious contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:38:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate delegation target: (1) Verify delegate implements required interfaces, (2) Ensure delegate is not zero address, (3) Check delegate has valid code, (4) Require signature for delegation setup, (5) Follow EIP-7702 security guidelines.

âš ï¸  HIGH: EIP-7702 delegation initialized without safety checks. Delegation without validation of target contract Unsafe delegation initialization can brick the account if delegating to incompatible or malicious contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:76:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate delegation target: (1) Verify delegate implements required interfaces, (2) Ensure delegate is not zero address, (3) Check delegate has valid code, (4) Require signature for delegation setup, (5) Follow EIP-7702 security guidelines.

âš ï¸  HIGH: EIP-7702 delegation initialized without safety checks. Delegation without validation of target contract Unsafe delegation initialization can brick the account if delegating to incompatible or malicious contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:109:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate delegation target: (1) Verify delegate implements required interfaces, (2) Ensure delegate is not zero address, (3) Check delegate has valid code, (4) Require signature for delegation setup, (5) Follow EIP-7702 security guidelines.

âš ï¸  HIGH: Delegation contract missing recovery mechanism. No recovery mechanism found - users cannot undo delegation Without recovery, hardware wallet users lose access if delegation target is compromised or becomes incompatible.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:1:0
   â”œâ”€ Detector: hardware-wallet-delegation
   â”œâ”€ CWE: CWE-672
   â””â”€ Fix: Implement delegation recovery: (1) Add removeDelegation function, (2) Allow switching delegation targets, (3) Implement emergency mode fallback, (4) Support direct EOA transactions, (5) Require hardware wallet signature for changes.

âš ï¸  HIGH: Delegation target not validated for interface compatibility. Missing interface validation can cause hardware wallet to delegate to incompatible code, bricking the account.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:1:0
   â”œâ”€ Detector: hardware-wallet-delegation
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate delegation target: (1) Check supportsInterface for EIP-165, (2) Verify required functions exist, (3) Test delegation in simulation first, (4) Implement delegation preview/confirmation, (5) Maintain whitelist of verified delegation targets.

âš¡ MEDIUM: Function 'execute' is missing transaction deadline. Missing transaction deadline. Order execution operation 'execute' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'execute'. Implement: (1) Add 'deadline' parameter: function execute(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

ğŸ“ LOW: Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:2:0
   â”œâ”€ Detector: floating-pragma
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.

ğŸ”¥ CRITICAL: Contract 'VulnerableProxy' declares storage variables directly without using Diamond Storage pattern. This creates collision risk when multiple facets share the same proxy storage. Direct storage at sequential slots (0, 1, 2...) will collide across facets, corrupting state and causing critical failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:11:10
   â”œâ”€ Detector: diamond-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Implement Diamond Storage pattern for 'VulnerableProxy': (1) Create a library with 'bytes32 constant STORAGE_POSITION = keccak256("diamond.storage.vulnerableproxy")' (2) Define a struct containing all storage variables, (3) Create a function returning 'Storage storage ds' using assembly to set slot to STORAGE_POSITION, (4) Access all storage through this function instead of direct variables, (5) Use unique namespace per facet to guarantee isolation.

âš ï¸  HIGH: Contract 'VulnerableProxy' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:11:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

ğŸ”¥ CRITICAL: Function 'execute' performs delegatecall with user-controlled target. Delegatecall target is derived from function parameters or user input, allowing callers to specify arbitrary code to execute. This allows arbitrary code execution in the contract's storage context, enabling complete takeover and fund theft.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:14
   â”œâ”€ Detector: delegatecall-user-controlled
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Remove user control over delegatecall target in 'execute'. Use a whitelist of approved addresses: mapping(address => bool) approvedTargets; Or avoid delegatecall entirely and use regular external calls.

âš ï¸  HIGH: Function 'forward' uses delegatecall to mutable library address. Delegatecall to mutable library 'implementation' - library address can be changed after deployment
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:21:14
   â”œâ”€ Detector: delegatecall-untrusted-library
   â””â”€ CWE: CWE-494

âš¡ MEDIUM: Signatures without expiration/deadline (indefinite validity risk)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:0:0
   â”œâ”€ Detector: multisig-bypass
   â”œâ”€ CWE: CWE-347
   â””â”€ Fix: Add expiration: Include deadline in signature data; require(block.timestamp <= deadline, "Signature expired"); Prevents execution of stale signatures.

ğŸ”¥ CRITICAL: Missing access control in 'execute' - allows arbitrary execution
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:0
   â”œâ”€ Detector: eip7702-delegate-access-control
   â””â”€ Fix: Fix: Add owner/authorization check:

address public owner;

function execute(address target, bytes calldata data) external payable {
require(msg.sender == owner, "Not authorized");
(bool success, ) = target.call{value: msg.value}(data);
require(success, "Call failed");
}

âš¡ MEDIUM: EIP-7702 delegate uses storage - verify no collision with EOA state
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:1:0
   â”œâ”€ Detector: eip7702-storage-collision
   â””â”€ Fix: Use EIP-7201 namespaced storage to avoid collisions:

bytes32 private constant STORAGE_LOCATION = 
keccak256("myprotocol.delegate.storage");

struct DelegateStorage {
address owner;
mapping(address => uint256) balances;
}

function _getStorage() private pure returns (DelegateStorage storage $) {
assembly { $.slot := STORAGE_LOCATION }
}

âš ï¸  HIGH: Potential division before multiplication - causes precision loss (OWASP 2025)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:1:0
   â”œâ”€ Detector: logic-error-patterns
   â””â”€ Fix: âŒ PRECISION LOSS ($63.8M in losses):
uint256 reward = (amount / totalSupply) * rewardRate;
// Result: 0 if amount < totalSupply!

âœ… CORRECT ORDER:
uint256 reward = (amount * rewardRate) / totalSupply;
// Maximizes precision, multiply before divide

âœ… BEST: Use fixed-point math:
uint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;

Real incidents:
- Cork Protocol: $11M (May 2025) - Division rounding
- SIR.trading: $355K (March 2025) - Reward calculation
- Multiple 2024 incidents: $63.8M total

âš¡ MEDIUM: Array access without length validation - can cause out-of-bounds access
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ MISSING ARRAY VALIDATION (OWASP 2025 - $14.6M impact):
function process(uint256[] calldata ids) external {
for (uint256 i = 0; i < ids.length; i++) {
// What if ids is empty? Or too large?
}
}

âœ… VALIDATE ARRAY LENGTH:
function process(uint256[] calldata ids) external {
// Check minimum length
require(ids.length > 0, "Empty array");

// Check maximum length (prevent DoS)
require(ids.length <= MAX_BATCH_SIZE, "Batch too large");

for (uint256 i = 0; i < ids.length; i++) {
// Safe to access ids[i]
}
}

âœ… VALIDATE ARRAY MATCHING:
function batchTransfer(
address[] calldata recipients,
uint256[] calldata amounts
) external {
// Arrays must match in length
require(
recipients.length == amounts.length,
"Length mismatch"
);
require(recipients.length > 0, "Empty arrays");
require(recipients.length <= MAX_BATCH, "Too many");

for (uint256 i = 0; i < recipients.length; i++) {
// Safe parallel access
}
}

âš¡ MEDIUM: Transfer function without zero-value check - validate non-zero amounts
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ MISSING ZERO-VALUE CHECK:
function transfer(address to, uint256 amount) external {
_transfer(msg.sender, to, amount);
// What if amount is 0? Wastes gas, may break accounting
}

âœ… VALIDATE NON-ZERO:
function transfer(address to, uint256 amount) external {
require(amount > 0, "Zero amount");
require(to != address(0), "Zero address");
_transfer(msg.sender, to, amount);
}

âœ… COMPLETE VALIDATION:
function deposit(uint256 amount) external payable {
// For ERC20 deposits
require(amount > 0, "Zero amount");
require(amount <= MAX_DEPOSIT, "Exceeds maximum");

// For native ETH deposits
if (msg.value > 0) {
require(msg.value == amount, "Value mismatch");
}

// Proceed with deposit
}

âš¡ MEDIUM: Address parameter without zero-address validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ MISSING ADDRESS VALIDATION:
function setOwner(address newOwner) external {
owner = newOwner;  // What if newOwner is address(0)?
}

âœ… VALIDATE ADDRESS:
function setOwner(address newOwner) external onlyOwner {
require(newOwner != address(0), "Zero address");
require(newOwner != owner, "Same address");
owner = newOwner;
}

âœ… VALIDATE MULTIPLE ADDRESSES:
function initialize(
address _token,
address _oracle,
address _treasury
) external {
require(_token != address(0), "Zero token");
require(_oracle != address(0), "Zero oracle");
require(_treasury != address(0), "Zero treasury");

// Check for duplicates if needed
require(_token != _oracle, "Token == oracle");
require(_token != _treasury, "Token == treasury");

token = _token;
oracle = _oracle;
treasury = _treasury;
}

âš ï¸  HIGH: Single-step ownership transfer - use 2-step transfer to prevent mistakes
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:1:0
   â”œâ”€ Detector: enhanced-access-control
   â””â”€ Fix: âŒ DANGEROUS - Single-step ownership transfer:
function transferOwnership(address newOwner) public onlyOwner {
owner = newOwner;  // What if newOwner is wrong address?
}
// Risk: Typo in address = permanent loss of control

âœ… SAFE - Two-step ownership transfer:
address public owner;
address public pendingOwner;

// Step 1: Current owner nominates new owner
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0), "Zero address");
pendingOwner = newOwner;
emit OwnershipTransferStarted(owner, newOwner);
}

// Step 2: New owner must accept
function acceptOwnership() public {
require(msg.sender == pendingOwner, "Not pending owner");
address oldOwner = owner;
owner = pendingOwner;
pendingOwner = address(0);
emit OwnershipTransferred(oldOwner, owner);
}

âœ… BEST - Use OpenZeppelin Ownable2Step:
import "@openzeppelin/contracts/access/Ownable2Step.sol";

contract MyContract is Ownable2Step {
// Automatically has 2-step transfer
}

Benefits of 2-step:
- New owner must prove they control the address
- Prevents typos in addresses
- Allows cancellation before acceptance
- New owner can verify contract state first

âš ï¸  HIGH: Liquidity removal without time-lock protection - vulnerable to JIT attacks
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:1:1
   â”œâ”€ Detector: jit-liquidity-sandwich
   â””â”€ Fix: Add a minimum lock time for liquidity positions (e.g., 1 block or epoch-based system) to prevent JIT liquidity attacks

âš ï¸  HIGH: Liquidity becomes active immediately - may enable JIT sandwich attacks
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:1:1
   â”œâ”€ Detector: jit-liquidity-sandwich
   â””â”€ Fix: Consider delaying liquidity activation to the next epoch or block to mitigate JIT attacks

âš ï¸  HIGH: No minimum deposit requirement - small deposits may round down to zero shares
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:1:1
   â”œâ”€ Detector: pool-donation-enhanced
   â””â”€ Fix: Enforce minimum deposit amount or minimum shares minted to prevent rounding attacks

ğŸ”¥ CRITICAL: Implementation contract 'VulnerableProxy' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:50:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Proxy contract 'VulnerableProxy' has state variable 'uint256)' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:60:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'VulnerableProxy' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:12:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'VulnerableProxy' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:13:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'VulnerableProxy' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'forward' in contract 'VulnerableProxy' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:24:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'execute' in contract 'VulnerableProxy' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:31:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'execute' in contract 'VulnerableProxy' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

âš ï¸  HIGH: Function 'executeLogic' in contract 'VulnerableProxy' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:124:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

ğŸ”¥ CRITICAL: Contract 'VulnerableProxy' allows instant liquidity add/remove without time lock. Attackers can perform JIT liquidity attacks by adding liquidity just before large swaps and removing immediately after to capture fees.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:68:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add time lock for liquidity operations:

mapping(address => uint256) public depositTime;
uint256 public constant MIN_LOCK_TIME = 1 hours;

function addLiquidity(uint256 amount) external {
depositTime[msg.sender] = block.timestamp;
// ... add liquidity
}

function removeLiquidity(uint256 shares) external {
require(
block.timestamp >= depositTime[msg.sender] + MIN_LOCK_TIME,
"Liquidity locked"
);
// ... remove liquidity
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableProxy' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableProxy' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

âš ï¸  HIGH: Function 'destroy' in contract 'VulnerableProxy' uses selfdestruct with a parameterized recipient. Attackers may be able to control the recipient address.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:137:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Use fixed recipient for selfdestruct:

address constant TREASURY = 0x...;

function destroy() external onlyOwner {
selfdestruct(payable(TREASURY));
}

Or use withdrawal pattern instead of selfdestruct.

âš ï¸  HIGH: Function 'destroy' in contract 'VulnerableProxy' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:49:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'destroy' in contract 'VulnerableProxy' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:135:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'destroy' in contract 'VulnerableProxy' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:50:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'VulnerableProxy' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:15:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableProxy' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:63:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableProxy' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:151:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:82:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:163:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:15:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:63:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:151:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableProxy' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableProxy' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableProxy' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableProxy' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

âš ï¸  HIGH: Function 'forward' in contract 'VulnerableProxy' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:21:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'execute' in contract 'VulnerableProxy' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'withdraw' in contract 'VulnerableProxy' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'executeLogic' in contract 'VulnerableProxy' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:124:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'destroy' in contract 'VulnerableProxy' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:135:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

ğŸ”¥ CRITICAL: Function 'becomeOwner' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:45:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'becomeOwner'

ğŸ”¥ CRITICAL: Function 'destroy' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:49:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'destroy'

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:45:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

âš ï¸  HIGH: Function 'destroy' contains selfdestruct abuse vulnerability. Selfdestruct is publicly accessible without access control, allowing anyone to destroy the contract Selfdestruct permanently destroys the contract and can force-send ether to any address, bypassing fallback functions and breaking assumptions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:49:14
   â”œâ”€ Detector: selfdestruct-abuse
   â”œâ”€ CWE: CWE-670
   â””â”€ Fix: Restrict or remove selfdestruct in 'destroy'. Add access control (onlyOwner), implement time-lock, or use withdraw pattern instead of selfdestruct. Consider that contracts expecting ether may not have payable fallback.

âš ï¸  HIGH: Function 'becomeOwner' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:45:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'becomeOwner'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function 'destroy' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:49:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'destroy'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Contract 'MaliciousImplementation' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:40:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

ğŸ”¥ CRITICAL: Function 'destroy' contains selfdestruct that publicly accessible without access control. Selfdestruct permanently destroys the contract and sends all remaining Ether to the specified address, bypassing any fallback functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:49:14
   â”œâ”€ Detector: swc106-unprotected-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Protect selfdestruct in 'destroy' with:
1. Add 'onlyOwner' modifier or equivalent access control
2. Implement a timelock (e.g., 48-hour delay) before destruction
3. Consider using upgradeable proxy patterns instead of selfdestruct
4. If selfdestruct is necessary, hardcode a safe beneficiary address
Note: After EIP-6780 (Cancun), selfdestruct only destroys in same transaction as creation

ğŸ”¥ CRITICAL: Implementation contract 'MaliciousImplementation' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:50:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Proxy contract 'MaliciousImplementation' has state variable 'uint256)' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:60:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'MaliciousImplementation' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:12:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'MaliciousImplementation' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:13:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'MaliciousImplementation' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'forward' in contract 'MaliciousImplementation' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:24:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'execute' in contract 'MaliciousImplementation' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:31:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'execute' in contract 'MaliciousImplementation' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

âš ï¸  HIGH: Function 'executeLogic' in contract 'MaliciousImplementation' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:124:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

ğŸ”¥ CRITICAL: Contract 'MaliciousImplementation' allows instant liquidity add/remove without time lock. Attackers can perform JIT liquidity attacks by adding liquidity just before large swaps and removing immediately after to capture fees.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:68:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add time lock for liquidity operations:

mapping(address => uint256) public depositTime;
uint256 public constant MIN_LOCK_TIME = 1 hours;

function addLiquidity(uint256 amount) external {
depositTime[msg.sender] = block.timestamp;
// ... add liquidity
}

function removeLiquidity(uint256 shares) external {
require(
block.timestamp >= depositTime[msg.sender] + MIN_LOCK_TIME,
"Liquidity locked"
);
// ... remove liquidity
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'MaliciousImplementation' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'MaliciousImplementation' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

âš ï¸  HIGH: Function 'destroy' in contract 'MaliciousImplementation' uses selfdestruct with a parameterized recipient. Attackers may be able to control the recipient address.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:137:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Use fixed recipient for selfdestruct:

address constant TREASURY = 0x...;

function destroy() external onlyOwner {
selfdestruct(payable(TREASURY));
}

Or use withdrawal pattern instead of selfdestruct.

âš ï¸  HIGH: Function 'destroy' in contract 'MaliciousImplementation' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:49:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'destroy' in contract 'MaliciousImplementation' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:135:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'destroy' in contract 'MaliciousImplementation' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:50:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'MaliciousImplementation' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:15:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'MaliciousImplementation' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:63:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'MaliciousImplementation' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:151:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MaliciousImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:82:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MaliciousImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:163:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'MaliciousImplementation' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:15:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'MaliciousImplementation' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:63:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'MaliciousImplementation' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:151:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'MaliciousImplementation' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'MaliciousImplementation' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'MaliciousImplementation' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'MaliciousImplementation' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

âš ï¸  HIGH: Function 'forward' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:21:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'execute' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'withdraw' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'executeLogic' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:124:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'destroy' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:135:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

ğŸ”¥ CRITICAL: Function 'withdraw' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'withdraw'

ğŸ“ LOW: Parameter '_amount' of type 'uint' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:31
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_amount > 0, "Amount must be positive");

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:63:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

ğŸ”¥ CRITICAL: Function 'withdraw' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'withdraw'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'withdraw' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'withdraw'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function '' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:82:5
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in ''. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

âš ï¸  HIGH: Function 'withdraw' may be vulnerable to withdrawal DOS attack. No withdrawal cap or limit detected. Large withdrawals can drain liquidity and DOS subsequent withdrawers Attacker can block withdrawals, causing funds to be locked indefinitely.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:14
   â”œâ”€ Detector: vault-withdrawal-dos
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Protect 'withdraw' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.

âš ï¸  HIGH: Function 'withdraw' has validator front-running vulnerability. Price-sensitive operations without fair sequencing, validators can reorder transactions for MEV extraction Validators can observe pending transactions and extract value by front-running users.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:14
   â”œâ”€ Detector: validator-front-running
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate validator front-running in 'withdraw'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.

âš ï¸  HIGH: Function 'withdraw' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'withdraw'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš ï¸  HIGH: Function '' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:82:5
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in ''. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš¡ MEDIUM: Function 'withdraw' is missing transaction deadline. Missing transaction deadline. Withdrawal operation 'withdraw' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'withdraw'. Implement: (1) Add 'deadline' parameter: function withdraw(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

ğŸ”¥ CRITICAL: Contract 'VulnerableWallet' declares storage variables directly without using Diamond Storage pattern. This creates collision risk when multiple facets share the same proxy storage. Direct storage at sequential slots (0, 1, 2...) will collide across facets, corrupting state and causing critical failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:58:10
   â”œâ”€ Detector: diamond-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Implement Diamond Storage pattern for 'VulnerableWallet': (1) Create a library with 'bytes32 constant STORAGE_POSITION = keccak256("diamond.storage.vulnerablewallet")' (2) Define a struct containing all storage variables, (3) Create a function returning 'Storage storage ds' using assembly to set slot to STORAGE_POSITION, (4) Access all storage through this function instead of direct variables, (5) Use unique namespace per facet to guarantee isolation.

âš ï¸  HIGH: Contract 'VulnerableWallet' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:58:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

âš ï¸  HIGH: Function '' performs delegatecall in fallback/receive without access control. Fallback/receive function performs delegatecall without validating the caller. Any address can trigger this by calling a non-existent function or sending ETH. This allows any caller to execute arbitrary code by calling non-existent functions or sending ETH to the contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:82:5
   â”œâ”€ Detector: fallback-delegatecall-unprotected
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Add access control to fallback function ''. Validate implementation address before delegatecall. Use modifiers like 'onlyOwner' or check msg.sender explicitly. Consider using OpenZeppelin's transparent or UUPS proxy patterns.

ğŸ”¥ CRITICAL: Function 'withdraw' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'withdraw'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

ğŸ”¥ CRITICAL: Implementation contract 'VulnerableWallet' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:50:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Proxy contract 'VulnerableWallet' has state variable 'uint256)' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:60:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'VulnerableWallet' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:12:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'VulnerableWallet' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:13:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'VulnerableWallet' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'forward' in contract 'VulnerableWallet' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:24:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'execute' in contract 'VulnerableWallet' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:31:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'execute' in contract 'VulnerableWallet' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

âš ï¸  HIGH: Function 'executeLogic' in contract 'VulnerableWallet' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:124:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

ğŸ”¥ CRITICAL: Contract 'VulnerableWallet' allows instant liquidity add/remove without time lock. Attackers can perform JIT liquidity attacks by adding liquidity just before large swaps and removing immediately after to capture fees.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:68:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add time lock for liquidity operations:

mapping(address => uint256) public depositTime;
uint256 public constant MIN_LOCK_TIME = 1 hours;

function addLiquidity(uint256 amount) external {
depositTime[msg.sender] = block.timestamp;
// ... add liquidity
}

function removeLiquidity(uint256 shares) external {
require(
block.timestamp >= depositTime[msg.sender] + MIN_LOCK_TIME,
"Liquidity locked"
);
// ... remove liquidity
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableWallet' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableWallet' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

âš ï¸  HIGH: Function 'destroy' in contract 'VulnerableWallet' uses selfdestruct with a parameterized recipient. Attackers may be able to control the recipient address.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:137:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Use fixed recipient for selfdestruct:

address constant TREASURY = 0x...;

function destroy() external onlyOwner {
selfdestruct(payable(TREASURY));
}

Or use withdrawal pattern instead of selfdestruct.

âš ï¸  HIGH: Function 'destroy' in contract 'VulnerableWallet' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:49:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'destroy' in contract 'VulnerableWallet' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:135:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'destroy' in contract 'VulnerableWallet' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:50:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'VulnerableWallet' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:15:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableWallet' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:63:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableWallet' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:151:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableWallet' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:82:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableWallet' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:163:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableWallet' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:15:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableWallet' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:63:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableWallet' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:151:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableWallet' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableWallet' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableWallet' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableWallet' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

âš ï¸  HIGH: Function 'forward' in contract 'VulnerableWallet' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:21:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'execute' in contract 'VulnerableWallet' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'withdraw' in contract 'VulnerableWallet' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'executeLogic' in contract 'VulnerableWallet' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:124:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'destroy' in contract 'VulnerableWallet' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:135:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

ğŸ”¥ CRITICAL: Function 'withdraw' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'withdraw'

ğŸ”¥ CRITICAL: Function 'setOwner' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:102:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'setOwner'

âš ï¸  HIGH: Address parameter '_newOwner' in function 'setOwner' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:102:31
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_newOwner != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter '_amount' of type 'uint' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:31
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_amount > 0, "Amount must be positive");

âš ï¸  HIGH: Parameter '_newOwner' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:102:31
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_newOwner != address(0), "Invalid address");

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

âš ï¸  HIGH: Function 'withdraw' may be vulnerable to withdrawal DOS attack. No circuit breaker or emergency withdrawal mechanism. Vault cannot be paused during attacks or emergencies Attacker can block withdrawals, causing funds to be locked indefinitely.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:14
   â”œâ”€ Detector: vault-withdrawal-dos
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Protect 'withdraw' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.

âš ï¸  HIGH: Function 'withdraw' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'withdraw'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš¡ MEDIUM: Function 'withdraw' is missing transaction deadline. Missing transaction deadline. Withdrawal operation 'withdraw' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'withdraw'. Implement: (1) Add 'deadline' parameter: function withdraw(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

ğŸ”¥ CRITICAL: Lending protocol function 'withdraw' has borrow bypass vulnerabilities: Collateral withdrawal doesn't validate health factor after removal, may allow withdrawal that causes undercollateralization
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:14
   â”œâ”€ Detector: lending-borrow-bypass
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Secure lending function 'withdraw': Calculate and validate health factor before borrow, enforce collateral factor (LTV) limits, add reentrancy guards, implement same-block borrow restrictions for flash loans, update state before external calls (checks-effects-interactions pattern)

âš ï¸  HIGH: Contract 'MaliciousLibrary' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:93:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

âš¡ MEDIUM: Function 'setOwner' in proxy contract may shadow implementation. Function 'setOwner' may shadow implementation's function. In transparent proxies, use ifAdmin pattern to separate admin and user calls Real-world impact: Similar to issues in various proxy implementations where admin functions were shadowed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:102:14
   â”œâ”€ Detector: fallback-function-shadowing
   â””â”€ CWE: CWE-670

ğŸ”¥ CRITICAL: Function 'withdraw' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'withdraw'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

ğŸ”¥ CRITICAL: Implementation contract 'MaliciousLibrary' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:50:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Proxy contract 'MaliciousLibrary' has state variable 'uint256)' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:60:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'MaliciousLibrary' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:12:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'MaliciousLibrary' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:13:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'MaliciousLibrary' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'forward' in contract 'MaliciousLibrary' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:24:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'execute' in contract 'MaliciousLibrary' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:31:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'execute' in contract 'MaliciousLibrary' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

âš ï¸  HIGH: Function 'executeLogic' in contract 'MaliciousLibrary' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:124:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

ğŸ”¥ CRITICAL: Contract 'MaliciousLibrary' allows instant liquidity add/remove without time lock. Attackers can perform JIT liquidity attacks by adding liquidity just before large swaps and removing immediately after to capture fees.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:68:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add time lock for liquidity operations:

mapping(address => uint256) public depositTime;
uint256 public constant MIN_LOCK_TIME = 1 hours;

function addLiquidity(uint256 amount) external {
depositTime[msg.sender] = block.timestamp;
// ... add liquidity
}

function removeLiquidity(uint256 shares) external {
require(
block.timestamp >= depositTime[msg.sender] + MIN_LOCK_TIME,
"Liquidity locked"
);
// ... remove liquidity
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'MaliciousLibrary' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'MaliciousLibrary' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

âš ï¸  HIGH: Function 'destroy' in contract 'MaliciousLibrary' uses selfdestruct with a parameterized recipient. Attackers may be able to control the recipient address.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:137:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Use fixed recipient for selfdestruct:

address constant TREASURY = 0x...;

function destroy() external onlyOwner {
selfdestruct(payable(TREASURY));
}

Or use withdrawal pattern instead of selfdestruct.

âš ï¸  HIGH: Function 'destroy' in contract 'MaliciousLibrary' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:49:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'destroy' in contract 'MaliciousLibrary' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:135:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'destroy' in contract 'MaliciousLibrary' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:50:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'MaliciousLibrary' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:15:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'MaliciousLibrary' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:63:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'MaliciousLibrary' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:151:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MaliciousLibrary' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:82:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MaliciousLibrary' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:163:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'MaliciousLibrary' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:15:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'MaliciousLibrary' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:63:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'MaliciousLibrary' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:151:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'MaliciousLibrary' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'MaliciousLibrary' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'MaliciousLibrary' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'MaliciousLibrary' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

âš ï¸  HIGH: Function 'forward' in contract 'MaliciousLibrary' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:21:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'execute' in contract 'MaliciousLibrary' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'withdraw' in contract 'MaliciousLibrary' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'executeLogic' in contract 'MaliciousLibrary' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:124:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'destroy' in contract 'MaliciousLibrary' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:135:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:115:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

âš¡ MEDIUM: Function 'executeLogic' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:124:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

ğŸ”¥ CRITICAL: Function 'executeLogic' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:124:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'executeLogic'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

âš ï¸  HIGH: Function 'register' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:119:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'register'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function 'executeLogic' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:124:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'executeLogic'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš¡ MEDIUM: Function 'executeLogic' is missing transaction deadline. Missing transaction deadline. Order execution operation 'executeLogic' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:124:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'executeLogic'. Implement: (1) Add 'deadline' parameter: function executeLogic(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

ğŸ”¥ CRITICAL: Contract 'VulnerableRegistry' declares storage variables directly without using Diamond Storage pattern. This creates collision risk when multiple facets share the same proxy storage. Direct storage at sequential slots (0, 1, 2...) will collide across facets, corrupting state and causing critical failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:111:10
   â”œâ”€ Detector: diamond-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Implement Diamond Storage pattern for 'VulnerableRegistry': (1) Create a library with 'bytes32 constant STORAGE_POSITION = keccak256("diamond.storage.vulnerableregistry")' (2) Define a struct containing all storage variables, (3) Create a function returning 'Storage storage ds' using assembly to set slot to STORAGE_POSITION, (4) Access all storage through this function instead of direct variables, (5) Use unique namespace per facet to guarantee isolation.

âš ï¸  HIGH: Contract 'VulnerableRegistry' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:111:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

ğŸ”¥ CRITICAL: Missing access control in 'executeLogic' - allows arbitrary execution
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:124:0
   â”œâ”€ Detector: eip7702-delegate-access-control
   â””â”€ Fix: Fix: Add owner/authorization check:

address public owner;

function execute(address target, bytes calldata data) external payable {
require(msg.sender == owner, "Not authorized");
(bool success, ) = target.call{value: msg.value}(data);
require(success, "Call failed");
}

ğŸ”¥ CRITICAL: Implementation contract 'VulnerableRegistry' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:50:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Proxy contract 'VulnerableRegistry' has state variable 'uint256)' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:60:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'VulnerableRegistry' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:12:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'VulnerableRegistry' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:13:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'VulnerableRegistry' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'forward' in contract 'VulnerableRegistry' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:24:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'execute' in contract 'VulnerableRegistry' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:31:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'execute' in contract 'VulnerableRegistry' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

âš ï¸  HIGH: Function 'executeLogic' in contract 'VulnerableRegistry' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:124:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

ğŸ”¥ CRITICAL: Contract 'VulnerableRegistry' allows instant liquidity add/remove without time lock. Attackers can perform JIT liquidity attacks by adding liquidity just before large swaps and removing immediately after to capture fees.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:68:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add time lock for liquidity operations:

mapping(address => uint256) public depositTime;
uint256 public constant MIN_LOCK_TIME = 1 hours;

function addLiquidity(uint256 amount) external {
depositTime[msg.sender] = block.timestamp;
// ... add liquidity
}

function removeLiquidity(uint256 shares) external {
require(
block.timestamp >= depositTime[msg.sender] + MIN_LOCK_TIME,
"Liquidity locked"
);
// ... remove liquidity
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableRegistry' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableRegistry' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

âš ï¸  HIGH: Function 'destroy' in contract 'VulnerableRegistry' uses selfdestruct with a parameterized recipient. Attackers may be able to control the recipient address.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:137:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Use fixed recipient for selfdestruct:

address constant TREASURY = 0x...;

function destroy() external onlyOwner {
selfdestruct(payable(TREASURY));
}

Or use withdrawal pattern instead of selfdestruct.

âš ï¸  HIGH: Function 'destroy' in contract 'VulnerableRegistry' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:49:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'destroy' in contract 'VulnerableRegistry' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:135:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'destroy' in contract 'VulnerableRegistry' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:50:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'VulnerableRegistry' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:15:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableRegistry' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:63:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableRegistry' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:151:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableRegistry' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:82:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableRegistry' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:163:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableRegistry' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:15:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableRegistry' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:63:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableRegistry' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:151:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableRegistry' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableRegistry' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableRegistry' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableRegistry' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

âš ï¸  HIGH: Function 'forward' in contract 'VulnerableRegistry' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:21:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'execute' in contract 'VulnerableRegistry' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'withdraw' in contract 'VulnerableRegistry' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'executeLogic' in contract 'VulnerableRegistry' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:124:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'destroy' in contract 'VulnerableRegistry' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:135:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

ğŸ”¥ CRITICAL: Function 'destroy' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:135:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'destroy'

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:135:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

ğŸ”¥ CRITICAL: Function 'destroy' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:135:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'destroy'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

âš ï¸  HIGH: Function 'destroy' contains selfdestruct abuse vulnerability. Selfdestruct is publicly accessible without access control, allowing anyone to destroy the contract Selfdestruct permanently destroys the contract and can force-send ether to any address, bypassing fallback functions and breaking assumptions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:135:14
   â”œâ”€ Detector: selfdestruct-abuse
   â”œâ”€ CWE: CWE-670
   â””â”€ Fix: Restrict or remove selfdestruct in 'destroy'. Add access control (onlyOwner), implement time-lock, or use withdraw pattern instead of selfdestruct. Consider that contracts expecting ether may not have payable fallback.

ğŸ”¥ CRITICAL: Function 'destroy' has upgradeable proxy vulnerability. Delegatecall without validating implementation address, can delegate to non-contract or malicious code Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:135:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'destroy'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'destroy' contains selfdestruct that publicly accessible without access control. Selfdestruct permanently destroys the contract and sends all remaining Ether to the specified address, bypassing any fallback functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:135:14
   â”œâ”€ Detector: swc106-unprotected-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Protect selfdestruct in 'destroy' with:
1. Add 'onlyOwner' modifier or equivalent access control
2. Implement a timelock (e.g., 48-hour delay) before destruction
3. Consider using upgradeable proxy patterns instead of selfdestruct
4. If selfdestruct is necessary, hardcode a safe beneficiary address
Note: After EIP-6780 (Cancun), selfdestruct only destroys in same transaction as creation

ğŸ”¥ CRITICAL: Implementation contract 'MaliciousLogic' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:50:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Proxy contract 'MaliciousLogic' has state variable 'uint256)' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:60:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'MaliciousLogic' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:12:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'MaliciousLogic' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:13:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'MaliciousLogic' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'forward' in contract 'MaliciousLogic' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:24:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'execute' in contract 'MaliciousLogic' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:31:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'execute' in contract 'MaliciousLogic' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

âš ï¸  HIGH: Function 'executeLogic' in contract 'MaliciousLogic' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:124:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

ğŸ”¥ CRITICAL: Contract 'MaliciousLogic' allows instant liquidity add/remove without time lock. Attackers can perform JIT liquidity attacks by adding liquidity just before large swaps and removing immediately after to capture fees.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:68:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add time lock for liquidity operations:

mapping(address => uint256) public depositTime;
uint256 public constant MIN_LOCK_TIME = 1 hours;

function addLiquidity(uint256 amount) external {
depositTime[msg.sender] = block.timestamp;
// ... add liquidity
}

function removeLiquidity(uint256 shares) external {
require(
block.timestamp >= depositTime[msg.sender] + MIN_LOCK_TIME,
"Liquidity locked"
);
// ... remove liquidity
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'MaliciousLogic' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'MaliciousLogic' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

âš ï¸  HIGH: Function 'destroy' in contract 'MaliciousLogic' uses selfdestruct with a parameterized recipient. Attackers may be able to control the recipient address.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:137:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Use fixed recipient for selfdestruct:

address constant TREASURY = 0x...;

function destroy() external onlyOwner {
selfdestruct(payable(TREASURY));
}

Or use withdrawal pattern instead of selfdestruct.

âš ï¸  HIGH: Function 'destroy' in contract 'MaliciousLogic' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:49:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'destroy' in contract 'MaliciousLogic' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:135:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'destroy' in contract 'MaliciousLogic' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:50:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'MaliciousLogic' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:15:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'MaliciousLogic' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:63:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'MaliciousLogic' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:151:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MaliciousLogic' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:82:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MaliciousLogic' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:163:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'MaliciousLogic' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:15:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'MaliciousLogic' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:63:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'MaliciousLogic' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:151:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'MaliciousLogic' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'MaliciousLogic' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'MaliciousLogic' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'MaliciousLogic' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

âš ï¸  HIGH: Function 'forward' in contract 'MaliciousLogic' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:21:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'execute' in contract 'MaliciousLogic' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'withdraw' in contract 'MaliciousLogic' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'executeLogic' in contract 'MaliciousLogic' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:124:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'destroy' in contract 'MaliciousLogic' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:135:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

ğŸ”¥ CRITICAL: Function 'initialize' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:157:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'initialize'

âš ï¸  HIGH: Initializer function 'initialize' lacks access control and can be called by anyone
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:157:14
   â”œâ”€ Detector: unprotected-initializer
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier to 'initialize' or ensure it can only be called once during deployment

âš ï¸  HIGH: State variable 'initialized' is modified without proper validation or state checks
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:160:9
   â”œâ”€ Detector: invalid-state-transition
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Add proper validation before modifying state variables

âš ï¸  HIGH: Address parameter '_owner' in function 'initialize' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:157:33
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_owner != address(0), "Zero address not allowed");

âš ï¸  HIGH: Parameter '_owner' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:157:33
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_owner != address(0), "Invalid address");

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:151:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

ğŸ”¥ CRITICAL: Function '' uses delegatecall which can cause storage collision. Delegatecall to variable target without storage layout verification Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:163:5
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in ''. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function '' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:163:5
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in ''. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:151:5
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:163:5
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

âš ï¸  HIGH: Function '' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:163:5
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in ''. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

ğŸ“ LOW: Function 'initialize' contains excessive gas usage pattern. Multiple storage reads detected (5). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:157:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'initialize'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

âš ï¸  HIGH: Contract 'UninitializedProxy' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:145:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

âš ï¸  HIGH: Function '' performs delegatecall in fallback/receive without access control. Fallback/receive function performs delegatecall without validating the caller. Any address can trigger this by calling a non-existent function or sending ETH. This allows any caller to execute arbitrary code by calling non-existent functions or sending ETH to the contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:163:5
   â”œâ”€ Detector: fallback-delegatecall-unprotected
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Add access control to fallback function ''. Validate implementation address before delegatecall. Use modifiers like 'onlyOwner' or check msg.sender explicitly. Consider using OpenZeppelin's transparent or UUPS proxy patterns.

âš¡ MEDIUM: Function 'initialize' in proxy contract may shadow implementation. Function 'initialize' may shadow implementation's function. In transparent proxies, use ifAdmin pattern to separate admin and user calls Real-world impact: Similar to issues in various proxy implementations where admin functions were shadowed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:157:14
   â”œâ”€ Detector: fallback-function-shadowing
   â””â”€ CWE: CWE-670

âš ï¸  HIGH: Function '' uses delegatecall to mutable library address. Delegatecall to mutable library 'implementation' - library address can be changed after deployment
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:163:5
   â”œâ”€ Detector: delegatecall-untrusted-library
   â””â”€ CWE: CWE-494

ğŸ”¥ CRITICAL: Unprotected initialization in 'initialize' - vulnerable to front-running takeover ($1.54M August 2025 attack)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:157:0
   â”œâ”€ Detector: eip7702-init-frontrun
   â””â”€ Fix: EIP-7702 Front-Running Attack:

Current code (VULNERABLE):
function initialize(...) public {
require(owner == address(0));
owner = newOwner;  // âŒ Attacker can front-run!
}

Attack sequence:
1. User signs EIP-7702 authorization
2. Attacker sees authorization in mempool
3. Attacker front-runs with initialize(attackerAddress)
4. User's delegation is now controlled by attacker
5. Attacker drains all assets

Fix 1: Authorization-based initialization
function initialize(address _owner, bytes memory signature) public {
require(owner == address(0));

// âœ… Verify user signed this specific initialization
bytes32 hash = keccak256(abi.encodePacked(_owner, address(this)));
address signer = ECDSA.recover(hash, signature);
require(signer == _owner, "Invalid signature");

owner = _owner;
}

Fix 2: Constructor initialization (if possible)
constructor(address _owner) {
owner = _owner;  // âœ… Set during deployment
}

Fix 3: Factory pattern with immediate initialization
contract DelegateFactory {
function createDelegate() public returns (address) {
Delegate delegate = new Delegate(msg.sender);
return address(delegate);
}
}

Fix 4: Commit-reveal with time-lock
mapping(bytes32 => uint256) public commitments;

function commitInit(bytes32 commitment) public {
commitments[commitment] = block.timestamp;
}

function initialize(address _owner, bytes32 salt) public {
bytes32 commitment = keccak256(abi.encodePacked(_owner, salt));
require(commitments[commitment] > 0, "No commitment");
require(block.timestamp >= commitments[commitment] + 10 minutes);

owner = _owner;
}

Real-World Loss: $1.54M (August 2025)

ğŸ”¥ CRITICAL: Implementation contract 'UninitializedProxy' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:50:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Proxy contract 'UninitializedProxy' has state variable 'uint256)' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:60:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'UninitializedProxy' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:12:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'UninitializedProxy' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:13:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'UninitializedProxy' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'forward' in contract 'UninitializedProxy' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:24:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'execute' in contract 'UninitializedProxy' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:31:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'execute' in contract 'UninitializedProxy' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

âš ï¸  HIGH: Function 'executeLogic' in contract 'UninitializedProxy' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:124:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

ğŸ”¥ CRITICAL: Contract 'UninitializedProxy' allows instant liquidity add/remove without time lock. Attackers can perform JIT liquidity attacks by adding liquidity just before large swaps and removing immediately after to capture fees.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:68:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add time lock for liquidity operations:

mapping(address => uint256) public depositTime;
uint256 public constant MIN_LOCK_TIME = 1 hours;

function addLiquidity(uint256 amount) external {
depositTime[msg.sender] = block.timestamp;
// ... add liquidity
}

function removeLiquidity(uint256 shares) external {
require(
block.timestamp >= depositTime[msg.sender] + MIN_LOCK_TIME,
"Liquidity locked"
);
// ... remove liquidity
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'UninitializedProxy' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'UninitializedProxy' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

âš ï¸  HIGH: Function 'destroy' in contract 'UninitializedProxy' uses selfdestruct with a parameterized recipient. Attackers may be able to control the recipient address.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:137:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Use fixed recipient for selfdestruct:

address constant TREASURY = 0x...;

function destroy() external onlyOwner {
selfdestruct(payable(TREASURY));
}

Or use withdrawal pattern instead of selfdestruct.

âš ï¸  HIGH: Function 'destroy' in contract 'UninitializedProxy' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:49:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'destroy' in contract 'UninitializedProxy' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:135:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'destroy' in contract 'UninitializedProxy' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:50:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'UninitializedProxy' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:15:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'UninitializedProxy' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:63:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'UninitializedProxy' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:151:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Proxy fallback in contract 'UninitializedProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:82:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'UninitializedProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:163:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'UninitializedProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:15:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'UninitializedProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:63:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'UninitializedProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:151:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'UninitializedProxy' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'UninitializedProxy' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'UninitializedProxy' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'UninitializedProxy' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:96:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

âš ï¸  HIGH: Function 'forward' in contract 'UninitializedProxy' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:21:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'execute' in contract 'UninitializedProxy' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:29:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'withdraw' in contract 'UninitializedProxy' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:73:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'executeLogic' in contract 'UninitializedProxy' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:124:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'destroy' in contract 'UninitializedProxy' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegateCall.sol:135:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Address parameter 'target' in function 'nestedConditionalDelegate' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:44:48
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(target != address(0), "Zero address not allowed");

âš ï¸  HIGH: Address parameter 'target' in function 'tryCatchDelegate' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:63:39
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(target != address(0), "Zero address not allowed");

âš ï¸  HIGH: Address parameter 'target' in function 'externalDelegate' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:73:39
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(target != address(0), "Zero address not allowed");

âš ï¸  HIGH: Address parameter 'target' in function 'switchStyleDelegate' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:79:56
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(target != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter 'target' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:44:48
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(target != address(0), "Invalid address");

ğŸ“ LOW: Parameter 'target' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:63:39
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(target != address(0), "Invalid address");

ğŸ“ LOW: Parameter 'target' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:73:39
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(target != address(0), "Invalid address");

ğŸ“ LOW: Parameter 'target' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:79:56
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(target != address(0), "Invalid address");

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:26:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

âš¡ MEDIUM: Function 'conditionalDelegate' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:32:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš¡ MEDIUM: Function 'nestedConditionalDelegate' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:44:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš¡ MEDIUM: Function 'ternaryDelegate' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:55:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš¡ MEDIUM: Function 'tryCatchDelegate' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:63:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš¡ MEDIUM: Function 'externalDelegate' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:73:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš¡ MEDIUM: Function 'switchStyleDelegate' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:79:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

ğŸ”¥ CRITICAL: Function 'conditionalDelegate' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:32:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'conditionalDelegate'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'nestedConditionalDelegate' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:44:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'nestedConditionalDelegate'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'ternaryDelegate' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:55:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'ternaryDelegate'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'tryCatchDelegate' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:63:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'tryCatchDelegate'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'externalDelegate' uses delegatecall which can cause storage collision. Delegatecall to variable target without storage layout verification Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:73:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'externalDelegate'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'switchStyleDelegate' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:79:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'switchStyleDelegate'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'conditionalDelegate' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:32:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'conditionalDelegate'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'nestedConditionalDelegate' contains dangerous delegatecall pattern. Delegatecall target is controlled by function parameters or user input, allowing arbitrary code execution Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:44:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'nestedConditionalDelegate'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'ternaryDelegate' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:55:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'ternaryDelegate'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'tryCatchDelegate' contains dangerous delegatecall pattern. Delegatecall target is controlled by function parameters or user input, allowing arbitrary code execution Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:63:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'tryCatchDelegate'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'externalDelegate' contains dangerous delegatecall pattern. Delegatecall target is controlled by function parameters or user input, allowing arbitrary code execution Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:73:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'externalDelegate'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'switchStyleDelegate' contains dangerous delegatecall pattern. Delegatecall target is controlled by function parameters or user input, allowing arbitrary code execution Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:79:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'switchStyleDelegate'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:26:5
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'conditionalDelegate' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:32:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'conditionalDelegate'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'ternaryDelegate' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:55:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'ternaryDelegate'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'tryCatchDelegate' has upgradeable proxy vulnerability. Delegatecall without validating implementation address, can delegate to non-contract or malicious code Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:63:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'tryCatchDelegate'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'switchStyleDelegate' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:79:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'switchStyleDelegate'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

âš ï¸  HIGH: Function 'conditionalDelegate' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:32:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'conditionalDelegate'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš ï¸  HIGH: Function 'nestedConditionalDelegate' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:44:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'nestedConditionalDelegate'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš ï¸  HIGH: Function 'ternaryDelegate' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:55:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'ternaryDelegate'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš ï¸  HIGH: Function 'tryCatchDelegate' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:63:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'tryCatchDelegate'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš ï¸  HIGH: Function 'externalDelegate' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:73:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'externalDelegate'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš ï¸  HIGH: Function 'switchStyleDelegate' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:79:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'switchStyleDelegate'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

ğŸ“ LOW: Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:32:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:44:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:55:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Small uint type as standalone storage variable. Use uint256 or pack with other variables Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:79:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:359:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Function 'switchStyleDelegate' contains redundant checks. Duplicate require check: 'success' appears multiple times Redundant checks waste gas and increase transaction costs unnecessarily.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:79:14
   â”œâ”€ Detector: redundant-checks
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Remove redundant checks in 'switchStyleDelegate'. Consider: (1) Eliminate duplicate require() statements, (2) Combine multiple checks into single require(), (3) Remove overflow checks in Solidity >=0.8, (4) Avoid checking same condition in modifier and function, (5) Use custom errors instead of require with strings.

âš ï¸  HIGH: Contract has centralization risk. Contract uses single owner without multi-signature protection. Single private key compromise leads to total contract control Single point of failure can lead to fund loss, governance attacks, or complete system compromise.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:1:0
   â”œâ”€ Detector: centralization-risk
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.

âš ï¸  HIGH: Delegation contract missing recovery mechanism. No recovery mechanism found - users cannot undo delegation Without recovery, hardware wallet users lose access if delegation target is compromised or becomes incompatible.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:1:0
   â”œâ”€ Detector: hardware-wallet-delegation
   â”œâ”€ CWE: CWE-672
   â””â”€ Fix: Implement delegation recovery: (1) Add removeDelegation function, (2) Allow switching delegation targets, (3) Implement emergency mode fallback, (4) Support direct EOA transactions, (5) Require hardware wallet signature for changes.

âš ï¸  HIGH: Delegation target not validated for interface compatibility. Missing interface validation can cause hardware wallet to delegate to incompatible code, bricking the account.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:1:0
   â”œâ”€ Detector: hardware-wallet-delegation
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate delegation target: (1) Check supportsInterface for EIP-165, (2) Verify required functions exist, (3) Test delegation in simulation first, (4) Implement delegation preview/confirmation, (5) Maintain whitelist of verified delegation targets.

âš¡ MEDIUM: Rebalancing function present - creates predictable MEV opportunity for backrunners
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:1:1
   â”œâ”€ Detector: mev-backrun-opportunities
   â””â”€ Fix: Use batch auctions or time-weighted execution to reduce MEV extraction

âš¡ MEDIUM: Public arbitrage function - creates PGA as bots compete for profit
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:1:1
   â”œâ”€ Detector: mev-priority-gas-auction
   â””â”€ Fix: Capture MEV for protocol via auction mechanism or restrict to specific keepers

ğŸ“ LOW: Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:2:0
   â”œâ”€ Detector: floating-pragma
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:22:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

ğŸ”¥ CRITICAL: Function 'nestedConditionalDelegate' performs delegatecall with user-controlled target. Delegatecall target is derived from function parameters or user input, allowing callers to specify arbitrary code to execute. This allows arbitrary code execution in the contract's storage context, enabling complete takeover and fund theft.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:44:14
   â”œâ”€ Detector: delegatecall-user-controlled
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Remove user control over delegatecall target in 'nestedConditionalDelegate'. Use a whitelist of approved addresses: mapping(address => bool) approvedTargets; Or avoid delegatecall entirely and use regular external calls.

ğŸ”¥ CRITICAL: Function 'tryCatchDelegate' performs delegatecall with user-controlled target. Delegatecall target is derived from function parameters or user input, allowing callers to specify arbitrary code to execute. This allows arbitrary code execution in the contract's storage context, enabling complete takeover and fund theft.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:63:14
   â”œâ”€ Detector: delegatecall-user-controlled
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Remove user control over delegatecall target in 'tryCatchDelegate'. Use a whitelist of approved addresses: mapping(address => bool) approvedTargets; Or avoid delegatecall entirely and use regular external calls.

ğŸ”¥ CRITICAL: Function 'externalDelegate' performs delegatecall with user-controlled target. Delegatecall target is derived from function parameters or user input, allowing callers to specify arbitrary code to execute. This allows arbitrary code execution in the contract's storage context, enabling complete takeover and fund theft.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:73:14
   â”œâ”€ Detector: delegatecall-user-controlled
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Remove user control over delegatecall target in 'externalDelegate'. Use a whitelist of approved addresses: mapping(address => bool) approvedTargets; Or avoid delegatecall entirely and use regular external calls.

ğŸ”¥ CRITICAL: Function 'switchStyleDelegate' performs delegatecall with user-controlled target. Delegatecall target is derived from function parameters or user input, allowing callers to specify arbitrary code to execute. This allows arbitrary code execution in the contract's storage context, enabling complete takeover and fund theft.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:79:14
   â”œâ”€ Detector: delegatecall-user-controlled
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Remove user control over delegatecall target in 'switchStyleDelegate'. Use a whitelist of approved addresses: mapping(address => bool) approvedTargets; Or avoid delegatecall entirely and use regular external calls.

âš ï¸  HIGH: Delegatecall in function 'tryCatchDelegate' does not properly check return value. Delegatecall return value captured but not validated. Add require(success, ...) or if (!success) revert(...) Real-world impact: Silent failures can lead to state corruption, failed upgrades, and fund loss. Similar to issues in proxy contracts where failed initializations went undetected.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:63:14
   â”œâ”€ Detector: delegatecall-return-ignored
   â””â”€ CWE: CWE-252

âš¡ MEDIUM: Signatures without expiration/deadline (indefinite validity risk)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:0:0
   â”œâ”€ Detector: multisig-bypass
   â”œâ”€ CWE: CWE-347
   â””â”€ Fix: Add expiration: Include deadline in signature data; require(block.timestamp <= deadline, "Signature expired"); Prevents execution of stale signatures.

âš¡ MEDIUM: EIP-7702 delegate uses storage - verify no collision with EOA state
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:1:0
   â”œâ”€ Detector: eip7702-storage-collision
   â””â”€ Fix: Use EIP-7201 namespaced storage to avoid collisions:

bytes32 private constant STORAGE_LOCATION = 
keccak256("myprotocol.delegate.storage");

struct DelegateStorage {
address owner;
mapping(address => uint256) balances;
}

function _getStorage() private pure returns (DelegateStorage storage $) {
assembly { $.slot := STORAGE_LOCATION }
}

âš ï¸  HIGH: Sensitive data 'private' in 'private' variable - all blockchain storage is publicly readable
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:359:0
   â”œâ”€ Detector: private-variable-exposure
   â””â”€ Fix: CRITICAL: 'private' visibility does NOT encrypt data!

All blockchain storage is publicly readable via:
- eth_getStorageAt RPC call
- Block explorers
- Archive nodes

âŒ This is INSECURE:
string private password = "mysecret123";

âœ… Correct approaches:

1. NEVER store secrets on-chain
2. Store hashes instead:
bytes32 public passwordHash = keccak256("password");

3. Use commit-reveal for sensitive values:
bytes32 public commitment = keccak256(abi.encode(value, salt));

4. For truly private data, use off-chain storage or ZK proofs

âš ï¸  HIGH: Potential division before multiplication - causes precision loss (OWASP 2025)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:1:0
   â”œâ”€ Detector: logic-error-patterns
   â””â”€ Fix: âŒ PRECISION LOSS ($63.8M in losses):
uint256 reward = (amount / totalSupply) * rewardRate;
// Result: 0 if amount < totalSupply!

âœ… CORRECT ORDER:
uint256 reward = (amount * rewardRate) / totalSupply;
// Maximizes precision, multiply before divide

âœ… BEST: Use fixed-point math:
uint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;

Real incidents:
- Cork Protocol: $11M (May 2025) - Division rounding
- SIR.trading: $355K (March 2025) - Reward calculation
- Multiple 2024 incidents: $63.8M total

âš ï¸  HIGH: Assembly arithmetic detected - no overflow protection! ($223M Cetus DEX)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:1:0
   â”œâ”€ Detector: post-080-overflow
   â””â”€ Fix: ğŸš¨ CRITICAL: Assembly has NO overflow protection!

Real incident: Cetus DEX - $223M loss (May 2025)
Cause: Assembly arithmetic overflow

âŒ VULNERABLE (Cetus-style vulnerability):
assembly {
let result := add(a, b)  // NO OVERFLOW CHECK!
let product := mul(x, y) // NO OVERFLOW CHECK!
mstore(0x00, result)
}

âœ… SOLUTION 1 - Add manual checks:
assembly {
let result := add(a, b)
// Manual overflow check
if lt(result, a) {
revert(0, 0)  // Overflow detected
}
}

âœ… SOLUTION 2 - Use Solidity instead:
// Let Solidity handle overflow checks
uint256 result = a + b;  // Automatic overflow check

âœ… SOLUTION 3 - SafeMath for assembly:
function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c;
assembly {
c := add(a, b)
}
require(c >= a, "Overflow");  // Check outside assembly
return c;
}

Assembly arithmetic operations with NO checks:
- add(a, b)     â†’ wraps on overflow
- sub(a, b)     â†’ wraps on underflow
- mul(a, b)     â†’ wraps on overflow
- div(a, b)     â†’ returns 0 if b is 0 (no revert!)

âš ï¸ Only use assembly arithmetic when absolutely necessary
and with manual overflow checks!

ğŸ“ LOW: Type casting to smaller uint - verify no overflow on downcast
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:1:0
   â”œâ”€ Detector: post-080-overflow
   â””â”€ Fix: Downcasting can silently overflow even in Solidity 0.8.0+!

âŒ UNSAFE DOWNCAST:
uint256 bigValue = 1000;
uint8 smallValue = uint8(bigValue);  // Wraps to 232! (1000 % 256)

âœ… SAFE DOWNCAST with validation:
uint256 bigValue = 1000;
require(bigValue <= type(uint8).max, "Value too large");
uint8 smallValue = uint8(bigValue);  // Safe now

âœ… USE SafeCast library (OpenZeppelin):
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

uint256 bigValue = 1000;
uint8 smallValue = SafeCast.toUint8(bigValue);  // Reverts if > 255

Type limits:
- uint8:   0 to 255
- uint16:  0 to 65,535
- uint32:  0 to 4,294,967,295
- uint64:  0 to 18,446,744,073,709,551,615
- uint256: 0 to 2^256-1

âš ï¸  HIGH: Callback function lacks sender validation - attacker can trigger malicious reentry
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:1:1
   â”œâ”€ Detector: hook-reentrancy-enhanced
   â””â”€ Fix: Validate callback sender (e.g., require(msg.sender == pool)) to prevent unauthorized reentry

ğŸ”¥ CRITICAL: Proxy contract 'ControlFlowDelegatecall' has state variable 'address[]' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:171:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:6:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:8:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:10:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:12:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:13:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:35:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:47:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:48:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:54:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:58:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:62:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:68:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:74:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:78:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:81:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:87:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:88:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:105:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:111:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:112:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:136:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:139:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:141:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:150:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:153:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:157:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:181:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:191:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:197:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:201:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:203:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:208:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:210:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:213:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:219:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:222:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:225:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:244:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:246:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:250:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:252:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:256:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:258:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:267:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:268:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:272:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:274:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:282:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:283:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:287:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:290:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:296:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:308:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:320:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:321:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:327:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:342:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:354:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:366:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:381:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'ControlFlowDelegatecall' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:23:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'ControlFlowDelegatecall' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:24:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'ControlFlowDelegatecall' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:99:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'nestedConditionalDelegate' in contract 'ControlFlowDelegatecall' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:48:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'tryCatchDelegate' in contract 'ControlFlowDelegatecall' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:68:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'multiExecute' in contract 'ControlFlowDelegatecall' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

âš ï¸  HIGH: Function 'executeWithCallback' in contract 'ControlFlowDelegatecall' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:273:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

âš ï¸  HIGH: Function 'callback' in contract 'ControlFlowDelegatecall' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:281:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

ğŸ”¥ CRITICAL: Function 'executeWithCallback' in contract 'ControlFlowDelegatecall' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:276:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

âš ï¸  HIGH: Constructor in contract 'ControlFlowDelegatecall' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:26:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'batchDelegateFor' in contract 'ControlFlowDelegatecall' uses delegatecall in multicall without reentrancy guard. Cross-function reentrancy is possible between batched calls.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:1
   â”œâ”€ Detector: batch-cross-function-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Protect against cross-function reentrancy in multicall:

1. Add reentrancy guard to multicall function:
function multicall(...) external nonReentrant { ... }

2. Use function-level locking for state-changing operations
3. Consider disabling multicall for sensitive functions

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'ControlFlowDelegatecall' performs batch operations that sequencers could exploit through partial execution ordering.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Improve batch operation safety:

1. Make batch operations atomic (all-or-nothing)
2. Add revert on partial failure
3. Implement batch ordering guarantees
4. Consider splitting into individual transactions

âš ï¸  HIGH: Function 'addImplementation' in contract 'ControlFlowDelegatecall' has DoS vulnerability: Unbounded push to array 'implementations'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:174:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'ControlFlowDelegatecall' iterates over unbounded array: Iteration over unbounded array 'implementations'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:180:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Contract 'ControlFlowDelegatecall' has unbounded storage array 'implementations'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:171:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'ControlFlowDelegatecall' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:180:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'multiExecute' in contract 'ControlFlowDelegatecall' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:202:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'ControlFlowDelegatecall' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:211:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'ControlFlowDelegatecall' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:212:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'ControlFlowDelegatecall' contains nested loops. O(n*m) operations can easily exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:211:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid nested loops or add strict bounds:

1. Use mappings instead of nested array iteration
2. Pre-compute results off-chain
3. Split into multiple transactions
4. Add strict size limits on both dimensions

âš ï¸  HIGH: Function 'storageWriteDelegate' in contract 'ControlFlowDelegatecall' has delegatecall to self: Possible delegatecall to self via stored address. This can cause infinite loops or unexpected state changes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:342:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Avoid delegatecall to self:

1. Never use address(this) as delegatecall target
2. Validate target != address(this) before delegatecall
3. Use direct internal calls instead
4. If multicall needed, use call instead of delegatecall

âš ï¸  HIGH: Function 'conditionalDelegate' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:32:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'nestedConditionalDelegate' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:44:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'ternaryDelegate' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:55:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'tryCatchDelegate' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:63:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'externalDelegate' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:73:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'switchStyleDelegate' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:79:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'assemblyDelegate' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:106:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'gasOptimizedDelegate' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:137:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'manualMemoryDelegate' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:151:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'batchDelegateWhile' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:187:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'multiExecute' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:209:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'doWhileDelegate' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:220:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'publicExecute' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:245:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function '_internalDelegate' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:251:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'chainedExecute' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:257:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function '_stepTwo' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:266:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'executeWithCallback' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:273:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'callback' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:281:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'executeWithModifier' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:295:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'dynamicDelegate' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:309:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'manipulatedReturnDelegate' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:326:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'storageWriteDelegate' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:338:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'eventEmittingDelegate' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:352:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'reentrancyDelegate' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:361:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'exploit' in contract 'ControlFlowDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:380:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Address parameter 'target' in function 'gasOptimizedDelegate' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:137:43
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(target != address(0), "Zero address not allowed");

âš ï¸  HIGH: Address parameter 'target' in function 'manualMemoryDelegate' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:151:43
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(target != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter 'target' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:137:43
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(target != address(0), "Invalid address");

ğŸ“ LOW: Parameter 'target' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:151:43
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(target != address(0), "Invalid address");

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:101:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

âš¡ MEDIUM: Function 'assemblyDelegate' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:106:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš¡ MEDIUM: Function 'gasOptimizedDelegate' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:137:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš¡ MEDIUM: Function 'manualMemoryDelegate' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:151:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

ğŸ”¥ CRITICAL: Function 'assemblyDelegate' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:106:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'assemblyDelegate'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'gasOptimizedDelegate' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:137:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'gasOptimizedDelegate'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'manualMemoryDelegate' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:151:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'manualMemoryDelegate'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'assemblyDelegate' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:106:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'assemblyDelegate'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'gasOptimizedDelegate' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:137:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'gasOptimizedDelegate'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'manualMemoryDelegate' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:151:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'manualMemoryDelegate'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:101:5
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'assemblyDelegate' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:106:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'assemblyDelegate'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'gasOptimizedDelegate' has upgradeable proxy vulnerability. Delegatecall without validating implementation address, can delegate to non-contract or malicious code Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:137:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'gasOptimizedDelegate'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'manualMemoryDelegate' has upgradeable proxy vulnerability. Delegatecall without validating implementation address, can delegate to non-contract or malicious code Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:151:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'manualMemoryDelegate'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

âš ï¸  HIGH: Function 'gasOptimizedDelegate' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:137:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'gasOptimizedDelegate'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš¡ MEDIUM: Function 'assemblyDelegate' contains variable shadowing. Local variable 'target' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:106:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'assemblyDelegate'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:98:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

ğŸ”¥ CRITICAL: Function 'assemblyDelegate' performs delegatecall with user-controlled target. Delegatecall target is derived from function parameters or user input, allowing callers to specify arbitrary code to execute. This allows arbitrary code execution in the contract's storage context, enabling complete takeover and fund theft.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:106:14
   â”œâ”€ Detector: delegatecall-user-controlled
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Remove user control over delegatecall target in 'assemblyDelegate'. Use a whitelist of approved addresses: mapping(address => bool) approvedTargets; Or avoid delegatecall entirely and use regular external calls.

ğŸ”¥ CRITICAL: Proxy contract 'AssemblyDelegatecall' has state variable 'address[]' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:171:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:6:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:8:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:10:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:12:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:13:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:35:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:47:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:48:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:54:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:58:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:62:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:68:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:74:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:78:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:81:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:87:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:88:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:105:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:111:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:112:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:136:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:139:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:141:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:150:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:153:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:157:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:181:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:191:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:197:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:201:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:203:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:208:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:210:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:213:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:219:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:222:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:225:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:244:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:246:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:250:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:252:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:256:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:258:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:267:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:268:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:272:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:274:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:282:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:283:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:287:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:290:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:296:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:308:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:320:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:321:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:327:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:342:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:354:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:366:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:381:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'AssemblyDelegatecall' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:23:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'AssemblyDelegatecall' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:24:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'AssemblyDelegatecall' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:99:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'nestedConditionalDelegate' in contract 'AssemblyDelegatecall' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:48:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'tryCatchDelegate' in contract 'AssemblyDelegatecall' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:68:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'multiExecute' in contract 'AssemblyDelegatecall' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

âš ï¸  HIGH: Function 'executeWithCallback' in contract 'AssemblyDelegatecall' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:273:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

âš ï¸  HIGH: Function 'callback' in contract 'AssemblyDelegatecall' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:281:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

ğŸ”¥ CRITICAL: Function 'executeWithCallback' in contract 'AssemblyDelegatecall' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:276:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

âš ï¸  HIGH: Constructor in contract 'AssemblyDelegatecall' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:26:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'batchDelegateFor' in contract 'AssemblyDelegatecall' uses delegatecall in multicall without reentrancy guard. Cross-function reentrancy is possible between batched calls.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:1
   â”œâ”€ Detector: batch-cross-function-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Protect against cross-function reentrancy in multicall:

1. Add reentrancy guard to multicall function:
function multicall(...) external nonReentrant { ... }

2. Use function-level locking for state-changing operations
3. Consider disabling multicall for sensitive functions

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'AssemblyDelegatecall' performs batch operations that sequencers could exploit through partial execution ordering.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Improve batch operation safety:

1. Make batch operations atomic (all-or-nothing)
2. Add revert on partial failure
3. Implement batch ordering guarantees
4. Consider splitting into individual transactions

âš ï¸  HIGH: Function 'addImplementation' in contract 'AssemblyDelegatecall' has DoS vulnerability: Unbounded push to array 'implementations'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:174:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'AssemblyDelegatecall' iterates over unbounded array: Iteration over unbounded array 'implementations'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:180:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Contract 'AssemblyDelegatecall' has unbounded storage array 'implementations'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:171:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'AssemblyDelegatecall' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:180:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'multiExecute' in contract 'AssemblyDelegatecall' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:202:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'AssemblyDelegatecall' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:211:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'AssemblyDelegatecall' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:212:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'AssemblyDelegatecall' contains nested loops. O(n*m) operations can easily exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:211:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid nested loops or add strict bounds:

1. Use mappings instead of nested array iteration
2. Pre-compute results off-chain
3. Split into multiple transactions
4. Add strict size limits on both dimensions

âš ï¸  HIGH: Function 'storageWriteDelegate' in contract 'AssemblyDelegatecall' has delegatecall to self: Possible delegatecall to self via stored address. This can cause infinite loops or unexpected state changes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:342:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Avoid delegatecall to self:

1. Never use address(this) as delegatecall target
2. Validate target != address(this) before delegatecall
3. Use direct internal calls instead
4. If multicall needed, use call instead of delegatecall

âš ï¸  HIGH: Function 'conditionalDelegate' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:32:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'nestedConditionalDelegate' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:44:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'ternaryDelegate' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:55:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'tryCatchDelegate' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:63:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'externalDelegate' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:73:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'switchStyleDelegate' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:79:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'assemblyDelegate' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:106:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'gasOptimizedDelegate' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:137:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'manualMemoryDelegate' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:151:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'batchDelegateWhile' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:187:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'multiExecute' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:209:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'doWhileDelegate' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:220:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'publicExecute' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:245:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function '_internalDelegate' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:251:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'chainedExecute' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:257:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function '_stepTwo' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:266:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'executeWithCallback' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:273:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'callback' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:281:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'executeWithModifier' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:295:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'dynamicDelegate' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:309:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'manipulatedReturnDelegate' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:326:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'storageWriteDelegate' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:338:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'eventEmittingDelegate' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:352:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'reentrancyDelegate' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:361:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'exploit' in contract 'AssemblyDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:380:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

ğŸ”¥ CRITICAL: Function 'addImplementation' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:173:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'addImplementation'

âš¡ MEDIUM: Address parameter 'impl' in function 'addImplementation' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:173:40
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(impl != address(0), "Zero address not allowed");

âš ï¸  HIGH: Array access to 'dataArray' may be out of bounds - index not validated
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:203:56
   â”œâ”€ Detector: array-bounds-check
   â”œâ”€ CWE: CWE-125
   â””â”€ Fix: Add bounds check: require(index < dataArray.length, "Index out of bounds");

âš ï¸  HIGH: Function 'multiExecute' has multiple array parameters but no apparent length validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:14
   â”œâ”€ Detector: array-bounds-check
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Add length validation: require(array1.length == array2.length, "Array length mismatch");

ğŸ“ LOW: Parameter 'impl' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:173:40
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(impl != address(0), "Invalid address");

âš¡ MEDIUM: Parameter 'targetGroups' of type 'array' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:209:52
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(targetGroups.length > 0, "Array cannot be empty");

âš ï¸  HIGH: Function 'addImplementation' relies on a single oracle source, creating centralization risk
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:173:14
   â”œâ”€ Detector: single-oracle-source
   â”œâ”€ CWE: CWE-693
   â””â”€ Fix: Use multiple oracle sources and implement price aggregation in function 'addImplementation'

âš¡ MEDIUM: External call in function 'addImplementation' does not check return value
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:173:14
   â”œâ”€ Detector: unchecked-external-call
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check the return value of external calls in function 'addImplementation'

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:173:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

âš¡ MEDIUM: Function 'batchDelegateFor' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš¡ MEDIUM: Function 'batchDelegateWhile' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:187:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš¡ MEDIUM: Function 'multiExecute' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš¡ MEDIUM: Function 'nestedLoopDelegate' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:209:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš¡ MEDIUM: Function 'doWhileDelegate' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:220:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš ï¸  HIGH: Function 'batchDelegateFor' contains external calls within loops. This can lead to DoS attacks if any external call fails or consumes excessive gas, and can be exploited in governance systems to block proposal execution.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:0
   â”œâ”€ Detector: external-calls-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid external calls in loops. Consider using a withdrawal pattern, batch processing, or fail-safe mechanisms for critical operations.

âš ï¸  HIGH: Function 'batchDelegateWhile' contains external calls within loops. This can lead to DoS attacks if any external call fails or consumes excessive gas, and can be exploited in governance systems to block proposal execution.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:187:0
   â”œâ”€ Detector: external-calls-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid external calls in loops. Consider using a withdrawal pattern, batch processing, or fail-safe mechanisms for critical operations.

âš ï¸  HIGH: Function 'multiExecute' contains external calls within loops. This can lead to DoS attacks if any external call fails or consumes excessive gas, and can be exploited in governance systems to block proposal execution.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:0
   â”œâ”€ Detector: external-calls-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid external calls in loops. Consider using a withdrawal pattern, batch processing, or fail-safe mechanisms for critical operations.

âš ï¸  HIGH: Function 'nestedLoopDelegate' contains external calls within loops. This can lead to DoS attacks if any external call fails or consumes excessive gas, and can be exploited in governance systems to block proposal execution.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:209:0
   â”œâ”€ Detector: external-calls-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid external calls in loops. Consider using a withdrawal pattern, batch processing, or fail-safe mechanisms for critical operations.

âš ï¸  HIGH: Function 'doWhileDelegate' contains external calls within loops. This can lead to DoS attacks if any external call fails or consumes excessive gas, and can be exploited in governance systems to block proposal execution.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:220:0
   â”œâ”€ Detector: external-calls-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid external calls in loops. Consider using a withdrawal pattern, batch processing, or fail-safe mechanisms for critical operations.

ğŸ”¥ CRITICAL: Function 'batchDelegateFor' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'batchDelegateFor'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'batchDelegateWhile' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:187:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'batchDelegateWhile'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'multiExecute' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'multiExecute'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'nestedLoopDelegate' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:209:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'nestedLoopDelegate'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'doWhileDelegate' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:220:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'doWhileDelegate'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'batchDelegateFor' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'batchDelegateFor'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'batchDelegateWhile' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:187:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'batchDelegateWhile'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'multiExecute' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'multiExecute'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'nestedLoopDelegate' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:209:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'nestedLoopDelegate'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'doWhileDelegate' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:220:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'doWhileDelegate'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'addImplementation' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:173:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'addImplementation'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'batchDelegateFor' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'batchDelegateFor'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'batchDelegateWhile' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:187:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'batchDelegateWhile'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'doWhileDelegate' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:220:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'doWhileDelegate'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

âš ï¸  HIGH: Function 'batchDelegateFor' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'batchDelegateFor'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš ï¸  HIGH: Function 'batchDelegateWhile' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:187:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'batchDelegateWhile'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš ï¸  HIGH: Function 'multiExecute' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'multiExecute'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš ï¸  HIGH: Function 'nestedLoopDelegate' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:209:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'nestedLoopDelegate'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš ï¸  HIGH: Function 'doWhileDelegate' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:220:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'doWhileDelegate'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

ğŸ“ LOW: Function 'batchDelegateFor' contains excessive gas usage pattern. Storage write operation inside loop. Consider using memory array Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'batchDelegateFor'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Function 'batchDelegateFor' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'batchDelegateFor'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Function 'batchDelegateWhile' contains excessive gas usage pattern. Storage write operation inside loop. Consider using memory array Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:187:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'batchDelegateWhile'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Function 'multiExecute' contains excessive gas usage pattern. Storage write operation inside loop. Consider using memory array Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'multiExecute'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Function 'multiExecute' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'multiExecute'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Function 'nestedLoopDelegate' contains excessive gas usage pattern. Storage write operation inside loop. Consider using memory array Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:209:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'nestedLoopDelegate'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Function 'nestedLoopDelegate' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:209:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'nestedLoopDelegate'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

âš¡ MEDIUM: Function 'batchDelegateWhile' contains variable shadowing. Parameter 'i' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:187:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'batchDelegateWhile'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Function 'batchDelegateWhile' contains variable shadowing. Local variable 'i' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:187:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'batchDelegateWhile'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Function 'doWhileDelegate' contains variable shadowing. Local variable 'i' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:220:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'doWhileDelegate'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Function 'multiExecute' is missing transaction deadline. Missing transaction deadline. Order execution operation 'multiExecute' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'multiExecute'. Implement: (1) Add 'deadline' parameter: function multiExecute(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

âš ï¸  HIGH: Contract 'LoopDelegatecall' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:170:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

ğŸ”¥ CRITICAL: Missing access control in 'batchDelegateFor' - allows arbitrary execution
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:0
   â”œâ”€ Detector: eip7702-delegate-access-control
   â””â”€ Fix: Fix: Add owner/authorization check:

address public owner;

function execute(address target, bytes calldata data) external payable {
require(msg.sender == owner, "Not authorized");
(bool success, ) = target.call{value: msg.value}(data);
require(success, "Call failed");
}

ğŸ”¥ CRITICAL: Missing access control in 'batchDelegateWhile' - allows arbitrary execution
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:187:0
   â”œâ”€ Detector: eip7702-delegate-access-control
   â””â”€ Fix: Fix: Add owner/authorization check:

address public owner;

function execute(address target, bytes calldata data) external payable {
require(msg.sender == owner, "Not authorized");
(bool success, ) = target.call{value: msg.value}(data);
require(success, "Call failed");
}

ğŸ”¥ CRITICAL: Missing access control in 'multiExecute' - allows arbitrary execution
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:0
   â”œâ”€ Detector: eip7702-delegate-access-control
   â””â”€ Fix: Fix: Add owner/authorization check:

address public owner;

function execute(address target, bytes calldata data) external payable {
require(msg.sender == owner, "Not authorized");
(bool success, ) = target.call{value: msg.value}(data);
require(success, "Call failed");
}

ğŸ”¥ CRITICAL: Missing authorization in batch executor 'batchDelegateFor' - anyone can execute arbitrary calls
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:0
   â”œâ”€ Detector: erc7821-batch-authorization
   â””â”€ Fix: Add authorization check:

address public owner;

function executeBatch(
address[] calldata targets,
bytes[] calldata datas
) external {
require(msg.sender == owner, "Not authorized");

for (uint i = 0; i < targets.length; i++) {
(bool success,) = targets[i].call(datas[i]);
require(success);
}
}

ğŸ”¥ CRITICAL: Missing authorization in batch executor 'batchDelegateWhile' - anyone can execute arbitrary calls
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:187:0
   â”œâ”€ Detector: erc7821-batch-authorization
   â””â”€ Fix: Add authorization check:

address public owner;

function executeBatch(
address[] calldata targets,
bytes[] calldata datas
) external {
require(msg.sender == owner, "Not authorized");

for (uint i = 0; i < targets.length; i++) {
(bool success,) = targets[i].call(datas[i]);
require(success);
}
}

ğŸ”¥ CRITICAL: Missing authorization in batch executor 'multiExecute' - anyone can execute arbitrary calls
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:0
   â”œâ”€ Detector: erc7821-batch-authorization
   â””â”€ Fix: Add authorization check:

address public owner;

function executeBatch(
address[] calldata targets,
bytes[] calldata datas
) external {
require(msg.sender == owner, "Not authorized");

for (uint i = 0; i < targets.length; i++) {
(bool success,) = targets[i].call(datas[i]);
require(success);
}
}

ğŸ”¥ CRITICAL: Proxy contract 'LoopDelegatecall' has state variable 'address[]' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:171:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:6:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:8:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:10:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:12:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:13:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:35:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:47:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:48:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:54:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:58:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:62:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:68:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:74:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:78:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:81:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:87:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:88:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:105:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:111:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:112:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:136:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:139:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:141:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:150:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:153:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:157:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:181:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:191:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:197:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:201:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:203:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:208:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:210:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:213:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:219:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:222:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:225:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:244:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:246:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:250:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:252:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:256:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:258:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:267:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:268:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:272:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:274:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:282:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:283:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:287:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:290:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:296:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:308:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:320:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:321:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:327:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:342:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:354:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:366:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'LoopDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:381:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'LoopDelegatecall' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:23:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'LoopDelegatecall' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:24:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'LoopDelegatecall' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:99:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'nestedConditionalDelegate' in contract 'LoopDelegatecall' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:48:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'tryCatchDelegate' in contract 'LoopDelegatecall' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:68:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'multiExecute' in contract 'LoopDelegatecall' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

âš ï¸  HIGH: Function 'executeWithCallback' in contract 'LoopDelegatecall' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:273:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

âš ï¸  HIGH: Function 'callback' in contract 'LoopDelegatecall' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:281:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

ğŸ”¥ CRITICAL: Function 'executeWithCallback' in contract 'LoopDelegatecall' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:276:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

âš ï¸  HIGH: Constructor in contract 'LoopDelegatecall' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:26:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'batchDelegateFor' in contract 'LoopDelegatecall' uses delegatecall in multicall without reentrancy guard. Cross-function reentrancy is possible between batched calls.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:1
   â”œâ”€ Detector: batch-cross-function-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Protect against cross-function reentrancy in multicall:

1. Add reentrancy guard to multicall function:
function multicall(...) external nonReentrant { ... }

2. Use function-level locking for state-changing operations
3. Consider disabling multicall for sensitive functions

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'LoopDelegatecall' performs batch operations that sequencers could exploit through partial execution ordering.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Improve batch operation safety:

1. Make batch operations atomic (all-or-nothing)
2. Add revert on partial failure
3. Implement batch ordering guarantees
4. Consider splitting into individual transactions

âš ï¸  HIGH: Function 'addImplementation' in contract 'LoopDelegatecall' has DoS vulnerability: Unbounded push to array 'implementations'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:174:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'LoopDelegatecall' iterates over unbounded array: Iteration over unbounded array 'implementations'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:180:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Contract 'LoopDelegatecall' has unbounded storage array 'implementations'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:171:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'LoopDelegatecall' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:180:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'multiExecute' in contract 'LoopDelegatecall' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:202:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'LoopDelegatecall' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:211:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'LoopDelegatecall' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:212:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'LoopDelegatecall' contains nested loops. O(n*m) operations can easily exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:211:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid nested loops or add strict bounds:

1. Use mappings instead of nested array iteration
2. Pre-compute results off-chain
3. Split into multiple transactions
4. Add strict size limits on both dimensions

âš ï¸  HIGH: Function 'storageWriteDelegate' in contract 'LoopDelegatecall' has delegatecall to self: Possible delegatecall to self via stored address. This can cause infinite loops or unexpected state changes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:342:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Avoid delegatecall to self:

1. Never use address(this) as delegatecall target
2. Validate target != address(this) before delegatecall
3. Use direct internal calls instead
4. If multicall needed, use call instead of delegatecall

âš ï¸  HIGH: Function 'conditionalDelegate' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:32:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'nestedConditionalDelegate' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:44:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'ternaryDelegate' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:55:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'tryCatchDelegate' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:63:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'externalDelegate' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:73:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'switchStyleDelegate' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:79:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'assemblyDelegate' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:106:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'gasOptimizedDelegate' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:137:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'manualMemoryDelegate' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:151:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'batchDelegateWhile' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:187:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'multiExecute' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:209:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'doWhileDelegate' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:220:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'publicExecute' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:245:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function '_internalDelegate' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:251:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'chainedExecute' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:257:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function '_stepTwo' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:266:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'executeWithCallback' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:273:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'callback' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:281:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'executeWithModifier' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:295:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'dynamicDelegate' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:309:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'manipulatedReturnDelegate' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:326:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'storageWriteDelegate' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:338:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'eventEmittingDelegate' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:352:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'reentrancyDelegate' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:361:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'exploit' in contract 'LoopDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:380:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Address parameter 'target' in function 'executeWithCallback' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:273:42
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(target != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter 'target' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:273:42
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(target != address(0), "Invalid address");

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:240:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

âš¡ MEDIUM: Function 'publicExecute' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:245:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš¡ MEDIUM: Function '_internalDelegate' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:251:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš¡ MEDIUM: Function 'chainedExecute' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:257:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš¡ MEDIUM: Function 'executeWithCallback' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:273:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš¡ MEDIUM: Function 'withDelegate' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:288:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš¡ MEDIUM: Function 'executeWithModifier' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:295:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

ğŸ”¥ CRITICAL: Function 'publicExecute' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:245:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'publicExecute'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function '_internalDelegate' uses delegatecall which can cause storage collision. Delegatecall to variable target without storage layout verification Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:251:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in '_internalDelegate'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'chainedExecute' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:257:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'chainedExecute'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function '_stepTwo' uses delegatecall which can cause storage collision. Delegatecall to variable target without storage layout verification Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:266:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in '_stepTwo'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'executeWithCallback' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:273:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'executeWithCallback'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'callback' uses delegatecall which can cause storage collision. Delegatecall to variable target without storage layout verification Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:281:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'callback'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'withDelegate' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:288:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'withDelegate'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'publicExecute' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:245:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'publicExecute'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function '_internalDelegate' contains dangerous delegatecall pattern. Delegatecall target is not validated against a whitelist of approved addresses Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:251:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in '_internalDelegate'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'chainedExecute' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:257:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'chainedExecute'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function '_stepTwo' contains dangerous delegatecall pattern. Delegatecall target is not validated against a whitelist of approved addresses Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:266:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in '_stepTwo'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'executeWithCallback' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:273:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'executeWithCallback'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'callback' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:281:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'callback'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'withDelegate' contains dangerous delegatecall pattern. Delegatecall target is not validated against a whitelist of approved addresses Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:288:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'withDelegate'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'executeWithModifier' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:295:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'executeWithModifier'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:240:5
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'publicExecute' has upgradeable proxy vulnerability. Delegatecall without validating implementation address, can delegate to non-contract or malicious code Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:245:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'publicExecute'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function '_internalDelegate' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:251:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in '_internalDelegate'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'chainedExecute' has upgradeable proxy vulnerability. Delegatecall without validating implementation address, can delegate to non-contract or malicious code Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:257:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'chainedExecute'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function '_stepTwo' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:266:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in '_stepTwo'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'callback' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:281:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'callback'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'withDelegate' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:288:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'withDelegate'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'executeWithModifier' has upgradeable proxy vulnerability. Delegatecall without validating implementation address, can delegate to non-contract or malicious code Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:295:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'executeWithModifier'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

âš ï¸  HIGH: Function '_internalDelegate' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:251:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in '_internalDelegate'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš ï¸  HIGH: Function '_stepTwo' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:266:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in '_stepTwo'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš ï¸  HIGH: Function 'executeWithCallback' has circular dependency vulnerability. Callback pattern without reentrancy guard, enables circular call chains and reentrancy attacks Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:273:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'executeWithCallback'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš ï¸  HIGH: Function 'callback' has circular dependency vulnerability. Callback pattern without reentrancy guard, enables circular call chains and reentrancy attacks Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:281:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'callback'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš ï¸  HIGH: Function 'withDelegate' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:288:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'withDelegate'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš¡ MEDIUM: Function 'publicExecute' is missing transaction deadline. Missing transaction deadline. Order execution operation 'publicExecute' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:245:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'publicExecute'. Implement: (1) Add 'deadline' parameter: function publicExecute(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

âš¡ MEDIUM: Function 'chainedExecute' is missing transaction deadline. Missing transaction deadline. Order execution operation 'chainedExecute' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:257:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'chainedExecute'. Implement: (1) Add 'deadline' parameter: function chainedExecute(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

âš¡ MEDIUM: Function 'executeWithCallback' is missing transaction deadline. Missing transaction deadline. Order execution operation 'executeWithCallback' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:273:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'executeWithCallback'. Implement: (1) Add 'deadline' parameter: function executeWithCallback(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

âš¡ MEDIUM: Function 'executeWithModifier' is missing transaction deadline. Missing transaction deadline. Order execution operation 'executeWithModifier' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:295:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'executeWithModifier'. Implement: (1) Add 'deadline' parameter: function executeWithModifier(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

âš ï¸  HIGH: Contract 'IndirectDelegatecall' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:237:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

ğŸ”¥ CRITICAL: Missing access control in 'publicExecute' - allows arbitrary execution
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:245:0
   â”œâ”€ Detector: eip7702-delegate-access-control
   â””â”€ Fix: Fix: Add owner/authorization check:

address public owner;

function execute(address target, bytes calldata data) external payable {
require(msg.sender == owner, "Not authorized");
(bool success, ) = target.call{value: msg.value}(data);
require(success, "Call failed");
}

ğŸ”¥ CRITICAL: Missing access control in 'chainedExecute' - allows arbitrary execution
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:257:0
   â”œâ”€ Detector: eip7702-delegate-access-control
   â””â”€ Fix: Fix: Add owner/authorization check:

address public owner;

function execute(address target, bytes calldata data) external payable {
require(msg.sender == owner, "Not authorized");
(bool success, ) = target.call{value: msg.value}(data);
require(success, "Call failed");
}

ğŸ”¥ CRITICAL: Missing access control in 'executeWithCallback' - allows arbitrary execution
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:273:0
   â”œâ”€ Detector: eip7702-delegate-access-control
   â””â”€ Fix: Fix: Add owner/authorization check:

address public owner;

function execute(address target, bytes calldata data) external payable {
require(msg.sender == owner, "Not authorized");
(bool success, ) = target.call{value: msg.value}(data);
require(success, "Call failed");
}

ğŸ”¥ CRITICAL: Missing access control in 'callback' - allows arbitrary execution
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:281:0
   â”œâ”€ Detector: eip7702-delegate-access-control
   â””â”€ Fix: Fix: Add owner/authorization check:

address public owner;

function execute(address target, bytes calldata data) external payable {
require(msg.sender == owner, "Not authorized");
(bool success, ) = target.call{value: msg.value}(data);
require(success, "Call failed");
}

ğŸ”¥ CRITICAL: Missing access control in 'executeWithModifier' - allows arbitrary execution
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:295:0
   â”œâ”€ Detector: eip7702-delegate-access-control
   â””â”€ Fix: Fix: Add owner/authorization check:

address public owner;

function execute(address target, bytes calldata data) external payable {
require(msg.sender == owner, "Not authorized");
(bool success, ) = target.call{value: msg.value}(data);
require(success, "Call failed");
}

ğŸ”¥ CRITICAL: Missing authorization in batch executor 'publicExecute' - anyone can execute arbitrary calls
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:245:0
   â”œâ”€ Detector: erc7821-batch-authorization
   â””â”€ Fix: Add authorization check:

address public owner;

function executeBatch(
address[] calldata targets,
bytes[] calldata datas
) external {
require(msg.sender == owner, "Not authorized");

for (uint i = 0; i < targets.length; i++) {
(bool success,) = targets[i].call(datas[i]);
require(success);
}
}

ğŸ”¥ CRITICAL: Missing authorization in batch executor 'chainedExecute' - anyone can execute arbitrary calls
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:257:0
   â”œâ”€ Detector: erc7821-batch-authorization
   â””â”€ Fix: Add authorization check:

address public owner;

function executeBatch(
address[] calldata targets,
bytes[] calldata datas
) external {
require(msg.sender == owner, "Not authorized");

for (uint i = 0; i < targets.length; i++) {
(bool success,) = targets[i].call(datas[i]);
require(success);
}
}

ğŸ”¥ CRITICAL: Missing authorization in batch executor 'executeWithCallback' - anyone can execute arbitrary calls
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:273:0
   â”œâ”€ Detector: erc7821-batch-authorization
   â””â”€ Fix: Add authorization check:

address public owner;

function executeBatch(
address[] calldata targets,
bytes[] calldata datas
) external {
require(msg.sender == owner, "Not authorized");

for (uint i = 0; i < targets.length; i++) {
(bool success,) = targets[i].call(datas[i]);
require(success);
}
}

ğŸ”¥ CRITICAL: Proxy contract 'IndirectDelegatecall' has state variable 'address[]' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:171:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:6:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:8:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:10:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:12:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:13:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:35:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:47:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:48:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:54:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:58:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:62:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:68:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:74:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:78:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:81:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:87:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:88:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:105:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:111:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:112:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:136:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:139:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:141:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:150:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:153:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:157:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:181:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:191:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:197:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:201:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:203:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:208:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:210:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:213:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:219:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:222:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:225:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:244:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:246:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:250:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:252:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:256:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:258:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:267:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:268:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:272:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:274:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:282:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:283:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:287:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:290:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:296:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:308:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:320:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:321:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:327:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:342:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:354:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:366:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IndirectDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:381:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'IndirectDelegatecall' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:23:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'IndirectDelegatecall' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:24:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'IndirectDelegatecall' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:99:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'nestedConditionalDelegate' in contract 'IndirectDelegatecall' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:48:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'tryCatchDelegate' in contract 'IndirectDelegatecall' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:68:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'multiExecute' in contract 'IndirectDelegatecall' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

âš ï¸  HIGH: Function 'executeWithCallback' in contract 'IndirectDelegatecall' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:273:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

âš ï¸  HIGH: Function 'callback' in contract 'IndirectDelegatecall' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:281:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

ğŸ”¥ CRITICAL: Function 'executeWithCallback' in contract 'IndirectDelegatecall' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:276:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

âš ï¸  HIGH: Constructor in contract 'IndirectDelegatecall' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:26:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'batchDelegateFor' in contract 'IndirectDelegatecall' uses delegatecall in multicall without reentrancy guard. Cross-function reentrancy is possible between batched calls.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:1
   â”œâ”€ Detector: batch-cross-function-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Protect against cross-function reentrancy in multicall:

1. Add reentrancy guard to multicall function:
function multicall(...) external nonReentrant { ... }

2. Use function-level locking for state-changing operations
3. Consider disabling multicall for sensitive functions

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'IndirectDelegatecall' performs batch operations that sequencers could exploit through partial execution ordering.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Improve batch operation safety:

1. Make batch operations atomic (all-or-nothing)
2. Add revert on partial failure
3. Implement batch ordering guarantees
4. Consider splitting into individual transactions

âš ï¸  HIGH: Function 'addImplementation' in contract 'IndirectDelegatecall' has DoS vulnerability: Unbounded push to array 'implementations'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:174:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'IndirectDelegatecall' iterates over unbounded array: Iteration over unbounded array 'implementations'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:180:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Contract 'IndirectDelegatecall' has unbounded storage array 'implementations'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:171:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'IndirectDelegatecall' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:180:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'multiExecute' in contract 'IndirectDelegatecall' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:202:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'IndirectDelegatecall' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:211:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'IndirectDelegatecall' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:212:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'IndirectDelegatecall' contains nested loops. O(n*m) operations can easily exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:211:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid nested loops or add strict bounds:

1. Use mappings instead of nested array iteration
2. Pre-compute results off-chain
3. Split into multiple transactions
4. Add strict size limits on both dimensions

âš ï¸  HIGH: Function 'storageWriteDelegate' in contract 'IndirectDelegatecall' has delegatecall to self: Possible delegatecall to self via stored address. This can cause infinite loops or unexpected state changes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:342:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Avoid delegatecall to self:

1. Never use address(this) as delegatecall target
2. Validate target != address(this) before delegatecall
3. Use direct internal calls instead
4. If multicall needed, use call instead of delegatecall

âš ï¸  HIGH: Function 'conditionalDelegate' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:32:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'nestedConditionalDelegate' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:44:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'ternaryDelegate' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:55:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'tryCatchDelegate' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:63:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'externalDelegate' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:73:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'switchStyleDelegate' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:79:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'assemblyDelegate' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:106:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'gasOptimizedDelegate' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:137:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'manualMemoryDelegate' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:151:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'batchDelegateWhile' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:187:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'multiExecute' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:209:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'doWhileDelegate' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:220:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'publicExecute' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:245:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function '_internalDelegate' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:251:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'chainedExecute' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:257:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function '_stepTwo' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:266:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'executeWithCallback' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:273:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'callback' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:281:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'executeWithModifier' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:295:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'dynamicDelegate' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:309:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'manipulatedReturnDelegate' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:326:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'storageWriteDelegate' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:338:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'eventEmittingDelegate' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:352:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'reentrancyDelegate' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:361:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'exploit' in contract 'IndirectDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:380:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'reentrancyDelegate' may be vulnerable to reentrancy attacks due to state changes after external calls
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:361:14
   â”œâ”€ Detector: classic-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Apply checks-effects-interactions pattern or use a reentrancy guard in function 'reentrancyDelegate'

âš ï¸  HIGH: State variable 'locked' is modified without proper validation or state checks
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:363:9
   â”œâ”€ Detector: invalid-state-transition
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Add proper validation before modifying state variables

âš ï¸  HIGH: State variable 'locked' is modified without proper validation or state checks
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:369:9
   â”œâ”€ Detector: invalid-state-transition
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Add proper validation before modifying state variables

âš ï¸  HIGH: Address parameter 'target' in function 'manipulatedReturnDelegate' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:326:48
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(target != address(0), "Zero address not allowed");

âš ï¸  HIGH: Address parameter 'target' in function 'storageWriteDelegate' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:338:43
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(target != address(0), "Zero address not allowed");

âš ï¸  HIGH: Address parameter 'target' in function 'eventEmittingDelegate' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:352:44
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(target != address(0), "Zero address not allowed");

âš ï¸  HIGH: Address parameter 'target' in function 'reentrancyDelegate' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:361:41
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(target != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter 'target' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:326:48
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(target != address(0), "Invalid address");

ğŸ“ LOW: Parameter 'target' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:338:43
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(target != address(0), "Invalid address");

ğŸ“ LOW: Parameter 'target' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:352:44
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(target != address(0), "Invalid address");

ğŸ“ LOW: Parameter 'target' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:361:41
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(target != address(0), "Invalid address");

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:309:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

âš¡ MEDIUM: Function 'dynamicDelegate' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:309:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš¡ MEDIUM: Function 'manipulatedReturnDelegate' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:326:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš¡ MEDIUM: Function 'storageWriteDelegate' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:338:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš¡ MEDIUM: Function 'eventEmittingDelegate' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:352:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš¡ MEDIUM: Function 'reentrancyDelegate' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:361:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

ğŸ”¥ CRITICAL: Function 'dynamicDelegate' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:309:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'dynamicDelegate'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'manipulatedReturnDelegate' uses delegatecall which can cause storage collision. Delegatecall to variable target without storage layout verification Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:326:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'manipulatedReturnDelegate'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'storageWriteDelegate' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:338:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'storageWriteDelegate'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'eventEmittingDelegate' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:352:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'eventEmittingDelegate'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'reentrancyDelegate' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:361:14
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in 'reentrancyDelegate'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function 'dynamicDelegate' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:309:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'dynamicDelegate'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'manipulatedReturnDelegate' contains dangerous delegatecall pattern. Delegatecall target is controlled by function parameters or user input, allowing arbitrary code execution Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:326:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'manipulatedReturnDelegate'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'storageWriteDelegate' contains dangerous delegatecall pattern. Delegatecall target is controlled by function parameters or user input, allowing arbitrary code execution Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:338:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'storageWriteDelegate'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'eventEmittingDelegate' contains dangerous delegatecall pattern. Delegatecall target is controlled by function parameters or user input, allowing arbitrary code execution Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:352:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'eventEmittingDelegate'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'reentrancyDelegate' contains dangerous delegatecall pattern. Delegatecall target is controlled by function parameters or user input, allowing arbitrary code execution Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:361:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'reentrancyDelegate'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'dynamicDelegate' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:309:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'dynamicDelegate'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'eventEmittingDelegate' has upgradeable proxy vulnerability. Delegatecall without validating implementation address, can delegate to non-contract or malicious code Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:352:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'eventEmittingDelegate'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

âš ï¸  HIGH: Function 'dynamicDelegate' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:309:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'dynamicDelegate'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš ï¸  HIGH: Function 'manipulatedReturnDelegate' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:326:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'manipulatedReturnDelegate'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš ï¸  HIGH: Function 'storageWriteDelegate' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:338:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'storageWriteDelegate'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš ï¸  HIGH: Function 'eventEmittingDelegate' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:352:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'eventEmittingDelegate'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš¡ MEDIUM: Function 'dynamicDelegate' contains variable shadowing. Local variable 'target' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:309:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'dynamicDelegate'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Function 'storageWriteDelegate' contains unsafe type casting. address type casting without validation. May result in zero address Unsafe type conversions can lead to data loss, value truncation, or unexpected behavior.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:338:0
   â”œâ”€ Detector: unsafe-type-casting
   â”œâ”€ CWE: CWE-704
   â””â”€ Fix: Add safe type casting in 'storageWriteDelegate'. Implement: (1) Validate value ranges before casting, (2) Use require() to check bounds, (3) Use SafeCast library from OpenZeppelin, (4) Avoid downcasting without validation, (5) Check for sign preservation in int/uint conversions.

âš¡ MEDIUM: Function 'storageWriteDelegate' contains unsafe type casting. address type casting without validation. May result in zero address Unsafe type conversions can lead to data loss, value truncation, or unexpected behavior.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:344:0
   â”œâ”€ Detector: unsafe-type-casting
   â”œâ”€ CWE: CWE-704
   â””â”€ Fix: Add safe type casting in 'storageWriteDelegate'. Implement: (1) Validate value ranges before casting, (2) Use require() to check bounds, (3) Use SafeCast library from OpenZeppelin, (4) Avoid downcasting without validation, (5) Check for sign preservation in int/uint conversions.

âš ï¸  HIGH: Contract 'ComplexDelegatecall' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:304:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

ğŸ”¥ CRITICAL: Function 'manipulatedReturnDelegate' performs delegatecall with user-controlled target. Delegatecall target is derived from function parameters or user input, allowing callers to specify arbitrary code to execute. This allows arbitrary code execution in the contract's storage context, enabling complete takeover and fund theft.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:326:14
   â”œâ”€ Detector: delegatecall-user-controlled
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Remove user control over delegatecall target in 'manipulatedReturnDelegate'. Use a whitelist of approved addresses: mapping(address => bool) approvedTargets; Or avoid delegatecall entirely and use regular external calls.

ğŸ”¥ CRITICAL: Function 'storageWriteDelegate' performs delegatecall with user-controlled target. Delegatecall target is derived from function parameters or user input, allowing callers to specify arbitrary code to execute. This allows arbitrary code execution in the contract's storage context, enabling complete takeover and fund theft.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:338:14
   â”œâ”€ Detector: delegatecall-user-controlled
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Remove user control over delegatecall target in 'storageWriteDelegate'. Use a whitelist of approved addresses: mapping(address => bool) approvedTargets; Or avoid delegatecall entirely and use regular external calls.

ğŸ”¥ CRITICAL: Function 'eventEmittingDelegate' performs delegatecall with user-controlled target. Delegatecall target is derived from function parameters or user input, allowing callers to specify arbitrary code to execute. This allows arbitrary code execution in the contract's storage context, enabling complete takeover and fund theft.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:352:14
   â”œâ”€ Detector: delegatecall-user-controlled
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Remove user control over delegatecall target in 'eventEmittingDelegate'. Use a whitelist of approved addresses: mapping(address => bool) approvedTargets; Or avoid delegatecall entirely and use regular external calls.

ğŸ”¥ CRITICAL: Function 'reentrancyDelegate' performs delegatecall with user-controlled target. Delegatecall target is derived from function parameters or user input, allowing callers to specify arbitrary code to execute. This allows arbitrary code execution in the contract's storage context, enabling complete takeover and fund theft.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:361:14
   â”œâ”€ Detector: delegatecall-user-controlled
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Remove user control over delegatecall target in 'reentrancyDelegate'. Use a whitelist of approved addresses: mapping(address => bool) approvedTargets; Or avoid delegatecall entirely and use regular external calls.

âš ï¸  HIGH: Delegatecall in function 'dynamicDelegate' does not properly check return value. Assembly delegatecall result not properly validated. Check result: switch result case 0 { revert(...) } default { return(...) } Real-world impact: Silent failures can lead to state corruption, failed upgrades, and fund loss. Similar to issues in proxy contracts where failed initializations went undetected.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:309:14
   â”œâ”€ Detector: delegatecall-return-ignored
   â””â”€ CWE: CWE-252

âš ï¸  HIGH: Delegatecall in function 'eventEmittingDelegate' does not properly check return value. Delegatecall return value captured but not validated. Add require(success, ...) or if (!success) revert(...) Real-world impact: Silent failures can lead to state corruption, failed upgrades, and fund loss. Similar to issues in proxy contracts where failed initializations went undetected.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:352:14
   â”œâ”€ Detector: delegatecall-return-ignored
   â””â”€ CWE: CWE-252

ğŸ”¥ CRITICAL: Proxy contract 'ComplexDelegatecall' has state variable 'address[]' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:171:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:6:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:8:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:10:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:12:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:13:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:35:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:47:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:48:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:54:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:58:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:62:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:68:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:74:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:78:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:81:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:87:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:88:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:105:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:111:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:112:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:136:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:139:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:141:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:150:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:153:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:157:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:181:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:191:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:197:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:201:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:203:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:208:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:210:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:213:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:219:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:222:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:225:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:244:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:246:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:250:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:252:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:256:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:258:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:267:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:268:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:272:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:274:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:282:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:283:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:287:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:290:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:296:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:308:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:320:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:321:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:327:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:342:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:354:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:366:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ComplexDelegatecall' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:381:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'ComplexDelegatecall' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:23:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'ComplexDelegatecall' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:24:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'ComplexDelegatecall' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:99:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'nestedConditionalDelegate' in contract 'ComplexDelegatecall' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:48:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'tryCatchDelegate' in contract 'ComplexDelegatecall' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:68:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'multiExecute' in contract 'ComplexDelegatecall' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

âš ï¸  HIGH: Function 'executeWithCallback' in contract 'ComplexDelegatecall' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:273:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

âš ï¸  HIGH: Function 'callback' in contract 'ComplexDelegatecall' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:281:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

ğŸ”¥ CRITICAL: Function 'executeWithCallback' in contract 'ComplexDelegatecall' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:276:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

âš ï¸  HIGH: Constructor in contract 'ComplexDelegatecall' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:26:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'batchDelegateFor' in contract 'ComplexDelegatecall' uses delegatecall in multicall without reentrancy guard. Cross-function reentrancy is possible between batched calls.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:1
   â”œâ”€ Detector: batch-cross-function-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Protect against cross-function reentrancy in multicall:

1. Add reentrancy guard to multicall function:
function multicall(...) external nonReentrant { ... }

2. Use function-level locking for state-changing operations
3. Consider disabling multicall for sensitive functions

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'ComplexDelegatecall' performs batch operations that sequencers could exploit through partial execution ordering.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Improve batch operation safety:

1. Make batch operations atomic (all-or-nothing)
2. Add revert on partial failure
3. Implement batch ordering guarantees
4. Consider splitting into individual transactions

âš ï¸  HIGH: Function 'addImplementation' in contract 'ComplexDelegatecall' has DoS vulnerability: Unbounded push to array 'implementations'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:174:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'ComplexDelegatecall' iterates over unbounded array: Iteration over unbounded array 'implementations'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:180:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Contract 'ComplexDelegatecall' has unbounded storage array 'implementations'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:171:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'ComplexDelegatecall' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:180:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'multiExecute' in contract 'ComplexDelegatecall' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:202:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'ComplexDelegatecall' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:211:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'ComplexDelegatecall' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:212:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'ComplexDelegatecall' contains nested loops. O(n*m) operations can easily exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:211:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid nested loops or add strict bounds:

1. Use mappings instead of nested array iteration
2. Pre-compute results off-chain
3. Split into multiple transactions
4. Add strict size limits on both dimensions

âš ï¸  HIGH: Function 'storageWriteDelegate' in contract 'ComplexDelegatecall' has delegatecall to self: Possible delegatecall to self via stored address. This can cause infinite loops or unexpected state changes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:342:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Avoid delegatecall to self:

1. Never use address(this) as delegatecall target
2. Validate target != address(this) before delegatecall
3. Use direct internal calls instead
4. If multicall needed, use call instead of delegatecall

âš ï¸  HIGH: Function 'conditionalDelegate' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:32:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'nestedConditionalDelegate' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:44:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'ternaryDelegate' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:55:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'tryCatchDelegate' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:63:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'externalDelegate' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:73:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'switchStyleDelegate' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:79:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'assemblyDelegate' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:106:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'gasOptimizedDelegate' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:137:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'manualMemoryDelegate' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:151:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'batchDelegateWhile' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:187:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'multiExecute' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:209:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'doWhileDelegate' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:220:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'publicExecute' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:245:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function '_internalDelegate' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:251:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'chainedExecute' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:257:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function '_stepTwo' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:266:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'executeWithCallback' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:273:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'callback' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:281:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'executeWithModifier' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:295:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'dynamicDelegate' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:309:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'manipulatedReturnDelegate' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:326:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'storageWriteDelegate' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:338:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'eventEmittingDelegate' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:352:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'reentrancyDelegate' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:361:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'exploit' in contract 'ComplexDelegatecall' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:380:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

ğŸ”¥ CRITICAL: Function 'stealOwnership' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:387:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'stealOwnership'

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:380:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

ğŸ”¥ CRITICAL: Function 'exploit' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:380:14
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in 'exploit'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'exploit' has upgradeable proxy vulnerability. Delegatecall without validating implementation address, can delegate to non-contract or malicious code Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:380:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'exploit'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

âš ï¸  HIGH: Contract 'MaliciousImplementation' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:377:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

ğŸ”¥ CRITICAL: Proxy contract 'MaliciousImplementation' has state variable 'address[]' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:171:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:6:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:8:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:10:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:12:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:13:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:35:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:47:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:48:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:54:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:58:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:62:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:68:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:74:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:78:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:81:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:87:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:88:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:105:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:111:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:112:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:136:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:139:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:141:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:150:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:153:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:157:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:181:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:191:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:197:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:201:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:203:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:208:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:210:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:213:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:219:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:222:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:225:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:244:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:246:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:250:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:252:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:256:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:258:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:267:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:268:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:272:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:274:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:282:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:283:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:287:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:290:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:296:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:308:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:320:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:321:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a while loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:327:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:342:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:354:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:366:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:381:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'MaliciousImplementation' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:23:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'MaliciousImplementation' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:24:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'MaliciousImplementation' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:99:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'nestedConditionalDelegate' in contract 'MaliciousImplementation' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:48:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'tryCatchDelegate' in contract 'MaliciousImplementation' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:68:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'multiExecute' in contract 'MaliciousImplementation' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

âš ï¸  HIGH: Function 'executeWithCallback' in contract 'MaliciousImplementation' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:273:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

âš ï¸  HIGH: Function 'callback' in contract 'MaliciousImplementation' executes calls without proper authorization checks. In EIP-7702 context, this could allow unauthorized parties to execute arbitrary operations on delegating EOAs.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:281:1
   â”œâ”€ Detector: eip7702-authorization-bypass
   â”œâ”€ CWE: CWE-862
   â””â”€ Fix: Add authorization checks before executing calls:

1. Verify msg.sender is the authorized caller:
require(msg.sender == authorizedExecutor, "Unauthorized");

2. Use role-based access control:
require(hasRole(EXECUTOR_ROLE, msg.sender), "Missing role");

3. Implement EIP-7702 specific authorization:
require(isAuthorizedDelegation(msg.sender), "Invalid delegation");

ğŸ”¥ CRITICAL: Function 'executeWithCallback' in contract 'MaliciousImplementation' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:276:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

âš ï¸  HIGH: Constructor in contract 'MaliciousImplementation' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:26:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'batchDelegateFor' in contract 'MaliciousImplementation' uses delegatecall in multicall without reentrancy guard. Cross-function reentrancy is possible between batched calls.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:1
   â”œâ”€ Detector: batch-cross-function-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Protect against cross-function reentrancy in multicall:

1. Add reentrancy guard to multicall function:
function multicall(...) external nonReentrant { ... }

2. Use function-level locking for state-changing operations
3. Consider disabling multicall for sensitive functions

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'MaliciousImplementation' performs batch operations that sequencers could exploit through partial execution ordering.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Improve batch operation safety:

1. Make batch operations atomic (all-or-nothing)
2. Add revert on partial failure
3. Implement batch ordering guarantees
4. Consider splitting into individual transactions

âš ï¸  HIGH: Function 'addImplementation' in contract 'MaliciousImplementation' has DoS vulnerability: Unbounded push to array 'implementations'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:174:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'MaliciousImplementation' iterates over unbounded array: Iteration over unbounded array 'implementations'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:180:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Contract 'MaliciousImplementation' has unbounded storage array 'implementations'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:171:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'MaliciousImplementation' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:180:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'multiExecute' in contract 'MaliciousImplementation' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:202:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'MaliciousImplementation' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:211:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'MaliciousImplementation' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:212:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'MaliciousImplementation' contains nested loops. O(n*m) operations can easily exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:211:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid nested loops or add strict bounds:

1. Use mappings instead of nested array iteration
2. Pre-compute results off-chain
3. Split into multiple transactions
4. Add strict size limits on both dimensions

âš ï¸  HIGH: Function 'storageWriteDelegate' in contract 'MaliciousImplementation' has delegatecall to self: Possible delegatecall to self via stored address. This can cause infinite loops or unexpected state changes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:342:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Avoid delegatecall to self:

1. Never use address(this) as delegatecall target
2. Validate target != address(this) before delegatecall
3. Use direct internal calls instead
4. If multicall needed, use call instead of delegatecall

âš ï¸  HIGH: Function 'conditionalDelegate' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:32:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'nestedConditionalDelegate' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:44:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'ternaryDelegate' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:55:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'tryCatchDelegate' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:63:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'externalDelegate' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:73:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'switchStyleDelegate' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:79:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'assemblyDelegate' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:106:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'gasOptimizedDelegate' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:137:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'manualMemoryDelegate' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:151:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'batchDelegateFor' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:178:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'batchDelegateWhile' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:187:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'multiExecute' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:198:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'nestedLoopDelegate' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:209:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'doWhileDelegate' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:220:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'publicExecute' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:245:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function '_internalDelegate' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:251:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'chainedExecute' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:257:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function '_stepTwo' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:266:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'executeWithCallback' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:273:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'callback' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:281:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'executeWithModifier' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:295:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'dynamicDelegate' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:309:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'manipulatedReturnDelegate' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:326:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'storageWriteDelegate' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:338:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'eventEmittingDelegate' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:352:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'reentrancyDelegate' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:361:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'exploit' in contract 'MaliciousImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallAdvanced_NoLibrary.sol:380:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

ğŸ”¥ CRITICAL: Function 'upgradeTo' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'upgradeTo'

âš¡ MEDIUM: Address parameter 'newImplementation' in function 'upgradeTo' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:32
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(newImplementation != address(0), "Zero address not allowed");

âš¡ MEDIUM: Address parameter 'newImplementation' in function 'upgradeToUnchecked' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:41
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(newImplementation != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter 'newImplementation' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:32
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(newImplementation != address(0), "Invalid address");

ğŸ“ LOW: Parameter 'newImplementation' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:41
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(newImplementation != address(0), "Invalid address");

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

ğŸ”¥ CRITICAL: Function '' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:5
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in ''. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function '' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:5
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in ''. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

âš ï¸  HIGH: Function 'upgradeToUnchecked' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'upgradeToUnchecked'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

ğŸ”¥ CRITICAL: Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:5
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'upgradeTo' has upgradeable proxy vulnerability. Upgrade executes immediately without timelock delay, no time for users to exit before malicious upgrade Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'upgradeTo'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'upgradeToUnchecked' has upgradeable proxy vulnerability. Upgrade executes immediately without timelock delay, no time for users to exit before malicious upgrade Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'upgradeToUnchecked'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:5
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ“ LOW: Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:366:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Function 'setOwner' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:353:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Function 'initialize' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:374:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Function 'reinitialize' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:381:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

âš ï¸  HIGH: Contract has centralization risk. Contract uses single owner without multi-signature protection. Single private key compromise leads to total contract control Single point of failure can lead to fund loss, governance attacks, or complete system compromise.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:1:0
   â”œâ”€ Detector: centralization-risk
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.

âš ï¸  HIGH: Function 'upgradeTo' has centralization risk. Critical 'upgradeTo' function restricted to single owner without multi-sig or timelock. Single point of failure for critical operation Critical function controlled by single address creates attack vector.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:14
   â”œâ”€ Detector: centralization-risk
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Add decentralization to 'upgradeTo'. Implement multi-signature requirements, timelock delays, or DAO governance for this critical function.

âš ï¸  HIGH: Function 'upgradeToUnchecked' has centralization risk. Critical 'upgradeToUnchecked' function restricted to single owner without multi-sig or timelock. Single point of failure for critical operation Critical function controlled by single address creates attack vector.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:14
   â”œâ”€ Detector: centralization-risk
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Add decentralization to 'upgradeToUnchecked'. Implement multi-signature requirements, timelock delays, or DAO governance for this critical function.

âš¡ MEDIUM: Function 'upgradeToUnchecked' contains variable shadowing. Parameter 'owner' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'upgradeToUnchecked'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Function '' contains variable shadowing. Local variable 'impl' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:5
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in ''. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

ğŸ“ LOW: Deprecated function or pattern detected: 'selfdestruct'. selfdestruct is deprecated. Consider alternative contract upgrade patterns
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:1:0
   â”œâ”€ Detector: deprecated-functions
   â”œâ”€ CWE: CWE-477
   â””â”€ Fix: Replace deprecated 'selfdestruct'. selfdestruct is deprecated. Consider alternative contract upgrade patterns

âš ï¸  HIGH: Account abstraction initialization lacks signature verification. Initialization function lacks signature verification Missing signature verification allows anyone to initialize the account with arbitrary parameters, leading to account takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:374:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: Implement secure initialization: (1) Add initWithSig function requiring user signature, (2) Verify signature matches expected owner, (3) Use nonce to prevent replay attacks, (4) Implement one-time initialization flag, (5) Consider ERC-4337 EntryPoint-only initialization.

âš ï¸  HIGH: Initialization sets owner without validation. Owner assignment without address(0) check or signature verification Unvalidated owner parameter allows initialization with attacker-controlled address.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:26:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate owner parameter: (1) Require owner != address(0), (2) Verify signature from owner address, (3) Emit OwnerSet event, (4) Consider two-step ownership transfer, (5) Validate owner in constructor or initWithSig.

âš ï¸  HIGH: Initialization sets owner without validation. Owner assignment without address(0) check or signature verification Unvalidated owner parameter allows initialization with attacker-controlled address.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:196:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate owner parameter: (1) Require owner != address(0), (2) Verify signature from owner address, (3) Emit OwnerSet event, (4) Consider two-step ownership transfer, (5) Validate owner in constructor or initWithSig.

âš ï¸  HIGH: Initialization sets owner without validation. Owner assignment without address(0) check or signature verification Unvalidated owner parameter allows initialization with attacker-controlled address.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:355:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate owner parameter: (1) Require owner != address(0), (2) Verify signature from owner address, (3) Emit OwnerSet event, (4) Consider two-step ownership transfer, (5) Validate owner in constructor or initWithSig.

âš ï¸  HIGH: Initialization sets owner without validation. Owner assignment without address(0) check or signature verification Unvalidated owner parameter allows initialization with attacker-controlled address.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:383:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate owner parameter: (1) Require owner != address(0), (2) Verify signature from owner address, (3) Emit OwnerSet event, (4) Consider two-step ownership transfer, (5) Validate owner in constructor or initWithSig.

âš ï¸  HIGH: EIP-7702 delegation initialized without safety checks. Delegation without validation of target contract Unsafe delegation initialization can brick the account if delegating to incompatible or malicious contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:6:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate delegation target: (1) Verify delegate implements required interfaces, (2) Ensure delegate is not zero address, (3) Check delegate has valid code, (4) Require signature for delegation setup, (5) Follow EIP-7702 security guidelines.

âš ï¸  HIGH: EIP-7702 delegation initialized without safety checks. Delegation without validation of target contract Unsafe delegation initialization can brick the account if delegating to incompatible or malicious contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate delegation target: (1) Verify delegate implements required interfaces, (2) Ensure delegate is not zero address, (3) Check delegate has valid code, (4) Require signature for delegation setup, (5) Follow EIP-7702 security guidelines.

âš ï¸  HIGH: EIP-7702 delegation initialized without safety checks. Delegation without validation of target contract Unsafe delegation initialization can brick the account if delegating to incompatible or malicious contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate delegation target: (1) Verify delegate implements required interfaces, (2) Ensure delegate is not zero address, (3) Check delegate has valid code, (4) Require signature for delegation setup, (5) Follow EIP-7702 security guidelines.

âš ï¸  HIGH: EIP-7702 delegation initialized without safety checks. Delegation without validation of target contract Unsafe delegation initialization can brick the account if delegating to incompatible or malicious contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate delegation target: (1) Verify delegate implements required interfaces, (2) Ensure delegate is not zero address, (3) Check delegate has valid code, (4) Require signature for delegation setup, (5) Follow EIP-7702 security guidelines.

âš ï¸  HIGH: EIP-7702 delegation initialized without safety checks. Delegation without validation of target contract Unsafe delegation initialization can brick the account if delegating to incompatible or malicious contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate delegation target: (1) Verify delegate implements required interfaces, (2) Ensure delegate is not zero address, (3) Check delegate has valid code, (4) Require signature for delegation setup, (5) Follow EIP-7702 security guidelines.

âš ï¸  HIGH: EIP-7702 delegation initialized without safety checks. Delegation without validation of target contract Unsafe delegation initialization can brick the account if delegating to incompatible or malicious contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate delegation target: (1) Verify delegate implements required interfaces, (2) Ensure delegate is not zero address, (3) Check delegate has valid code, (4) Require signature for delegation setup, (5) Follow EIP-7702 security guidelines.

âš ï¸  HIGH: EIP-7702 delegation initialized without safety checks. Delegation without validation of target contract Unsafe delegation initialization can brick the account if delegating to incompatible or malicious contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate delegation target: (1) Verify delegate implements required interfaces, (2) Ensure delegate is not zero address, (3) Check delegate has valid code, (4) Require signature for delegation setup, (5) Follow EIP-7702 security guidelines.

âš ï¸  HIGH: EIP-7702 delegation initialized without safety checks. Delegation without validation of target contract Unsafe delegation initialization can brick the account if delegating to incompatible or malicious contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate delegation target: (1) Verify delegate implements required interfaces, (2) Ensure delegate is not zero address, (3) Check delegate has valid code, (4) Require signature for delegation setup, (5) Follow EIP-7702 security guidelines.

âš ï¸  HIGH: EIP-7702 delegation initialized without safety checks. Delegation without validation of target contract Unsafe delegation initialization can brick the account if delegating to incompatible or malicious contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate delegation target: (1) Verify delegate implements required interfaces, (2) Ensure delegate is not zero address, (3) Check delegate has valid code, (4) Require signature for delegation setup, (5) Follow EIP-7702 security guidelines.

âš ï¸  HIGH: EIP-7702 delegation initialized without safety checks. Delegation without validation of target contract Unsafe delegation initialization can brick the account if delegating to incompatible or malicious contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:0
   â”œâ”€ Detector: aa-initialization-vulnerability
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate delegation target: (1) Verify delegate implements required interfaces, (2) Ensure delegate is not zero address, (3) Check delegate has valid code, (4) Require signature for delegation setup, (5) Follow EIP-7702 security guidelines.

âš ï¸  HIGH: Delegation contract missing recovery mechanism. No recovery mechanism found - users cannot undo delegation Without recovery, hardware wallet users lose access if delegation target is compromised or becomes incompatible.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:1:0
   â”œâ”€ Detector: hardware-wallet-delegation
   â”œâ”€ CWE: CWE-672
   â””â”€ Fix: Implement delegation recovery: (1) Add removeDelegation function, (2) Allow switching delegation targets, (3) Implement emergency mode fallback, (4) Support direct EOA transactions, (5) Require hardware wallet signature for changes.

âš ï¸  HIGH: Delegation target not validated for interface compatibility. Missing interface validation can cause hardware wallet to delegate to incompatible code, bricking the account.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:1:0
   â”œâ”€ Detector: hardware-wallet-delegation
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Validate delegation target: (1) Check supportsInterface for EIP-165, (2) Verify required functions exist, (3) Test delegation in simulation first, (4) Implement delegation preview/confirmation, (5) Maintain whitelist of verified delegation targets.

ğŸ“ LOW: Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:2:0
   â”œâ”€ Detector: floating-pragma
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.

ğŸ“ LOW: State variable 'functionSelectors' is declared but never used. Unused state variables waste storage slots and increase deployment gas costs. Each unused storage slot costs gas during deployment.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:215:0
   â”œâ”€ Detector: unused-state-variables
   â”œâ”€ CWE: CWE-563
   â””â”€ Fix: Remove unused state variable 'functionSelectors'. If this variable is intended for future use, consider adding a TODO comment. If it needs to maintain storage layout for upgradeable contracts, add a comment explaining this.

ğŸ”¥ CRITICAL: Contract 'VulnerableUUPS' declares storage variables directly without using Diamond Storage pattern. This creates collision risk when multiple facets share the same proxy storage. Direct storage at sequential slots (0, 1, 2...) will collide across facets, corrupting state and causing critical failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:20:10
   â”œâ”€ Detector: diamond-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Implement Diamond Storage pattern for 'VulnerableUUPS': (1) Create a library with 'bytes32 constant STORAGE_POSITION = keccak256("diamond.storage.vulnerableuups")' (2) Define a struct containing all storage variables, (3) Create a function returning 'Storage storage ds' using assembly to set slot to STORAGE_POSITION, (4) Access all storage through this function instead of direct variables, (5) Use unique namespace per facet to guarantee isolation.

âš¡ MEDIUM: Contract 'VulnerableUUPS' is a Diamond proxy but missing required ERC-2535 Loupe functions: facets(), facetFunctionSelectors(address), facetAddresses(), facetAddress(bytes4). The Diamond Loupe standard defines 4 introspection functions that enable tools, users, and contracts to discover which facets and functions a Diamond implements. Without these, the Diamond becomes a black box, hindering integration, debugging, and security auditing.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:20:10
   â”œâ”€ Detector: diamond-loupe-violation
   â”œâ”€ CWE: CWE-573
   â””â”€ Fix: Implement missing Loupe functions in 'VulnerableUUPS': (1) facets() returning Facet[] array with address and selectors for each facet (2) facetFunctionSelectors(address _facet) returning bytes4[] of selectors for a facet (3) facetAddresses() returning address[] of all facet addresses (4) facetAddress(bytes4 _selector) returning address of facet for a selector (5) Implement IDiamondLoupe interface and add to supportsInterface

âš¡ MEDIUM: Contract 'VulnerableUUPS' implements loupe functions but doesn't declare IDiamondLoupe interface support. The ERC-2535 standard requires supportsInterface(0x48e2b093) to return true for IDiamondLoupe. Without proper interface support, tools cannot reliably detect Diamond Loupe compliance.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:20:10
   â”œâ”€ Detector: diamond-loupe-violation
   â”œâ”€ CWE: CWE-573
   â””â”€ Fix: Add interface support to 'VulnerableUUPS': (1) Import 'import "@openzeppelin/contracts/utils/introspection/IERC165.sol"' (2) Implement supportsInterface: 'return interfaceId == type(IDiamondLoupe).interfaceId || interfaceId == type(IERC165).interfaceId' (3) IDiamondLoupe interface ID is 0x48e2b093 (4) Ensure DiamondLoupeFacet is added during initialization (5) Test interface detection with supportsInterface

ğŸ”¥ CRITICAL: Contract 'VulnerableUUPS' fallback performs delegatecall without validating facet != address(0). When a function selector is not registered in selectorToFacet, it returns address(0). Delegatecall to address(0) succeeds silently in assembly, returning success=true without executing any code. This creates false success responses for non-existent functions, breaking contract behavior and potentially bypassing security checks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:20:10
   â”œâ”€ Detector: diamond-delegatecall-zero
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add facet validation in 'VulnerableUUPS' fallback: (1) After loading facet address, add 'require(facet != address(0), "Function does not exist")' (2) Check BEFORE delegatecall, not after (3) Use revert with custom error for gas efficiency: 'error FunctionNotFound(bytes4 selector)' (4) Consider explicit fallback failure rather than silent success (5) Validate facet in both Solidity and assembly implementations

ğŸ”¥ CRITICAL: Contract 'VulnerableUUPS' fallback delegates without verifying facet has code. Even if facet != address(0), the address may be an EOA or a self-destructed contract with no code. Delegatecall to addresses without code succeeds silently, returning success=true. This allows unregistered selectors to succeed unexpectedly, bypassing access controls and validation logic.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:20:10
   â”œâ”€ Detector: diamond-delegatecall-zero
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in 'VulnerableUUPS': (1) Validate 'require(facet.code.length > 0, "Facet has no code")' (2) In assembly, use EXTCODESIZE: 'if iszero(extcodesize(facet)) { revert(0, 0) }' (3) Perform check immediately after loading facet address (4) Consider caching code validation during facet registration (5) Handle self-destructed facets gracefully

ğŸ”¥ CRITICAL: Contract 'VulnerableUUPS' uses assembly delegatecall without proper validation. Assembly delegatecall bypasses Solidity's address validation, making it critical to manually check facet != 0 and extcodesize > 0. Missing validation in assembly is more dangerous because there are no implicit safety checks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:20:10
   â”œâ”€ Detector: diamond-delegatecall-zero
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add assembly validation in 'VulnerableUUPS': (1) After loading facet: 'if iszero(facet) { revert(0, 0) }' (2) Check code size: 'if iszero(extcodesize(facet)) { revert(0, 0) }' (3) Place checks immediately before delegatecall opcode (4) Use consistent error handling (revert with error code) (5) Document assembly validation logic clearly

âš ï¸  HIGH: Contract 'VulnerableUUPS' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:20:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

âš ï¸  HIGH: Function '' performs delegatecall in fallback/receive without access control. Fallback/receive function performs delegatecall without validating the caller. Any address can trigger this by calling a non-existent function or sending ETH. This allows any caller to execute arbitrary code by calling non-existent functions or sending ETH to the contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:5
   â”œâ”€ Detector: fallback-delegatecall-unprotected
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Add access control to fallback function ''. Validate implementation address before delegatecall. Use modifiers like 'onlyOwner' or check msg.sender explicitly. Consider using OpenZeppelin's transparent or UUPS proxy patterns.

âš¡ MEDIUM: Function 'upgradeTo' in proxy contract may shadow implementation. Function 'upgradeTo' may shadow implementation's function. In transparent proxies, use ifAdmin pattern to separate admin and user calls Real-world impact: Similar to issues in various proxy implementations where admin functions were shadowed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:14
   â”œâ”€ Detector: fallback-function-shadowing
   â””â”€ CWE: CWE-670

âš¡ MEDIUM: Function 'upgradeToUnchecked' in proxy contract may shadow implementation. Function 'upgradeToUnchecked' may shadow implementation's function. In transparent proxies, use ifAdmin pattern to separate admin and user calls Real-world impact: Similar to issues in various proxy implementations where admin functions were shadowed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:14
   â”œâ”€ Detector: fallback-function-shadowing
   â””â”€ CWE: CWE-670

âš ï¸  HIGH: SELFDESTRUCT recipient is not validated (can force ether to contracts)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:0:0
   â”œâ”€ Detector: selfdestruct-recipient-manipulation
   â”œâ”€ CWE: CWE-477
   â””â”€ Fix: Validate recipient address: require(recipient != address(0) && isApproved(recipient)). Be aware that selfdestruct can force ether to contracts that don't accept it.

âš¡ MEDIUM: SELFDESTRUCT without checking contract balance
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:0:0
   â”œâ”€ Detector: selfdestruct-recipient-manipulation
   â”œâ”€ CWE: CWE-477
   â””â”€ Fix: Check contract balance before selfdestruct to ensure expected state. Document that all remaining ether will be forcibly transferred to recipient.

âš¡ MEDIUM: EIP-7702 delegate uses storage - verify no collision with EOA state
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:1:0
   â”œâ”€ Detector: eip7702-storage-collision
   â””â”€ Fix: Use EIP-7201 namespaced storage to avoid collisions:

bytes32 private constant STORAGE_LOCATION = 
keccak256("myprotocol.delegate.storage");

struct DelegateStorage {
address owner;
mapping(address => uint256) balances;
}

function _getStorage() private pure returns (DelegateStorage storage $) {
assembly { $.slot := STORAGE_LOCATION }
}

âš ï¸  HIGH: Potential division before multiplication - causes precision loss (OWASP 2025)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:1:0
   â”œâ”€ Detector: logic-error-patterns
   â””â”€ Fix: âŒ PRECISION LOSS ($63.8M in losses):
uint256 reward = (amount / totalSupply) * rewardRate;
// Result: 0 if amount < totalSupply!

âœ… CORRECT ORDER:
uint256 reward = (amount * rewardRate) / totalSupply;
// Maximizes precision, multiply before divide

âœ… BEST: Use fixed-point math:
uint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;

Real incidents:
- Cork Protocol: $11M (May 2025) - Division rounding
- SIR.trading: $355K (March 2025) - Reward calculation
- Multiple 2024 incidents: $63.8M total

âš ï¸  HIGH: Assembly arithmetic detected - no overflow protection! ($223M Cetus DEX)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:1:0
   â”œâ”€ Detector: post-080-overflow
   â””â”€ Fix: ğŸš¨ CRITICAL: Assembly has NO overflow protection!

Real incident: Cetus DEX - $223M loss (May 2025)
Cause: Assembly arithmetic overflow

âŒ VULNERABLE (Cetus-style vulnerability):
assembly {
let result := add(a, b)  // NO OVERFLOW CHECK!
let product := mul(x, y) // NO OVERFLOW CHECK!
mstore(0x00, result)
}

âœ… SOLUTION 1 - Add manual checks:
assembly {
let result := add(a, b)
// Manual overflow check
if lt(result, a) {
revert(0, 0)  // Overflow detected
}
}

âœ… SOLUTION 2 - Use Solidity instead:
// Let Solidity handle overflow checks
uint256 result = a + b;  // Automatic overflow check

âœ… SOLUTION 3 - SafeMath for assembly:
function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c;
assembly {
c := add(a, b)
}
require(c >= a, "Overflow");  // Check outside assembly
return c;
}

Assembly arithmetic operations with NO checks:
- add(a, b)     â†’ wraps on overflow
- sub(a, b)     â†’ wraps on underflow
- mul(a, b)     â†’ wraps on overflow
- div(a, b)     â†’ returns 0 if b is 0 (no revert!)

âš ï¸ Only use assembly arithmetic when absolutely necessary
and with manual overflow checks!

âš ï¸  HIGH: Single-step ownership transfer - use 2-step transfer to prevent mistakes
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:1:0
   â”œâ”€ Detector: enhanced-access-control
   â””â”€ Fix: âŒ DANGEROUS - Single-step ownership transfer:
function transferOwnership(address newOwner) public onlyOwner {
owner = newOwner;  // What if newOwner is wrong address?
}
// Risk: Typo in address = permanent loss of control

âœ… SAFE - Two-step ownership transfer:
address public owner;
address public pendingOwner;

// Step 1: Current owner nominates new owner
function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0), "Zero address");
pendingOwner = newOwner;
emit OwnershipTransferStarted(owner, newOwner);
}

// Step 2: New owner must accept
function acceptOwnership() public {
require(msg.sender == pendingOwner, "Not pending owner");
address oldOwner = owner;
owner = pendingOwner;
pendingOwner = address(0);
emit OwnershipTransferred(oldOwner, owner);
}

âœ… BEST - Use OpenZeppelin Ownable2Step:
import "@openzeppelin/contracts/access/Ownable2Step.sol";

contract MyContract is Ownable2Step {
// Automatically has 2-step transfer
}

Benefits of 2-step:
- New owner must prove they control the address
- Prevents typos in addresses
- Allows cancellation before acceptance
- New owner can verify contract state first

ğŸ”¥ CRITICAL: Implementation contract 'VulnerableUUPS' has a constructor but does not call _disableInitializers(). The implementation contract can be initialized by an attacker.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:20:10
   â”œâ”€ Detector: implementation-not-initialized
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that calls _disableInitializers():

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This prevents the implementation contract from being initialized directly.

ğŸ”¥ CRITICAL: UUPS contract 'VulnerableUUPS' does not call _disableInitializers() in constructor. An attacker can initialize the implementation contract directly and potentially call upgradeTo() to brick all proxies or take control.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:20:10
   â”œâ”€ Detector: uups-missing-disable-initializers
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that disables initializers:

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This is especially critical for UUPS contracts since the upgrade logic lives in the implementation.

ğŸ”¥ CRITICAL: Implementation contract 'VulnerableUUPS' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableUUPS' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableUUPS' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableUUPS' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

âš ï¸  HIGH: Implementation contract 'VulnerableUUPS' has function 'changeAdmin' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'changeAdmin' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Implementation contract 'VulnerableUUPS' has function 'implementation' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'implementation' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Transparent proxy 'VulnerableUUPS': Setting admin to msg.sender in initializer - admin should be separate from users
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:410:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Ensure admin operations and user operations use separate addresses. The admin address can only call admin functions, not implementation functions.

âš ï¸  HIGH: Implementation contract 'VulnerableUUPS': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableUUPS': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableUUPS': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableUUPS': Function 'implementation()' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš¡ MEDIUM: Upgradeable contract 'VulnerableUUPS' has 22 state variable(s) but no storage gap. Adding new state variables in future upgrades may corrupt storage layout of derived contracts.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:0
   â”œâ”€ Detector: missing-storage-gap
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Add a storage gap at the end of the contract to reserve slots for future use:

contract UpgradeableBase is Initializable {
uint256 public value;

// Reserve 50 slots for future storage variables
// Reduce this number when adding new state variables
uint256[50] private __gap;
}

When adding new state variables, reduce the gap size accordingly:
uint256 public newValue; // Added in upgrade
uint256[49] private __gap; // Reduced from 50 to 49

ğŸ”¥ CRITICAL: Contract 'VulnerableUUPS' uses custom initialization tracking variable instead of OpenZeppelin's Initializable pattern. Custom tracking can be corrupted by storage collision during upgrades, allowing re-initialization attacks. This was the root cause of the AllianceBlock staking exploit in 2024.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:366:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Use OpenZeppelin's Initializable contract instead of custom tracking:

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract MyContract is Initializable {
function initialize() public initializer {
// initialization logic
}
}

ğŸ”¥ CRITICAL: Function 'initialize' in contract 'VulnerableUUPS' uses a custom require check for initialization instead of OpenZeppelin's initializer modifier. This pattern is vulnerable to storage collision attacks during upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:375:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Replace custom require check with OpenZeppelin's initializer modifier:

function initialize() public initializer {
// initialization logic
}

ğŸ”¥ CRITICAL: Proxy contract 'VulnerableUUPS' has state variable '' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

âš ï¸  HIGH: Beacon contract 'VulnerableUUPS' allows immediate upgrades without a timelock. Malicious or accidental upgrades will immediately affect all proxy contracts using this beacon, with no time for users to react.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: beacon-single-point-of-failure
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add a timelock to beacon upgrades:

uint256 public constant UPGRADE_DELAY = 2 days;
address public pendingImplementation;
uint256 public upgradeTimestamp;

function proposeUpgrade(address newImpl) external onlyOwner {
pendingImplementation = newImpl;
upgradeTimestamp = block.timestamp + UPGRADE_DELAY;
}

function executeUpgrade() external {
require(block.timestamp >= upgradeTimestamp);
_upgradeTo(pendingImplementation);
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableUUPS' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableUUPS' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableUUPS' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableUUPS' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableUUPS' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableUUPS' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableUUPS' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableUUPS' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Fallback function in Diamond contract 'VulnerableUUPS' performs delegatecall without checking facet code existence. This can cause silent failures for any call to the Diamond when the selected facet has been destroyed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in fallback:

fallback() external payable {
address facet = selectorToFacet[msg.sig];
require(facet != address(0), "Function not found");
require(facet.code.length > 0, "Facet destroyed");
// delegatecall...
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableUUPS' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableUUPS' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function '_authorizeUpgrade' in contract 'VulnerableUUPS' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:68:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableUUPS' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableUUPS' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeBeacon' in contract 'VulnerableUUPS' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:164:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'changeAdmin' in contract 'VulnerableUUPS' changes admin without emitting AdminChanged event.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Emit AdminChanged event:

function _changeAdmin(address newAdmin) internal {
emit AdminChanged(_getAdmin(), newAdmin);
_setAdmin(newAdmin);
}

âš ï¸  HIGH: Contract 'VulnerableUUPS' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:6:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableUUPS' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableUUPS' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:44:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableUUPS' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableUUPS' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableUUPS' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableUUPS' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableUUPS' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableUUPS' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableUUPS' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableUUPS' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'VulnerableUUPS' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:21:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'VulnerableUUPS' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:22:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'VulnerableUUPS' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:64:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'upgradeTo' in contract 'VulnerableUUPS' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:33:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'upgradeToUnchecked' in contract 'VulnerableUUPS' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'selfDestruct' in contract 'VulnerableUUPS' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:418:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'selfDestruct' in contract 'VulnerableUUPS' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'VulnerableUUPS' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableUUPS' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'clone' in contract 'VulnerableUUPS' uses assembly create/create2. Ensure bytecode source is trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:304:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate assembly deployment:

1. Verify bytecode hash before create/create2
2. Use high-level new ContractName() when possible
3. Audit all sources of deployment bytecode

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableUUPS' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableUUPS' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:106:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableUUPS' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:134:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableUUPS' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:176:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableUUPS' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:237:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableUUPS' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:275:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableUUPS' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:329:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableUUPS' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:386:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableUUPS' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableUUPS' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableUUPS' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableUUPS' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:324:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Upgrade function 'upgradeTo' in contract 'VulnerableUUPS' has weak protection. Owner-only upgrades without timelock allow rapid privilege changes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Strengthen upgrade protection:

1. Require timelock for upgrades
2. Use governance vote for implementation changes
3. Add upgrade delay period

Example:
function _authorizeUpgrade(address) internal override onlyTimelock {}

âš ï¸  HIGH: Function 'addFacet' in contract 'VulnerableUUPS' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:224:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'addFacet' in contract 'VulnerableUUPS' accepts unbounded array input. Large inputs can cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit input array size:

uint256 constant MAX_BATCH_SIZE = 100;

function processBatch(address[] calldata items) external {
require(
items.length <= MAX_BATCH_SIZE,
"Batch too large"
);
// ...
}

âš ï¸  HIGH: Function 'implementation' in contract 'VulnerableUUPS' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

ğŸ”¥ CRITICAL: Function 'upgradeTo' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'upgradeTo'

âš¡ MEDIUM: Address parameter 'newImplementation' in function 'upgradeTo' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:32
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(newImplementation != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter 'newImplementation' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:32
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(newImplementation != address(0), "Invalid address");

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:68:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

ğŸ”¥ CRITICAL: Function '_authorizeUpgrade' has upgradeable proxy vulnerability. Upgrade executes immediately without timelock delay, no time for users to exit before malicious upgrade Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:68:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in '_authorizeUpgrade'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'upgradeTo' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'upgradeTo'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'upgradeTo' is an unprotected proxy upgrade function. The upgrade function 'upgradeTo' is public and lacks access control modifiers. It modifies implementation storage without verifying msg.sender permissions. This allows any address to upgrade the implementation contract, potentially leading to complete takeover with fund theft and data manipulation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:14
   â”œâ”€ Detector: proxy-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo'. Use modifiers like 'onlyOwner', 'onlyAdmin', or implement role-based access control. Example: function upgradeTo(...) external onlyOwner { ... }

âš ï¸  HIGH: Contract 'VulnerableUUPSImplementation' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:63:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

âš¡ MEDIUM: Function 'upgradeTo' in proxy contract may shadow implementation. Function 'upgradeTo' may shadow implementation's function. In transparent proxies, use ifAdmin pattern to separate admin and user calls Real-world impact: Similar to issues in various proxy implementations where admin functions were shadowed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:14
   â”œâ”€ Detector: fallback-function-shadowing
   â””â”€ CWE: CWE-670

ğŸ”¥ CRITICAL: Implementation contract 'VulnerableUUPSImplementation' has a constructor but does not call _disableInitializers(). The implementation contract can be initialized by an attacker.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:63:10
   â”œâ”€ Detector: implementation-not-initialized
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that calls _disableInitializers():

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This prevents the implementation contract from being initialized directly.

ğŸ”¥ CRITICAL: UUPS contract 'VulnerableUUPSImplementation' does not call _disableInitializers() in constructor. An attacker can initialize the implementation contract directly and potentially call upgradeTo() to brick all proxies or take control.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:63:10
   â”œâ”€ Detector: uups-missing-disable-initializers
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that disables initializers:

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This is especially critical for UUPS contracts since the upgrade logic lives in the implementation.

ğŸ”¥ CRITICAL: Implementation contract 'VulnerableUUPSImplementation' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableUUPSImplementation' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableUUPSImplementation' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableUUPSImplementation' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

âš ï¸  HIGH: Implementation contract 'VulnerableUUPSImplementation' has function 'changeAdmin' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'changeAdmin' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Implementation contract 'VulnerableUUPSImplementation' has function 'implementation' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'implementation' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Transparent proxy 'VulnerableUUPSImplementation': Setting admin to msg.sender in initializer - admin should be separate from users
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:410:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Ensure admin operations and user operations use separate addresses. The admin address can only call admin functions, not implementation functions.

âš ï¸  HIGH: Implementation contract 'VulnerableUUPSImplementation': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableUUPSImplementation': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableUUPSImplementation': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableUUPSImplementation': Function 'implementation()' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš¡ MEDIUM: Upgradeable contract 'VulnerableUUPSImplementation' has 22 state variable(s) but no storage gap. Adding new state variables in future upgrades may corrupt storage layout of derived contracts.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:0
   â”œâ”€ Detector: missing-storage-gap
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Add a storage gap at the end of the contract to reserve slots for future use:

contract UpgradeableBase is Initializable {
uint256 public value;

// Reserve 50 slots for future storage variables
// Reduce this number when adding new state variables
uint256[50] private __gap;
}

When adding new state variables, reduce the gap size accordingly:
uint256 public newValue; // Added in upgrade
uint256[49] private __gap; // Reduced from 50 to 49

ğŸ”¥ CRITICAL: Contract 'VulnerableUUPSImplementation' uses custom initialization tracking variable instead of OpenZeppelin's Initializable pattern. Custom tracking can be corrupted by storage collision during upgrades, allowing re-initialization attacks. This was the root cause of the AllianceBlock staking exploit in 2024.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:366:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Use OpenZeppelin's Initializable contract instead of custom tracking:

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract MyContract is Initializable {
function initialize() public initializer {
// initialization logic
}
}

ğŸ”¥ CRITICAL: Function 'initialize' in contract 'VulnerableUUPSImplementation' uses a custom require check for initialization instead of OpenZeppelin's initializer modifier. This pattern is vulnerable to storage collision attacks during upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:375:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Replace custom require check with OpenZeppelin's initializer modifier:

function initialize() public initializer {
// initialization logic
}

ğŸ”¥ CRITICAL: Proxy contract 'VulnerableUUPSImplementation' has state variable '' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

âš ï¸  HIGH: Beacon contract 'VulnerableUUPSImplementation' allows immediate upgrades without a timelock. Malicious or accidental upgrades will immediately affect all proxy contracts using this beacon, with no time for users to react.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: beacon-single-point-of-failure
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add a timelock to beacon upgrades:

uint256 public constant UPGRADE_DELAY = 2 days;
address public pendingImplementation;
uint256 public upgradeTimestamp;

function proposeUpgrade(address newImpl) external onlyOwner {
pendingImplementation = newImpl;
upgradeTimestamp = block.timestamp + UPGRADE_DELAY;
}

function executeUpgrade() external {
require(block.timestamp >= upgradeTimestamp);
_upgradeTo(pendingImplementation);
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableUUPSImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableUUPSImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableUUPSImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableUUPSImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableUUPSImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableUUPSImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableUUPSImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableUUPSImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Fallback function in Diamond contract 'VulnerableUUPSImplementation' performs delegatecall without checking facet code existence. This can cause silent failures for any call to the Diamond when the selected facet has been destroyed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in fallback:

fallback() external payable {
address facet = selectorToFacet[msg.sig];
require(facet != address(0), "Function not found");
require(facet.code.length > 0, "Facet destroyed");
// delegatecall...
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableUUPSImplementation' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableUUPSImplementation' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function '_authorizeUpgrade' in contract 'VulnerableUUPSImplementation' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:68:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableUUPSImplementation' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableUUPSImplementation' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeBeacon' in contract 'VulnerableUUPSImplementation' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:164:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'changeAdmin' in contract 'VulnerableUUPSImplementation' changes admin without emitting AdminChanged event.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Emit AdminChanged event:

function _changeAdmin(address newAdmin) internal {
emit AdminChanged(_getAdmin(), newAdmin);
_setAdmin(newAdmin);
}

âš ï¸  HIGH: Contract 'VulnerableUUPSImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:6:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableUUPSImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableUUPSImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:44:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableUUPSImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableUUPSImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableUUPSImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableUUPSImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableUUPSImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableUUPSImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableUUPSImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableUUPSImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'VulnerableUUPSImplementation' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:21:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'VulnerableUUPSImplementation' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:22:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'VulnerableUUPSImplementation' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:64:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'upgradeTo' in contract 'VulnerableUUPSImplementation' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:33:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'upgradeToUnchecked' in contract 'VulnerableUUPSImplementation' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'selfDestruct' in contract 'VulnerableUUPSImplementation' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:418:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'selfDestruct' in contract 'VulnerableUUPSImplementation' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'VulnerableUUPSImplementation' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableUUPSImplementation' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'clone' in contract 'VulnerableUUPSImplementation' uses assembly create/create2. Ensure bytecode source is trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:304:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate assembly deployment:

1. Verify bytecode hash before create/create2
2. Use high-level new ContractName() when possible
3. Audit all sources of deployment bytecode

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableUUPSImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableUUPSImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:106:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableUUPSImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:134:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableUUPSImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:176:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableUUPSImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:237:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableUUPSImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:275:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableUUPSImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:329:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableUUPSImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:386:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableUUPSImplementation' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableUUPSImplementation' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableUUPSImplementation' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableUUPSImplementation' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:324:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Upgrade function 'upgradeTo' in contract 'VulnerableUUPSImplementation' has weak protection. Owner-only upgrades without timelock allow rapid privilege changes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Strengthen upgrade protection:

1. Require timelock for upgrades
2. Use governance vote for implementation changes
3. Add upgrade delay period

Example:
function _authorizeUpgrade(address) internal override onlyTimelock {}

âš ï¸  HIGH: Function 'addFacet' in contract 'VulnerableUUPSImplementation' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:224:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'addFacet' in contract 'VulnerableUUPSImplementation' accepts unbounded array input. Large inputs can cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit input array size:

uint256 constant MAX_BATCH_SIZE = 100;

function processBatch(address[] calldata items) external {
require(
items.length <= MAX_BATCH_SIZE,
"Batch too large"
);
// ...
}

âš ï¸  HIGH: Function 'implementation' in contract 'VulnerableUUPSImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

ğŸ”¥ CRITICAL: Function 'upgradeTo' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'upgradeTo'

âš¡ MEDIUM: Address parameter 'newImplementation' in function 'upgradeTo' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:32
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(newImplementation != address(0), "Zero address not allowed");

âš ï¸  HIGH: Address parameter 'newImplementation' in function 'adminUpgrade' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:99:35
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(newImplementation != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter 'newImplementation' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:32
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(newImplementation != address(0), "Invalid address");

ğŸ“ LOW: Parameter 'newImplementation' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:99:35
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(newImplementation != address(0), "Invalid address");

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

ğŸ”¥ CRITICAL: Function '' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:106:5
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in ''. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function '' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:106:5
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in ''. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

âš ï¸  HIGH: Function 'adminUpgrade' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:99:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'adminUpgrade'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

ğŸ”¥ CRITICAL: Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:5
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'upgradeTo' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'upgradeTo'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'adminUpgrade' has upgradeable proxy vulnerability. Upgrade executes immediately without timelock delay, no time for users to exit before malicious upgrade Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:99:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'adminUpgrade'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:106:5
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

âš¡ MEDIUM: Function 'adminUpgrade' contains variable shadowing. Parameter 'admin' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:99:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'adminUpgrade'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Function '' contains variable shadowing. Local variable 'impl' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:106:5
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in ''. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Contract 'VulnerableTransparentProxy' is a Diamond proxy but missing required ERC-2535 Loupe functions: facets(), facetFunctionSelectors(address), facetAddresses(), facetAddress(bytes4). The Diamond Loupe standard defines 4 introspection functions that enable tools, users, and contracts to discover which facets and functions a Diamond implements. Without these, the Diamond becomes a black box, hindering integration, debugging, and security auditing.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:83:10
   â”œâ”€ Detector: diamond-loupe-violation
   â”œâ”€ CWE: CWE-573
   â””â”€ Fix: Implement missing Loupe functions in 'VulnerableTransparentProxy': (1) facets() returning Facet[] array with address and selectors for each facet (2) facetFunctionSelectors(address _facet) returning bytes4[] of selectors for a facet (3) facetAddresses() returning address[] of all facet addresses (4) facetAddress(bytes4 _selector) returning address of facet for a selector (5) Implement IDiamondLoupe interface and add to supportsInterface

âš¡ MEDIUM: Contract 'VulnerableTransparentProxy' implements loupe functions but doesn't declare IDiamondLoupe interface support. The ERC-2535 standard requires supportsInterface(0x48e2b093) to return true for IDiamondLoupe. Without proper interface support, tools cannot reliably detect Diamond Loupe compliance.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:83:10
   â”œâ”€ Detector: diamond-loupe-violation
   â”œâ”€ CWE: CWE-573
   â””â”€ Fix: Add interface support to 'VulnerableTransparentProxy': (1) Import 'import "@openzeppelin/contracts/utils/introspection/IERC165.sol"' (2) Implement supportsInterface: 'return interfaceId == type(IDiamondLoupe).interfaceId || interfaceId == type(IERC165).interfaceId' (3) IDiamondLoupe interface ID is 0x48e2b093 (4) Ensure DiamondLoupeFacet is added during initialization (5) Test interface detection with supportsInterface

ğŸ”¥ CRITICAL: Contract 'VulnerableTransparentProxy' fallback performs delegatecall without validating facet != address(0). When a function selector is not registered in selectorToFacet, it returns address(0). Delegatecall to address(0) succeeds silently in assembly, returning success=true without executing any code. This creates false success responses for non-existent functions, breaking contract behavior and potentially bypassing security checks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:83:10
   â”œâ”€ Detector: diamond-delegatecall-zero
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add facet validation in 'VulnerableTransparentProxy' fallback: (1) After loading facet address, add 'require(facet != address(0), "Function does not exist")' (2) Check BEFORE delegatecall, not after (3) Use revert with custom error for gas efficiency: 'error FunctionNotFound(bytes4 selector)' (4) Consider explicit fallback failure rather than silent success (5) Validate facet in both Solidity and assembly implementations

ğŸ”¥ CRITICAL: Contract 'VulnerableTransparentProxy' fallback delegates without verifying facet has code. Even if facet != address(0), the address may be an EOA or a self-destructed contract with no code. Delegatecall to addresses without code succeeds silently, returning success=true. This allows unregistered selectors to succeed unexpectedly, bypassing access controls and validation logic.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:83:10
   â”œâ”€ Detector: diamond-delegatecall-zero
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in 'VulnerableTransparentProxy': (1) Validate 'require(facet.code.length > 0, "Facet has no code")' (2) In assembly, use EXTCODESIZE: 'if iszero(extcodesize(facet)) { revert(0, 0) }' (3) Perform check immediately after loading facet address (4) Consider caching code validation during facet registration (5) Handle self-destructed facets gracefully

ğŸ”¥ CRITICAL: Contract 'VulnerableTransparentProxy' uses assembly delegatecall without proper validation. Assembly delegatecall bypasses Solidity's address validation, making it critical to manually check facet != 0 and extcodesize > 0. Missing validation in assembly is more dangerous because there are no implicit safety checks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:83:10
   â”œâ”€ Detector: diamond-delegatecall-zero
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add assembly validation in 'VulnerableTransparentProxy': (1) After loading facet: 'if iszero(facet) { revert(0, 0) }' (2) Check code size: 'if iszero(extcodesize(facet)) { revert(0, 0) }' (3) Place checks immediately before delegatecall opcode (4) Use consistent error handling (revert with error code) (5) Document assembly validation logic clearly

ğŸ”¥ CRITICAL: Function 'upgradeTo' is an unprotected proxy upgrade function. The upgrade function 'upgradeTo' is public and lacks access control modifiers. It modifies implementation storage without verifying msg.sender permissions. This allows any address to upgrade the implementation contract, potentially leading to complete takeover with fund theft and data manipulation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:14
   â”œâ”€ Detector: proxy-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo'. Use modifiers like 'onlyOwner', 'onlyAdmin', or implement role-based access control. Example: function upgradeTo(...) external onlyOwner { ... }

âš ï¸  HIGH: Contract 'VulnerableTransparentProxy' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:83:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

âš ï¸  HIGH: Function '' performs delegatecall in fallback/receive without access control. Fallback/receive function performs delegatecall without validating the caller. Any address can trigger this by calling a non-existent function or sending ETH. This allows any caller to execute arbitrary code by calling non-existent functions or sending ETH to the contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:106:5
   â”œâ”€ Detector: fallback-delegatecall-unprotected
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Add access control to fallback function ''. Validate implementation address before delegatecall. Use modifiers like 'onlyOwner' or check msg.sender explicitly. Consider using OpenZeppelin's transparent or UUPS proxy patterns.

âš¡ MEDIUM: Function 'upgradeTo' in proxy contract may shadow implementation. Function 'upgradeTo' may shadow implementation's function. In transparent proxies, use ifAdmin pattern to separate admin and user calls Real-world impact: Similar to issues in various proxy implementations where admin functions were shadowed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:14
   â”œâ”€ Detector: fallback-function-shadowing
   â””â”€ CWE: CWE-670

ğŸ”¥ CRITICAL: Implementation contract 'VulnerableTransparentProxy' has a constructor but does not call _disableInitializers(). The implementation contract can be initialized by an attacker.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:83:10
   â”œâ”€ Detector: implementation-not-initialized
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that calls _disableInitializers():

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This prevents the implementation contract from being initialized directly.

ğŸ”¥ CRITICAL: UUPS contract 'VulnerableTransparentProxy' does not call _disableInitializers() in constructor. An attacker can initialize the implementation contract directly and potentially call upgradeTo() to brick all proxies or take control.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:83:10
   â”œâ”€ Detector: uups-missing-disable-initializers
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that disables initializers:

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This is especially critical for UUPS contracts since the upgrade logic lives in the implementation.

ğŸ”¥ CRITICAL: Implementation contract 'VulnerableTransparentProxy' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableTransparentProxy' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableTransparentProxy' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableTransparentProxy' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

âš ï¸  HIGH: Implementation contract 'VulnerableTransparentProxy' has function 'changeAdmin' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'changeAdmin' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Implementation contract 'VulnerableTransparentProxy' has function 'implementation' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'implementation' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Transparent proxy 'VulnerableTransparentProxy': Setting admin to msg.sender in initializer - admin should be separate from users
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:410:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Ensure admin operations and user operations use separate addresses. The admin address can only call admin functions, not implementation functions.

âš ï¸  HIGH: Implementation contract 'VulnerableTransparentProxy': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableTransparentProxy': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableTransparentProxy': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableTransparentProxy': Function 'implementation()' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš¡ MEDIUM: Upgradeable contract 'VulnerableTransparentProxy' has 22 state variable(s) but no storage gap. Adding new state variables in future upgrades may corrupt storage layout of derived contracts.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:0
   â”œâ”€ Detector: missing-storage-gap
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Add a storage gap at the end of the contract to reserve slots for future use:

contract UpgradeableBase is Initializable {
uint256 public value;

// Reserve 50 slots for future storage variables
// Reduce this number when adding new state variables
uint256[50] private __gap;
}

When adding new state variables, reduce the gap size accordingly:
uint256 public newValue; // Added in upgrade
uint256[49] private __gap; // Reduced from 50 to 49

ğŸ”¥ CRITICAL: Contract 'VulnerableTransparentProxy' uses custom initialization tracking variable instead of OpenZeppelin's Initializable pattern. Custom tracking can be corrupted by storage collision during upgrades, allowing re-initialization attacks. This was the root cause of the AllianceBlock staking exploit in 2024.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:366:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Use OpenZeppelin's Initializable contract instead of custom tracking:

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract MyContract is Initializable {
function initialize() public initializer {
// initialization logic
}
}

ğŸ”¥ CRITICAL: Function 'initialize' in contract 'VulnerableTransparentProxy' uses a custom require check for initialization instead of OpenZeppelin's initializer modifier. This pattern is vulnerable to storage collision attacks during upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:375:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Replace custom require check with OpenZeppelin's initializer modifier:

function initialize() public initializer {
// initialization logic
}

ğŸ”¥ CRITICAL: Proxy contract 'VulnerableTransparentProxy' has state variable '' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

âš ï¸  HIGH: Beacon contract 'VulnerableTransparentProxy' allows immediate upgrades without a timelock. Malicious or accidental upgrades will immediately affect all proxy contracts using this beacon, with no time for users to react.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: beacon-single-point-of-failure
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add a timelock to beacon upgrades:

uint256 public constant UPGRADE_DELAY = 2 days;
address public pendingImplementation;
uint256 public upgradeTimestamp;

function proposeUpgrade(address newImpl) external onlyOwner {
pendingImplementation = newImpl;
upgradeTimestamp = block.timestamp + UPGRADE_DELAY;
}

function executeUpgrade() external {
require(block.timestamp >= upgradeTimestamp);
_upgradeTo(pendingImplementation);
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableTransparentProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableTransparentProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableTransparentProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableTransparentProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableTransparentProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableTransparentProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableTransparentProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableTransparentProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Fallback function in Diamond contract 'VulnerableTransparentProxy' performs delegatecall without checking facet code existence. This can cause silent failures for any call to the Diamond when the selected facet has been destroyed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in fallback:

fallback() external payable {
address facet = selectorToFacet[msg.sig];
require(facet != address(0), "Function not found");
require(facet.code.length > 0, "Facet destroyed");
// delegatecall...
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableTransparentProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableTransparentProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function '_authorizeUpgrade' in contract 'VulnerableTransparentProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:68:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableTransparentProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableTransparentProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeBeacon' in contract 'VulnerableTransparentProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:164:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'changeAdmin' in contract 'VulnerableTransparentProxy' changes admin without emitting AdminChanged event.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Emit AdminChanged event:

function _changeAdmin(address newAdmin) internal {
emit AdminChanged(_getAdmin(), newAdmin);
_setAdmin(newAdmin);
}

âš ï¸  HIGH: Contract 'VulnerableTransparentProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:6:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableTransparentProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableTransparentProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:44:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableTransparentProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableTransparentProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableTransparentProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableTransparentProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableTransparentProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableTransparentProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableTransparentProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableTransparentProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'VulnerableTransparentProxy' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:21:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'VulnerableTransparentProxy' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:22:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'VulnerableTransparentProxy' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:64:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'upgradeTo' in contract 'VulnerableTransparentProxy' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:33:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'upgradeToUnchecked' in contract 'VulnerableTransparentProxy' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'selfDestruct' in contract 'VulnerableTransparentProxy' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:418:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'selfDestruct' in contract 'VulnerableTransparentProxy' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'VulnerableTransparentProxy' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableTransparentProxy' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'clone' in contract 'VulnerableTransparentProxy' uses assembly create/create2. Ensure bytecode source is trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:304:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate assembly deployment:

1. Verify bytecode hash before create/create2
2. Use high-level new ContractName() when possible
3. Audit all sources of deployment bytecode

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableTransparentProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableTransparentProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:106:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableTransparentProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:134:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableTransparentProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:176:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableTransparentProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:237:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableTransparentProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:275:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableTransparentProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:329:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableTransparentProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:386:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableTransparentProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableTransparentProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableTransparentProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableTransparentProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:324:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Upgrade function 'upgradeTo' in contract 'VulnerableTransparentProxy' has weak protection. Owner-only upgrades without timelock allow rapid privilege changes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Strengthen upgrade protection:

1. Require timelock for upgrades
2. Use governance vote for implementation changes
3. Add upgrade delay period

Example:
function _authorizeUpgrade(address) internal override onlyTimelock {}

âš ï¸  HIGH: Function 'addFacet' in contract 'VulnerableTransparentProxy' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:224:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'addFacet' in contract 'VulnerableTransparentProxy' accepts unbounded array input. Large inputs can cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit input array size:

uint256 constant MAX_BATCH_SIZE = 100;

function processBatch(address[] calldata items) external {
require(
items.length <= MAX_BATCH_SIZE,
"Batch too large"
);
// ...
}

âš ï¸  HIGH: Function 'implementation' in contract 'VulnerableTransparentProxy' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Address parameter 'newAdmin' in function 'changeAdmin' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:34
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(newAdmin != address(0), "Zero address not allowed");

âš ï¸  HIGH: Parameter 'newAdmin' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:34
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(newAdmin != address(0), "Invalid address");

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

ğŸ”¥ CRITICAL: Function '' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:134:5
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in ''. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function '' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:134:5
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in ''. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

âš ï¸  HIGH: Function 'changeAdmin' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'changeAdmin'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

ğŸ”¥ CRITICAL: Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:134:5
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

âš¡ MEDIUM: Function '' contains variable shadowing. Local variable 'impl' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:134:5
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in ''. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Contract 'TransparentProxySelectorCollision' is a Diamond proxy but missing required ERC-2535 Loupe functions: facets(), facetFunctionSelectors(address), facetAddresses(), facetAddress(bytes4). The Diamond Loupe standard defines 4 introspection functions that enable tools, users, and contracts to discover which facets and functions a Diamond implements. Without these, the Diamond becomes a black box, hindering integration, debugging, and security auditing.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:123:10
   â”œâ”€ Detector: diamond-loupe-violation
   â”œâ”€ CWE: CWE-573
   â””â”€ Fix: Implement missing Loupe functions in 'TransparentProxySelectorCollision': (1) facets() returning Facet[] array with address and selectors for each facet (2) facetFunctionSelectors(address _facet) returning bytes4[] of selectors for a facet (3) facetAddresses() returning address[] of all facet addresses (4) facetAddress(bytes4 _selector) returning address of facet for a selector (5) Implement IDiamondLoupe interface and add to supportsInterface

âš¡ MEDIUM: Contract 'TransparentProxySelectorCollision' implements loupe functions but doesn't declare IDiamondLoupe interface support. The ERC-2535 standard requires supportsInterface(0x48e2b093) to return true for IDiamondLoupe. Without proper interface support, tools cannot reliably detect Diamond Loupe compliance.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:123:10
   â”œâ”€ Detector: diamond-loupe-violation
   â”œâ”€ CWE: CWE-573
   â””â”€ Fix: Add interface support to 'TransparentProxySelectorCollision': (1) Import 'import "@openzeppelin/contracts/utils/introspection/IERC165.sol"' (2) Implement supportsInterface: 'return interfaceId == type(IDiamondLoupe).interfaceId || interfaceId == type(IERC165).interfaceId' (3) IDiamondLoupe interface ID is 0x48e2b093 (4) Ensure DiamondLoupeFacet is added during initialization (5) Test interface detection with supportsInterface

ğŸ”¥ CRITICAL: Contract 'TransparentProxySelectorCollision' fallback performs delegatecall without validating facet != address(0). When a function selector is not registered in selectorToFacet, it returns address(0). Delegatecall to address(0) succeeds silently in assembly, returning success=true without executing any code. This creates false success responses for non-existent functions, breaking contract behavior and potentially bypassing security checks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:123:10
   â”œâ”€ Detector: diamond-delegatecall-zero
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add facet validation in 'TransparentProxySelectorCollision' fallback: (1) After loading facet address, add 'require(facet != address(0), "Function does not exist")' (2) Check BEFORE delegatecall, not after (3) Use revert with custom error for gas efficiency: 'error FunctionNotFound(bytes4 selector)' (4) Consider explicit fallback failure rather than silent success (5) Validate facet in both Solidity and assembly implementations

ğŸ”¥ CRITICAL: Contract 'TransparentProxySelectorCollision' fallback delegates without verifying facet has code. Even if facet != address(0), the address may be an EOA or a self-destructed contract with no code. Delegatecall to addresses without code succeeds silently, returning success=true. This allows unregistered selectors to succeed unexpectedly, bypassing access controls and validation logic.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:123:10
   â”œâ”€ Detector: diamond-delegatecall-zero
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in 'TransparentProxySelectorCollision': (1) Validate 'require(facet.code.length > 0, "Facet has no code")' (2) In assembly, use EXTCODESIZE: 'if iszero(extcodesize(facet)) { revert(0, 0) }' (3) Perform check immediately after loading facet address (4) Consider caching code validation during facet registration (5) Handle self-destructed facets gracefully

ğŸ”¥ CRITICAL: Contract 'TransparentProxySelectorCollision' uses assembly delegatecall without proper validation. Assembly delegatecall bypasses Solidity's address validation, making it critical to manually check facet != 0 and extcodesize > 0. Missing validation in assembly is more dangerous because there are no implicit safety checks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:123:10
   â”œâ”€ Detector: diamond-delegatecall-zero
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add assembly validation in 'TransparentProxySelectorCollision': (1) After loading facet: 'if iszero(facet) { revert(0, 0) }' (2) Check code size: 'if iszero(extcodesize(facet)) { revert(0, 0) }' (3) Place checks immediately before delegatecall opcode (4) Use consistent error handling (revert with error code) (5) Document assembly validation logic clearly

âš ï¸  HIGH: Contract 'TransparentProxySelectorCollision' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:123:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

âš ï¸  HIGH: Function '' performs delegatecall in fallback/receive without access control. Fallback/receive function performs delegatecall without validating the caller. Any address can trigger this by calling a non-existent function or sending ETH. This allows any caller to execute arbitrary code by calling non-existent functions or sending ETH to the contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:134:5
   â”œâ”€ Detector: fallback-delegatecall-unprotected
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Add access control to fallback function ''. Validate implementation address before delegatecall. Use modifiers like 'onlyOwner' or check msg.sender explicitly. Consider using OpenZeppelin's transparent or UUPS proxy patterns.

ğŸ”¥ CRITICAL: Implementation contract 'TransparentProxySelectorCollision' has a constructor but does not call _disableInitializers(). The implementation contract can be initialized by an attacker.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:123:10
   â”œâ”€ Detector: implementation-not-initialized
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that calls _disableInitializers():

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This prevents the implementation contract from being initialized directly.

ğŸ”¥ CRITICAL: UUPS contract 'TransparentProxySelectorCollision' does not call _disableInitializers() in constructor. An attacker can initialize the implementation contract directly and potentially call upgradeTo() to brick all proxies or take control.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:123:10
   â”œâ”€ Detector: uups-missing-disable-initializers
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that disables initializers:

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This is especially critical for UUPS contracts since the upgrade logic lives in the implementation.

ğŸ”¥ CRITICAL: Implementation contract 'TransparentProxySelectorCollision' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Beacon contract 'TransparentProxySelectorCollision' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'TransparentProxySelectorCollision' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'TransparentProxySelectorCollision' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

âš ï¸  HIGH: Implementation contract 'TransparentProxySelectorCollision' has function 'changeAdmin' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'changeAdmin' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Implementation contract 'TransparentProxySelectorCollision' has function 'implementation' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'implementation' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Transparent proxy 'TransparentProxySelectorCollision': Setting admin to msg.sender in initializer - admin should be separate from users
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:410:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Ensure admin operations and user operations use separate addresses. The admin address can only call admin functions, not implementation functions.

âš ï¸  HIGH: Implementation contract 'TransparentProxySelectorCollision': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'TransparentProxySelectorCollision': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'TransparentProxySelectorCollision': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'TransparentProxySelectorCollision': Function 'implementation()' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš¡ MEDIUM: Upgradeable contract 'TransparentProxySelectorCollision' has 22 state variable(s) but no storage gap. Adding new state variables in future upgrades may corrupt storage layout of derived contracts.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:0
   â”œâ”€ Detector: missing-storage-gap
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Add a storage gap at the end of the contract to reserve slots for future use:

contract UpgradeableBase is Initializable {
uint256 public value;

// Reserve 50 slots for future storage variables
// Reduce this number when adding new state variables
uint256[50] private __gap;
}

When adding new state variables, reduce the gap size accordingly:
uint256 public newValue; // Added in upgrade
uint256[49] private __gap; // Reduced from 50 to 49

ğŸ”¥ CRITICAL: Contract 'TransparentProxySelectorCollision' uses custom initialization tracking variable instead of OpenZeppelin's Initializable pattern. Custom tracking can be corrupted by storage collision during upgrades, allowing re-initialization attacks. This was the root cause of the AllianceBlock staking exploit in 2024.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:366:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Use OpenZeppelin's Initializable contract instead of custom tracking:

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract MyContract is Initializable {
function initialize() public initializer {
// initialization logic
}
}

ğŸ”¥ CRITICAL: Function 'initialize' in contract 'TransparentProxySelectorCollision' uses a custom require check for initialization instead of OpenZeppelin's initializer modifier. This pattern is vulnerable to storage collision attacks during upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:375:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Replace custom require check with OpenZeppelin's initializer modifier:

function initialize() public initializer {
// initialization logic
}

ğŸ”¥ CRITICAL: Proxy contract 'TransparentProxySelectorCollision' has state variable '' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

âš ï¸  HIGH: Beacon contract 'TransparentProxySelectorCollision' allows immediate upgrades without a timelock. Malicious or accidental upgrades will immediately affect all proxy contracts using this beacon, with no time for users to react.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: beacon-single-point-of-failure
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add a timelock to beacon upgrades:

uint256 public constant UPGRADE_DELAY = 2 days;
address public pendingImplementation;
uint256 public upgradeTimestamp;

function proposeUpgrade(address newImpl) external onlyOwner {
pendingImplementation = newImpl;
upgradeTimestamp = block.timestamp + UPGRADE_DELAY;
}

function executeUpgrade() external {
require(block.timestamp >= upgradeTimestamp);
_upgradeTo(pendingImplementation);
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'TransparentProxySelectorCollision' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'TransparentProxySelectorCollision' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'TransparentProxySelectorCollision' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'TransparentProxySelectorCollision' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'TransparentProxySelectorCollision' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'TransparentProxySelectorCollision' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'TransparentProxySelectorCollision' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'TransparentProxySelectorCollision' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Fallback function in Diamond contract 'TransparentProxySelectorCollision' performs delegatecall without checking facet code existence. This can cause silent failures for any call to the Diamond when the selected facet has been destroyed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in fallback:

fallback() external payable {
address facet = selectorToFacet[msg.sig];
require(facet != address(0), "Function not found");
require(facet.code.length > 0, "Facet destroyed");
// delegatecall...
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'TransparentProxySelectorCollision' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'TransparentProxySelectorCollision' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function '_authorizeUpgrade' in contract 'TransparentProxySelectorCollision' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:68:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'TransparentProxySelectorCollision' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'TransparentProxySelectorCollision' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeBeacon' in contract 'TransparentProxySelectorCollision' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:164:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'changeAdmin' in contract 'TransparentProxySelectorCollision' changes admin without emitting AdminChanged event.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Emit AdminChanged event:

function _changeAdmin(address newAdmin) internal {
emit AdminChanged(_getAdmin(), newAdmin);
_setAdmin(newAdmin);
}

âš ï¸  HIGH: Contract 'TransparentProxySelectorCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:6:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'TransparentProxySelectorCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'TransparentProxySelectorCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:44:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'TransparentProxySelectorCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'TransparentProxySelectorCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'TransparentProxySelectorCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'TransparentProxySelectorCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'TransparentProxySelectorCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'TransparentProxySelectorCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'TransparentProxySelectorCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'TransparentProxySelectorCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'TransparentProxySelectorCollision' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:21:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'TransparentProxySelectorCollision' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:22:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'TransparentProxySelectorCollision' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:64:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'upgradeTo' in contract 'TransparentProxySelectorCollision' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:33:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'upgradeToUnchecked' in contract 'TransparentProxySelectorCollision' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'selfDestruct' in contract 'TransparentProxySelectorCollision' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:418:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'selfDestruct' in contract 'TransparentProxySelectorCollision' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'TransparentProxySelectorCollision' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'TransparentProxySelectorCollision' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'clone' in contract 'TransparentProxySelectorCollision' uses assembly create/create2. Ensure bytecode source is trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:304:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate assembly deployment:

1. Verify bytecode hash before create/create2
2. Use high-level new ContractName() when possible
3. Audit all sources of deployment bytecode

ğŸ”¥ CRITICAL: Proxy fallback in contract 'TransparentProxySelectorCollision' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'TransparentProxySelectorCollision' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:106:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'TransparentProxySelectorCollision' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:134:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'TransparentProxySelectorCollision' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:176:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'TransparentProxySelectorCollision' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:237:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'TransparentProxySelectorCollision' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:275:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'TransparentProxySelectorCollision' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:329:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'TransparentProxySelectorCollision' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:386:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'TransparentProxySelectorCollision' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'TransparentProxySelectorCollision' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'TransparentProxySelectorCollision' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'TransparentProxySelectorCollision' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:324:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Upgrade function 'upgradeTo' in contract 'TransparentProxySelectorCollision' has weak protection. Owner-only upgrades without timelock allow rapid privilege changes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Strengthen upgrade protection:

1. Require timelock for upgrades
2. Use governance vote for implementation changes
3. Add upgrade delay period

Example:
function _authorizeUpgrade(address) internal override onlyTimelock {}

âš ï¸  HIGH: Function 'addFacet' in contract 'TransparentProxySelectorCollision' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:224:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'addFacet' in contract 'TransparentProxySelectorCollision' accepts unbounded array input. Large inputs can cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit input array size:

uint256 constant MAX_BATCH_SIZE = 100;

function processBatch(address[] calldata items) external {
require(
items.length <= MAX_BATCH_SIZE,
"Batch too large"
);
// ...
}

âš ï¸  HIGH: Function 'implementation' in contract 'TransparentProxySelectorCollision' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

âš ï¸  HIGH: Contract 'IBeacon' has potential proxy storage collision vulnerability. Upgradeable contract is missing storage gap reservation. Future upgrades may cause storage layout collisions. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:152:11
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

ğŸ”¥ CRITICAL: Implementation contract 'IBeacon' has a constructor but does not call _disableInitializers(). The implementation contract can be initialized by an attacker.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:152:11
   â”œâ”€ Detector: implementation-not-initialized
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that calls _disableInitializers():

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This prevents the implementation contract from being initialized directly.

ğŸ”¥ CRITICAL: UUPS contract 'IBeacon' does not call _disableInitializers() in constructor. An attacker can initialize the implementation contract directly and potentially call upgradeTo() to brick all proxies or take control.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:152:11
   â”œâ”€ Detector: uups-missing-disable-initializers
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that disables initializers:

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This is especially critical for UUPS contracts since the upgrade logic lives in the implementation.

ğŸ”¥ CRITICAL: Implementation contract 'IBeacon' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Beacon contract 'IBeacon' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'IBeacon' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'IBeacon' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

âš ï¸  HIGH: Implementation contract 'IBeacon' has function 'changeAdmin' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'changeAdmin' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Implementation contract 'IBeacon' has function 'implementation' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'implementation' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Transparent proxy 'IBeacon': Setting admin to msg.sender in initializer - admin should be separate from users
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:410:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Ensure admin operations and user operations use separate addresses. The admin address can only call admin functions, not implementation functions.

âš ï¸  HIGH: Implementation contract 'IBeacon': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'IBeacon': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'IBeacon': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'IBeacon': Function 'implementation()' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš¡ MEDIUM: Upgradeable contract 'IBeacon' has 22 state variable(s) but no storage gap. Adding new state variables in future upgrades may corrupt storage layout of derived contracts.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:0
   â”œâ”€ Detector: missing-storage-gap
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Add a storage gap at the end of the contract to reserve slots for future use:

contract UpgradeableBase is Initializable {
uint256 public value;

// Reserve 50 slots for future storage variables
// Reduce this number when adding new state variables
uint256[50] private __gap;
}

When adding new state variables, reduce the gap size accordingly:
uint256 public newValue; // Added in upgrade
uint256[49] private __gap; // Reduced from 50 to 49

ğŸ”¥ CRITICAL: Contract 'IBeacon' uses custom initialization tracking variable instead of OpenZeppelin's Initializable pattern. Custom tracking can be corrupted by storage collision during upgrades, allowing re-initialization attacks. This was the root cause of the AllianceBlock staking exploit in 2024.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:366:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Use OpenZeppelin's Initializable contract instead of custom tracking:

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract MyContract is Initializable {
function initialize() public initializer {
// initialization logic
}
}

ğŸ”¥ CRITICAL: Function 'initialize' in contract 'IBeacon' uses a custom require check for initialization instead of OpenZeppelin's initializer modifier. This pattern is vulnerable to storage collision attacks during upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:375:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Replace custom require check with OpenZeppelin's initializer modifier:

function initialize() public initializer {
// initialization logic
}

ğŸ”¥ CRITICAL: Proxy contract 'IBeacon' has state variable '' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

âš ï¸  HIGH: Beacon contract 'IBeacon' allows immediate upgrades without a timelock. Malicious or accidental upgrades will immediately affect all proxy contracts using this beacon, with no time for users to react.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: beacon-single-point-of-failure
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add a timelock to beacon upgrades:

uint256 public constant UPGRADE_DELAY = 2 days;
address public pendingImplementation;
uint256 public upgradeTimestamp;

function proposeUpgrade(address newImpl) external onlyOwner {
pendingImplementation = newImpl;
upgradeTimestamp = block.timestamp + UPGRADE_DELAY;
}

function executeUpgrade() external {
require(block.timestamp >= upgradeTimestamp);
_upgradeTo(pendingImplementation);
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'IBeacon' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'IBeacon' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'IBeacon' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'IBeacon' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'IBeacon' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'IBeacon' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'IBeacon' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'IBeacon' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Fallback function in Diamond contract 'IBeacon' performs delegatecall without checking facet code existence. This can cause silent failures for any call to the Diamond when the selected facet has been destroyed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in fallback:

fallback() external payable {
address facet = selectorToFacet[msg.sig];
require(facet != address(0), "Function not found");
require(facet.code.length > 0, "Facet destroyed");
// delegatecall...
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'IBeacon' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'IBeacon' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function '_authorizeUpgrade' in contract 'IBeacon' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:68:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'IBeacon' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'IBeacon' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeBeacon' in contract 'IBeacon' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:164:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'changeAdmin' in contract 'IBeacon' changes admin without emitting AdminChanged event.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Emit AdminChanged event:

function _changeAdmin(address newAdmin) internal {
emit AdminChanged(_getAdmin(), newAdmin);
_setAdmin(newAdmin);
}

âš ï¸  HIGH: Contract 'IBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:6:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:44:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'IBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'IBeacon' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:21:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'IBeacon' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:22:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'IBeacon' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:64:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'upgradeTo' in contract 'IBeacon' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:33:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'upgradeToUnchecked' in contract 'IBeacon' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'selfDestruct' in contract 'IBeacon' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:418:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'selfDestruct' in contract 'IBeacon' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'IBeacon' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'IBeacon' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'clone' in contract 'IBeacon' uses assembly create/create2. Ensure bytecode source is trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:304:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate assembly deployment:

1. Verify bytecode hash before create/create2
2. Use high-level new ContractName() when possible
3. Audit all sources of deployment bytecode

ğŸ”¥ CRITICAL: Proxy fallback in contract 'IBeacon' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'IBeacon' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:106:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'IBeacon' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:134:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'IBeacon' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:176:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'IBeacon' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:237:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'IBeacon' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:275:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'IBeacon' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:329:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'IBeacon' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:386:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'IBeacon' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'IBeacon' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'IBeacon' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'IBeacon' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:324:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Upgrade function 'upgradeTo' in contract 'IBeacon' has weak protection. Owner-only upgrades without timelock allow rapid privilege changes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Strengthen upgrade protection:

1. Require timelock for upgrades
2. Use governance vote for implementation changes
3. Add upgrade delay period

Example:
function _authorizeUpgrade(address) internal override onlyTimelock {}

âš ï¸  HIGH: Function 'addFacet' in contract 'IBeacon' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:224:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'addFacet' in contract 'IBeacon' accepts unbounded array input. Large inputs can cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit input array size:

uint256 constant MAX_BATCH_SIZE = 100;

function processBatch(address[] calldata items) external {
require(
items.length <= MAX_BATCH_SIZE,
"Batch too large"
);
// ...
}

âš ï¸  HIGH: Function 'implementation' in contract 'IBeacon' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

ğŸ”¥ CRITICAL: Function 'upgradeBeacon' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:164:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'upgradeBeacon'

âš¡ MEDIUM: Address parameter 'newBeacon' in function 'upgradeBeacon' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:164:36
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(newBeacon != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter 'newBeacon' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:164:36
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(newBeacon != address(0), "Invalid address");

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:159:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

ğŸ”¥ CRITICAL: Function '' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:176:5
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in ''. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function '' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:176:5
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in ''. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function 'upgradeBeacon' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:164:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'upgradeBeacon'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function '_implementation' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:170:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in '_implementation'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:176:5
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

âš¡ MEDIUM: Function '_implementation' contains variable shadowing. Parameter 'beacon' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:170:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in '_implementation'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

ğŸ”¥ CRITICAL: Contract 'VulnerableBeaconProxy' declares storage variables directly without using Diamond Storage pattern. This creates collision risk when multiple facets share the same proxy storage. Direct storage at sequential slots (0, 1, 2...) will collide across facets, corrupting state and causing critical failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:156:10
   â”œâ”€ Detector: diamond-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Implement Diamond Storage pattern for 'VulnerableBeaconProxy': (1) Create a library with 'bytes32 constant STORAGE_POSITION = keccak256("diamond.storage.vulnerablebeaconproxy")' (2) Define a struct containing all storage variables, (3) Create a function returning 'Storage storage ds' using assembly to set slot to STORAGE_POSITION, (4) Access all storage through this function instead of direct variables, (5) Use unique namespace per facet to guarantee isolation.

âš¡ MEDIUM: Contract 'VulnerableBeaconProxy' is a Diamond proxy but missing required ERC-2535 Loupe functions: facets(), facetFunctionSelectors(address), facetAddresses(), facetAddress(bytes4). The Diamond Loupe standard defines 4 introspection functions that enable tools, users, and contracts to discover which facets and functions a Diamond implements. Without these, the Diamond becomes a black box, hindering integration, debugging, and security auditing.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:156:10
   â”œâ”€ Detector: diamond-loupe-violation
   â”œâ”€ CWE: CWE-573
   â””â”€ Fix: Implement missing Loupe functions in 'VulnerableBeaconProxy': (1) facets() returning Facet[] array with address and selectors for each facet (2) facetFunctionSelectors(address _facet) returning bytes4[] of selectors for a facet (3) facetAddresses() returning address[] of all facet addresses (4) facetAddress(bytes4 _selector) returning address of facet for a selector (5) Implement IDiamondLoupe interface and add to supportsInterface

âš¡ MEDIUM: Contract 'VulnerableBeaconProxy' implements loupe functions but doesn't declare IDiamondLoupe interface support. The ERC-2535 standard requires supportsInterface(0x48e2b093) to return true for IDiamondLoupe. Without proper interface support, tools cannot reliably detect Diamond Loupe compliance.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:156:10
   â”œâ”€ Detector: diamond-loupe-violation
   â”œâ”€ CWE: CWE-573
   â””â”€ Fix: Add interface support to 'VulnerableBeaconProxy': (1) Import 'import "@openzeppelin/contracts/utils/introspection/IERC165.sol"' (2) Implement supportsInterface: 'return interfaceId == type(IDiamondLoupe).interfaceId || interfaceId == type(IERC165).interfaceId' (3) IDiamondLoupe interface ID is 0x48e2b093 (4) Ensure DiamondLoupeFacet is added during initialization (5) Test interface detection with supportsInterface

ğŸ”¥ CRITICAL: Contract 'VulnerableBeaconProxy' fallback performs delegatecall without validating facet != address(0). When a function selector is not registered in selectorToFacet, it returns address(0). Delegatecall to address(0) succeeds silently in assembly, returning success=true without executing any code. This creates false success responses for non-existent functions, breaking contract behavior and potentially bypassing security checks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:156:10
   â”œâ”€ Detector: diamond-delegatecall-zero
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add facet validation in 'VulnerableBeaconProxy' fallback: (1) After loading facet address, add 'require(facet != address(0), "Function does not exist")' (2) Check BEFORE delegatecall, not after (3) Use revert with custom error for gas efficiency: 'error FunctionNotFound(bytes4 selector)' (4) Consider explicit fallback failure rather than silent success (5) Validate facet in both Solidity and assembly implementations

ğŸ”¥ CRITICAL: Contract 'VulnerableBeaconProxy' fallback delegates without verifying facet has code. Even if facet != address(0), the address may be an EOA or a self-destructed contract with no code. Delegatecall to addresses without code succeeds silently, returning success=true. This allows unregistered selectors to succeed unexpectedly, bypassing access controls and validation logic.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:156:10
   â”œâ”€ Detector: diamond-delegatecall-zero
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in 'VulnerableBeaconProxy': (1) Validate 'require(facet.code.length > 0, "Facet has no code")' (2) In assembly, use EXTCODESIZE: 'if iszero(extcodesize(facet)) { revert(0, 0) }' (3) Perform check immediately after loading facet address (4) Consider caching code validation during facet registration (5) Handle self-destructed facets gracefully

ğŸ”¥ CRITICAL: Contract 'VulnerableBeaconProxy' uses assembly delegatecall without proper validation. Assembly delegatecall bypasses Solidity's address validation, making it critical to manually check facet != 0 and extcodesize > 0. Missing validation in assembly is more dangerous because there are no implicit safety checks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:156:10
   â”œâ”€ Detector: diamond-delegatecall-zero
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add assembly validation in 'VulnerableBeaconProxy': (1) After loading facet: 'if iszero(facet) { revert(0, 0) }' (2) Check code size: 'if iszero(extcodesize(facet)) { revert(0, 0) }' (3) Place checks immediately before delegatecall opcode (4) Use consistent error handling (revert with error code) (5) Document assembly validation logic clearly

âš ï¸  HIGH: Contract 'VulnerableBeaconProxy' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:156:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

âš ï¸  HIGH: Function '' performs delegatecall in fallback/receive without access control. Fallback/receive function performs delegatecall without validating the caller. Any address can trigger this by calling a non-existent function or sending ETH. This allows any caller to execute arbitrary code by calling non-existent functions or sending ETH to the contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:176:5
   â”œâ”€ Detector: fallback-delegatecall-unprotected
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Add access control to fallback function ''. Validate implementation address before delegatecall. Use modifiers like 'onlyOwner' or check msg.sender explicitly. Consider using OpenZeppelin's transparent or UUPS proxy patterns.

âš¡ MEDIUM: Function 'upgradeBeacon' in proxy contract may shadow implementation. Function 'upgradeBeacon' may shadow implementation's function. In transparent proxies, use ifAdmin pattern to separate admin and user calls Real-world impact: Similar to issues in various proxy implementations where admin functions were shadowed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:164:14
   â”œâ”€ Detector: fallback-function-shadowing
   â””â”€ CWE: CWE-670

ğŸ”¥ CRITICAL: Implementation contract 'VulnerableBeaconProxy' has a constructor but does not call _disableInitializers(). The implementation contract can be initialized by an attacker.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:156:10
   â”œâ”€ Detector: implementation-not-initialized
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that calls _disableInitializers():

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This prevents the implementation contract from being initialized directly.

ğŸ”¥ CRITICAL: UUPS contract 'VulnerableBeaconProxy' does not call _disableInitializers() in constructor. An attacker can initialize the implementation contract directly and potentially call upgradeTo() to brick all proxies or take control.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:156:10
   â”œâ”€ Detector: uups-missing-disable-initializers
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that disables initializers:

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This is especially critical for UUPS contracts since the upgrade logic lives in the implementation.

ğŸ”¥ CRITICAL: Implementation contract 'VulnerableBeaconProxy' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableBeaconProxy' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableBeaconProxy' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableBeaconProxy' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

âš ï¸  HIGH: Implementation contract 'VulnerableBeaconProxy' has function 'changeAdmin' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'changeAdmin' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Implementation contract 'VulnerableBeaconProxy' has function 'implementation' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'implementation' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Transparent proxy 'VulnerableBeaconProxy': Setting admin to msg.sender in initializer - admin should be separate from users
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:410:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Ensure admin operations and user operations use separate addresses. The admin address can only call admin functions, not implementation functions.

âš ï¸  HIGH: Implementation contract 'VulnerableBeaconProxy': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableBeaconProxy': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableBeaconProxy': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableBeaconProxy': Function 'implementation()' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš¡ MEDIUM: Upgradeable contract 'VulnerableBeaconProxy' has 22 state variable(s) but no storage gap. Adding new state variables in future upgrades may corrupt storage layout of derived contracts.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:0
   â”œâ”€ Detector: missing-storage-gap
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Add a storage gap at the end of the contract to reserve slots for future use:

contract UpgradeableBase is Initializable {
uint256 public value;

// Reserve 50 slots for future storage variables
// Reduce this number when adding new state variables
uint256[50] private __gap;
}

When adding new state variables, reduce the gap size accordingly:
uint256 public newValue; // Added in upgrade
uint256[49] private __gap; // Reduced from 50 to 49

ğŸ”¥ CRITICAL: Contract 'VulnerableBeaconProxy' uses custom initialization tracking variable instead of OpenZeppelin's Initializable pattern. Custom tracking can be corrupted by storage collision during upgrades, allowing re-initialization attacks. This was the root cause of the AllianceBlock staking exploit in 2024.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:366:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Use OpenZeppelin's Initializable contract instead of custom tracking:

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract MyContract is Initializable {
function initialize() public initializer {
// initialization logic
}
}

ğŸ”¥ CRITICAL: Function 'initialize' in contract 'VulnerableBeaconProxy' uses a custom require check for initialization instead of OpenZeppelin's initializer modifier. This pattern is vulnerable to storage collision attacks during upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:375:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Replace custom require check with OpenZeppelin's initializer modifier:

function initialize() public initializer {
// initialization logic
}

ğŸ”¥ CRITICAL: Proxy contract 'VulnerableBeaconProxy' has state variable '' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

âš ï¸  HIGH: Beacon contract 'VulnerableBeaconProxy' allows immediate upgrades without a timelock. Malicious or accidental upgrades will immediately affect all proxy contracts using this beacon, with no time for users to react.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: beacon-single-point-of-failure
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add a timelock to beacon upgrades:

uint256 public constant UPGRADE_DELAY = 2 days;
address public pendingImplementation;
uint256 public upgradeTimestamp;

function proposeUpgrade(address newImpl) external onlyOwner {
pendingImplementation = newImpl;
upgradeTimestamp = block.timestamp + UPGRADE_DELAY;
}

function executeUpgrade() external {
require(block.timestamp >= upgradeTimestamp);
_upgradeTo(pendingImplementation);
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableBeaconProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableBeaconProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableBeaconProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableBeaconProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableBeaconProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableBeaconProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableBeaconProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableBeaconProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Fallback function in Diamond contract 'VulnerableBeaconProxy' performs delegatecall without checking facet code existence. This can cause silent failures for any call to the Diamond when the selected facet has been destroyed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in fallback:

fallback() external payable {
address facet = selectorToFacet[msg.sig];
require(facet != address(0), "Function not found");
require(facet.code.length > 0, "Facet destroyed");
// delegatecall...
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableBeaconProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableBeaconProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function '_authorizeUpgrade' in contract 'VulnerableBeaconProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:68:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableBeaconProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableBeaconProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeBeacon' in contract 'VulnerableBeaconProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:164:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'changeAdmin' in contract 'VulnerableBeaconProxy' changes admin without emitting AdminChanged event.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Emit AdminChanged event:

function _changeAdmin(address newAdmin) internal {
emit AdminChanged(_getAdmin(), newAdmin);
_setAdmin(newAdmin);
}

âš ï¸  HIGH: Contract 'VulnerableBeaconProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:6:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableBeaconProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableBeaconProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:44:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableBeaconProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableBeaconProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableBeaconProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableBeaconProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableBeaconProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableBeaconProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableBeaconProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableBeaconProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'VulnerableBeaconProxy' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:21:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'VulnerableBeaconProxy' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:22:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'VulnerableBeaconProxy' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:64:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'upgradeTo' in contract 'VulnerableBeaconProxy' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:33:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'upgradeToUnchecked' in contract 'VulnerableBeaconProxy' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'selfDestruct' in contract 'VulnerableBeaconProxy' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:418:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'selfDestruct' in contract 'VulnerableBeaconProxy' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'VulnerableBeaconProxy' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableBeaconProxy' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'clone' in contract 'VulnerableBeaconProxy' uses assembly create/create2. Ensure bytecode source is trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:304:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate assembly deployment:

1. Verify bytecode hash before create/create2
2. Use high-level new ContractName() when possible
3. Audit all sources of deployment bytecode

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableBeaconProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableBeaconProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:106:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableBeaconProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:134:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableBeaconProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:176:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableBeaconProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:237:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableBeaconProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:275:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableBeaconProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:329:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableBeaconProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:386:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableBeaconProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableBeaconProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableBeaconProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableBeaconProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:324:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Upgrade function 'upgradeTo' in contract 'VulnerableBeaconProxy' has weak protection. Owner-only upgrades without timelock allow rapid privilege changes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Strengthen upgrade protection:

1. Require timelock for upgrades
2. Use governance vote for implementation changes
3. Add upgrade delay period

Example:
function _authorizeUpgrade(address) internal override onlyTimelock {}

âš ï¸  HIGH: Function 'addFacet' in contract 'VulnerableBeaconProxy' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:224:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'addFacet' in contract 'VulnerableBeaconProxy' accepts unbounded array input. Large inputs can cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit input array size:

uint256 constant MAX_BATCH_SIZE = 100;

function processBatch(address[] calldata items) external {
require(
items.length <= MAX_BATCH_SIZE,
"Batch too large"
);
// ...
}

âš ï¸  HIGH: Function 'implementation' in contract 'VulnerableBeaconProxy' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš¡ MEDIUM: Address parameter 'newImplementation' in function 'upgrade' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:200:30
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(newImplementation != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter 'newImplementation' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:200:30
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(newImplementation != address(0), "Invalid address");

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

âš ï¸  HIGH: Function 'upgrade' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:200:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'upgrade'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

ğŸ”¥ CRITICAL: Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:5
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'upgrade' has upgradeable proxy vulnerability. Upgrade executes immediately without timelock delay, no time for users to exit before malicious upgrade Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:200:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'upgrade'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

âš ï¸  HIGH: Function 'upgrade' has centralization risk. Critical 'upgrade' function restricted to single owner without multi-sig or timelock. Single point of failure for critical operation Critical function controlled by single address creates attack vector.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:200:14
   â”œâ”€ Detector: centralization-risk
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Add decentralization to 'upgrade'. Implement multi-signature requirements, timelock delays, or DAO governance for this critical function.

âš¡ MEDIUM: Function 'upgrade' contains variable shadowing. Parameter 'owner' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:200:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'upgrade'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš ï¸  HIGH: Contract 'VulnerableBeacon' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:190:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

âš¡ MEDIUM: Function 'upgrade' in proxy contract may shadow implementation. Function 'upgrade' may shadow implementation's function. In transparent proxies, use ifAdmin pattern to separate admin and user calls Real-world impact: Similar to issues in various proxy implementations where admin functions were shadowed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:200:14
   â”œâ”€ Detector: fallback-function-shadowing
   â””â”€ CWE: CWE-670

ğŸ”¥ CRITICAL: Implementation contract 'VulnerableBeacon' has a constructor but does not call _disableInitializers(). The implementation contract can be initialized by an attacker.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:190:10
   â”œâ”€ Detector: implementation-not-initialized
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that calls _disableInitializers():

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This prevents the implementation contract from being initialized directly.

ğŸ”¥ CRITICAL: UUPS contract 'VulnerableBeacon' does not call _disableInitializers() in constructor. An attacker can initialize the implementation contract directly and potentially call upgradeTo() to brick all proxies or take control.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:190:10
   â”œâ”€ Detector: uups-missing-disable-initializers
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that disables initializers:

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This is especially critical for UUPS contracts since the upgrade logic lives in the implementation.

ğŸ”¥ CRITICAL: Implementation contract 'VulnerableBeacon' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableBeacon' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableBeacon' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableBeacon' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

âš ï¸  HIGH: Implementation contract 'VulnerableBeacon' has function 'changeAdmin' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'changeAdmin' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Implementation contract 'VulnerableBeacon' has function 'implementation' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'implementation' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Transparent proxy 'VulnerableBeacon': Setting admin to msg.sender in initializer - admin should be separate from users
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:410:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Ensure admin operations and user operations use separate addresses. The admin address can only call admin functions, not implementation functions.

âš ï¸  HIGH: Implementation contract 'VulnerableBeacon': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableBeacon': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableBeacon': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableBeacon': Function 'implementation()' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš¡ MEDIUM: Upgradeable contract 'VulnerableBeacon' has 22 state variable(s) but no storage gap. Adding new state variables in future upgrades may corrupt storage layout of derived contracts.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:0
   â”œâ”€ Detector: missing-storage-gap
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Add a storage gap at the end of the contract to reserve slots for future use:

contract UpgradeableBase is Initializable {
uint256 public value;

// Reserve 50 slots for future storage variables
// Reduce this number when adding new state variables
uint256[50] private __gap;
}

When adding new state variables, reduce the gap size accordingly:
uint256 public newValue; // Added in upgrade
uint256[49] private __gap; // Reduced from 50 to 49

ğŸ”¥ CRITICAL: Contract 'VulnerableBeacon' uses custom initialization tracking variable instead of OpenZeppelin's Initializable pattern. Custom tracking can be corrupted by storage collision during upgrades, allowing re-initialization attacks. This was the root cause of the AllianceBlock staking exploit in 2024.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:366:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Use OpenZeppelin's Initializable contract instead of custom tracking:

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract MyContract is Initializable {
function initialize() public initializer {
// initialization logic
}
}

ğŸ”¥ CRITICAL: Function 'initialize' in contract 'VulnerableBeacon' uses a custom require check for initialization instead of OpenZeppelin's initializer modifier. This pattern is vulnerable to storage collision attacks during upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:375:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Replace custom require check with OpenZeppelin's initializer modifier:

function initialize() public initializer {
// initialization logic
}

ğŸ”¥ CRITICAL: Proxy contract 'VulnerableBeacon' has state variable '' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

âš ï¸  HIGH: Beacon contract 'VulnerableBeacon' allows immediate upgrades without a timelock. Malicious or accidental upgrades will immediately affect all proxy contracts using this beacon, with no time for users to react.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: beacon-single-point-of-failure
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add a timelock to beacon upgrades:

uint256 public constant UPGRADE_DELAY = 2 days;
address public pendingImplementation;
uint256 public upgradeTimestamp;

function proposeUpgrade(address newImpl) external onlyOwner {
pendingImplementation = newImpl;
upgradeTimestamp = block.timestamp + UPGRADE_DELAY;
}

function executeUpgrade() external {
require(block.timestamp >= upgradeTimestamp);
_upgradeTo(pendingImplementation);
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableBeacon' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableBeacon' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableBeacon' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableBeacon' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableBeacon' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableBeacon' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableBeacon' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableBeacon' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Fallback function in Diamond contract 'VulnerableBeacon' performs delegatecall without checking facet code existence. This can cause silent failures for any call to the Diamond when the selected facet has been destroyed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in fallback:

fallback() external payable {
address facet = selectorToFacet[msg.sig];
require(facet != address(0), "Function not found");
require(facet.code.length > 0, "Facet destroyed");
// delegatecall...
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableBeacon' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableBeacon' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function '_authorizeUpgrade' in contract 'VulnerableBeacon' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:68:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableBeacon' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableBeacon' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeBeacon' in contract 'VulnerableBeacon' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:164:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'changeAdmin' in contract 'VulnerableBeacon' changes admin without emitting AdminChanged event.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Emit AdminChanged event:

function _changeAdmin(address newAdmin) internal {
emit AdminChanged(_getAdmin(), newAdmin);
_setAdmin(newAdmin);
}

âš ï¸  HIGH: Contract 'VulnerableBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:6:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:44:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableBeacon' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'VulnerableBeacon' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:21:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'VulnerableBeacon' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:22:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'VulnerableBeacon' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:64:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'upgradeTo' in contract 'VulnerableBeacon' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:33:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'upgradeToUnchecked' in contract 'VulnerableBeacon' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'selfDestruct' in contract 'VulnerableBeacon' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:418:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'selfDestruct' in contract 'VulnerableBeacon' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'VulnerableBeacon' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableBeacon' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'clone' in contract 'VulnerableBeacon' uses assembly create/create2. Ensure bytecode source is trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:304:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate assembly deployment:

1. Verify bytecode hash before create/create2
2. Use high-level new ContractName() when possible
3. Audit all sources of deployment bytecode

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableBeacon' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableBeacon' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:106:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableBeacon' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:134:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableBeacon' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:176:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableBeacon' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:237:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableBeacon' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:275:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableBeacon' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:329:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableBeacon' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:386:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableBeacon' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableBeacon' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableBeacon' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableBeacon' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:324:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Upgrade function 'upgradeTo' in contract 'VulnerableBeacon' has weak protection. Owner-only upgrades without timelock allow rapid privilege changes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Strengthen upgrade protection:

1. Require timelock for upgrades
2. Use governance vote for implementation changes
3. Add upgrade delay period

Example:
function _authorizeUpgrade(address) internal override onlyTimelock {}

âš ï¸  HIGH: Function 'addFacet' in contract 'VulnerableBeacon' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:224:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'addFacet' in contract 'VulnerableBeacon' accepts unbounded array input. Large inputs can cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit input array size:

uint256 constant MAX_BATCH_SIZE = 100;

function processBatch(address[] calldata items) external {
require(
items.length <= MAX_BATCH_SIZE,
"Batch too large"
);
// ...
}

âš ï¸  HIGH: Function 'implementation' in contract 'VulnerableBeacon' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

ğŸ”¥ CRITICAL: Function 'addFacet' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'addFacet'

âš¡ MEDIUM: Address parameter 'facetAddress' in function 'addFacet' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:31
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(facetAddress != address(0), "Zero address not allowed");

âš¡ MEDIUM: Address parameter 'newFacet' in function 'replaceFacet' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:230:52
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(newFacet != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter 'facetAddress' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:31
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(facetAddress != address(0), "Invalid address");

âš¡ MEDIUM: Parameter 'selectors' of type 'array' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:61
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(selectors.length > 0, "Array cannot be empty");

ğŸ“ LOW: Parameter 'newFacet' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:230:52
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(newFacet != address(0), "Invalid address");

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

ğŸ”¥ CRITICAL: Function '' uses delegatecall which can cause storage collision. Delegatecall with storage collision vulnerability marker detected Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:237:5
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in ''. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function '' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:237:5
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in ''. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

âš ï¸  HIGH: Function 'replaceFacet' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:230:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'replaceFacet'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function '' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:237:5
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in ''. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš ï¸  HIGH: Function 'addFacet' has DOS vulnerability via unbounded operation. Loop over unbounded array without iteration limit, large arrays cause out-of-gas Can cause out-of-gas errors blocking contract functionality.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:14
   â”œâ”€ Detector: dos-unbounded-operation
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Fix unbounded operation in 'addFacet'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.

ğŸ“ LOW: Function 'addFacet' contains excessive gas usage pattern. Storage write operation inside loop. Consider using memory array Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'addFacet'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Function 'addFacet' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'addFacet'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

âš¡ MEDIUM: Function 'replaceFacet' contains variable shadowing. Parameter 'owner' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:230:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'replaceFacet'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Function '' contains variable shadowing. Parameter 'facet' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:237:5
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in ''. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Function '' contains variable shadowing. Local variable 'facet' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:237:5
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in ''. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Contract 'VulnerableDiamondProxy' is a Diamond proxy but missing required ERC-2535 Loupe functions: facets(), facetFunctionSelectors(address), facetAddresses(), facetAddress(bytes4). The Diamond Loupe standard defines 4 introspection functions that enable tools, users, and contracts to discover which facets and functions a Diamond implements. Without these, the Diamond becomes a black box, hindering integration, debugging, and security auditing.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:212:10
   â”œâ”€ Detector: diamond-loupe-violation
   â”œâ”€ CWE: CWE-573
   â””â”€ Fix: Implement missing Loupe functions in 'VulnerableDiamondProxy': (1) facets() returning Facet[] array with address and selectors for each facet (2) facetFunctionSelectors(address _facet) returning bytes4[] of selectors for a facet (3) facetAddresses() returning address[] of all facet addresses (4) facetAddress(bytes4 _selector) returning address of facet for a selector (5) Implement IDiamondLoupe interface and add to supportsInterface

âš¡ MEDIUM: Contract 'VulnerableDiamondProxy' implements loupe functions but doesn't declare IDiamondLoupe interface support. The ERC-2535 standard requires supportsInterface(0x48e2b093) to return true for IDiamondLoupe. Without proper interface support, tools cannot reliably detect Diamond Loupe compliance.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:212:10
   â”œâ”€ Detector: diamond-loupe-violation
   â”œâ”€ CWE: CWE-573
   â””â”€ Fix: Add interface support to 'VulnerableDiamondProxy': (1) Import 'import "@openzeppelin/contracts/utils/introspection/IERC165.sol"' (2) Implement supportsInterface: 'return interfaceId == type(IDiamondLoupe).interfaceId || interfaceId == type(IERC165).interfaceId' (3) IDiamondLoupe interface ID is 0x48e2b093 (4) Ensure DiamondLoupeFacet is added during initialization (5) Test interface detection with supportsInterface

âš ï¸  HIGH: Contract 'VulnerableDiamondProxy' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:212:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

âš ï¸  HIGH: Function '' performs delegatecall in fallback/receive without access control. Fallback/receive function performs delegatecall without validating the caller. Any address can trigger this by calling a non-existent function or sending ETH. This allows any caller to execute arbitrary code by calling non-existent functions or sending ETH to the contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:237:5
   â”œâ”€ Detector: fallback-delegatecall-unprotected
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Add access control to fallback function ''. Validate implementation address before delegatecall. Use modifiers like 'onlyOwner' or check msg.sender explicitly. Consider using OpenZeppelin's transparent or UUPS proxy patterns.

ğŸ”¥ CRITICAL: Implementation contract 'VulnerableDiamondProxy' has a constructor but does not call _disableInitializers(). The implementation contract can be initialized by an attacker.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:212:10
   â”œâ”€ Detector: implementation-not-initialized
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that calls _disableInitializers():

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This prevents the implementation contract from being initialized directly.

ğŸ”¥ CRITICAL: UUPS contract 'VulnerableDiamondProxy' does not call _disableInitializers() in constructor. An attacker can initialize the implementation contract directly and potentially call upgradeTo() to brick all proxies or take control.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:212:10
   â”œâ”€ Detector: uups-missing-disable-initializers
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that disables initializers:

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This is especially critical for UUPS contracts since the upgrade logic lives in the implementation.

ğŸ”¥ CRITICAL: Implementation contract 'VulnerableDiamondProxy' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableDiamondProxy' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableDiamondProxy' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableDiamondProxy' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

âš ï¸  HIGH: Implementation contract 'VulnerableDiamondProxy' has function 'changeAdmin' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'changeAdmin' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Implementation contract 'VulnerableDiamondProxy' has function 'implementation' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'implementation' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Transparent proxy 'VulnerableDiamondProxy': Setting admin to msg.sender in initializer - admin should be separate from users
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:410:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Ensure admin operations and user operations use separate addresses. The admin address can only call admin functions, not implementation functions.

âš ï¸  HIGH: Implementation contract 'VulnerableDiamondProxy': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableDiamondProxy': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableDiamondProxy': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableDiamondProxy': Function 'implementation()' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš¡ MEDIUM: Upgradeable contract 'VulnerableDiamondProxy' has 22 state variable(s) but no storage gap. Adding new state variables in future upgrades may corrupt storage layout of derived contracts.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:0
   â”œâ”€ Detector: missing-storage-gap
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Add a storage gap at the end of the contract to reserve slots for future use:

contract UpgradeableBase is Initializable {
uint256 public value;

// Reserve 50 slots for future storage variables
// Reduce this number when adding new state variables
uint256[50] private __gap;
}

When adding new state variables, reduce the gap size accordingly:
uint256 public newValue; // Added in upgrade
uint256[49] private __gap; // Reduced from 50 to 49

ğŸ”¥ CRITICAL: Contract 'VulnerableDiamondProxy' uses custom initialization tracking variable instead of OpenZeppelin's Initializable pattern. Custom tracking can be corrupted by storage collision during upgrades, allowing re-initialization attacks. This was the root cause of the AllianceBlock staking exploit in 2024.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:366:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Use OpenZeppelin's Initializable contract instead of custom tracking:

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract MyContract is Initializable {
function initialize() public initializer {
// initialization logic
}
}

ğŸ”¥ CRITICAL: Function 'initialize' in contract 'VulnerableDiamondProxy' uses a custom require check for initialization instead of OpenZeppelin's initializer modifier. This pattern is vulnerable to storage collision attacks during upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:375:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Replace custom require check with OpenZeppelin's initializer modifier:

function initialize() public initializer {
// initialization logic
}

ğŸ”¥ CRITICAL: Proxy contract 'VulnerableDiamondProxy' has state variable '' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

âš ï¸  HIGH: Beacon contract 'VulnerableDiamondProxy' allows immediate upgrades without a timelock. Malicious or accidental upgrades will immediately affect all proxy contracts using this beacon, with no time for users to react.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: beacon-single-point-of-failure
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add a timelock to beacon upgrades:

uint256 public constant UPGRADE_DELAY = 2 days;
address public pendingImplementation;
uint256 public upgradeTimestamp;

function proposeUpgrade(address newImpl) external onlyOwner {
pendingImplementation = newImpl;
upgradeTimestamp = block.timestamp + UPGRADE_DELAY;
}

function executeUpgrade() external {
require(block.timestamp >= upgradeTimestamp);
_upgradeTo(pendingImplementation);
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableDiamondProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableDiamondProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableDiamondProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableDiamondProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableDiamondProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableDiamondProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableDiamondProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableDiamondProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Fallback function in Diamond contract 'VulnerableDiamondProxy' performs delegatecall without checking facet code existence. This can cause silent failures for any call to the Diamond when the selected facet has been destroyed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in fallback:

fallback() external payable {
address facet = selectorToFacet[msg.sig];
require(facet != address(0), "Function not found");
require(facet.code.length > 0, "Facet destroyed");
// delegatecall...
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableDiamondProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableDiamondProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function '_authorizeUpgrade' in contract 'VulnerableDiamondProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:68:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableDiamondProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableDiamondProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeBeacon' in contract 'VulnerableDiamondProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:164:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'changeAdmin' in contract 'VulnerableDiamondProxy' changes admin without emitting AdminChanged event.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Emit AdminChanged event:

function _changeAdmin(address newAdmin) internal {
emit AdminChanged(_getAdmin(), newAdmin);
_setAdmin(newAdmin);
}

âš ï¸  HIGH: Contract 'VulnerableDiamondProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:6:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableDiamondProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableDiamondProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:44:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableDiamondProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableDiamondProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableDiamondProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableDiamondProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableDiamondProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableDiamondProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableDiamondProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableDiamondProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'VulnerableDiamondProxy' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:21:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'VulnerableDiamondProxy' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:22:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'VulnerableDiamondProxy' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:64:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'upgradeTo' in contract 'VulnerableDiamondProxy' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:33:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'upgradeToUnchecked' in contract 'VulnerableDiamondProxy' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'selfDestruct' in contract 'VulnerableDiamondProxy' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:418:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'selfDestruct' in contract 'VulnerableDiamondProxy' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'VulnerableDiamondProxy' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableDiamondProxy' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'clone' in contract 'VulnerableDiamondProxy' uses assembly create/create2. Ensure bytecode source is trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:304:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate assembly deployment:

1. Verify bytecode hash before create/create2
2. Use high-level new ContractName() when possible
3. Audit all sources of deployment bytecode

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableDiamondProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableDiamondProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:106:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableDiamondProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:134:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableDiamondProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:176:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableDiamondProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:237:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableDiamondProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:275:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableDiamondProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:329:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableDiamondProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:386:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableDiamondProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableDiamondProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableDiamondProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableDiamondProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:324:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Upgrade function 'upgradeTo' in contract 'VulnerableDiamondProxy' has weak protection. Owner-only upgrades without timelock allow rapid privilege changes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Strengthen upgrade protection:

1. Require timelock for upgrades
2. Use governance vote for implementation changes
3. Add upgrade delay period

Example:
function _authorizeUpgrade(address) internal override onlyTimelock {}

âš ï¸  HIGH: Function 'addFacet' in contract 'VulnerableDiamondProxy' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:224:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'addFacet' in contract 'VulnerableDiamondProxy' accepts unbounded array input. Large inputs can cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit input array size:

uint256 constant MAX_BATCH_SIZE = 100;

function processBatch(address[] calldata items) external {
require(
items.length <= MAX_BATCH_SIZE,
"Batch too large"
);
// ...
}

âš ï¸  HIGH: Function 'implementation' in contract 'VulnerableDiamondProxy' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:259:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

âš ï¸  HIGH: Contract 'VulnerableDiamondFacet' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:254:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

ğŸ”¥ CRITICAL: Implementation contract 'VulnerableDiamondFacet' has a constructor but does not call _disableInitializers(). The implementation contract can be initialized by an attacker.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:254:10
   â”œâ”€ Detector: implementation-not-initialized
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that calls _disableInitializers():

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This prevents the implementation contract from being initialized directly.

ğŸ”¥ CRITICAL: UUPS contract 'VulnerableDiamondFacet' does not call _disableInitializers() in constructor. An attacker can initialize the implementation contract directly and potentially call upgradeTo() to brick all proxies or take control.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:254:10
   â”œâ”€ Detector: uups-missing-disable-initializers
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that disables initializers:

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This is especially critical for UUPS contracts since the upgrade logic lives in the implementation.

ğŸ”¥ CRITICAL: Implementation contract 'VulnerableDiamondFacet' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableDiamondFacet' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableDiamondFacet' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableDiamondFacet' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

âš ï¸  HIGH: Implementation contract 'VulnerableDiamondFacet' has function 'changeAdmin' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'changeAdmin' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Implementation contract 'VulnerableDiamondFacet' has function 'implementation' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'implementation' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Transparent proxy 'VulnerableDiamondFacet': Setting admin to msg.sender in initializer - admin should be separate from users
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:410:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Ensure admin operations and user operations use separate addresses. The admin address can only call admin functions, not implementation functions.

âš ï¸  HIGH: Implementation contract 'VulnerableDiamondFacet': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableDiamondFacet': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableDiamondFacet': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableDiamondFacet': Function 'implementation()' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš¡ MEDIUM: Upgradeable contract 'VulnerableDiamondFacet' has 22 state variable(s) but no storage gap. Adding new state variables in future upgrades may corrupt storage layout of derived contracts.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:0
   â”œâ”€ Detector: missing-storage-gap
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Add a storage gap at the end of the contract to reserve slots for future use:

contract UpgradeableBase is Initializable {
uint256 public value;

// Reserve 50 slots for future storage variables
// Reduce this number when adding new state variables
uint256[50] private __gap;
}

When adding new state variables, reduce the gap size accordingly:
uint256 public newValue; // Added in upgrade
uint256[49] private __gap; // Reduced from 50 to 49

ğŸ”¥ CRITICAL: Contract 'VulnerableDiamondFacet' uses custom initialization tracking variable instead of OpenZeppelin's Initializable pattern. Custom tracking can be corrupted by storage collision during upgrades, allowing re-initialization attacks. This was the root cause of the AllianceBlock staking exploit in 2024.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:366:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Use OpenZeppelin's Initializable contract instead of custom tracking:

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract MyContract is Initializable {
function initialize() public initializer {
// initialization logic
}
}

ğŸ”¥ CRITICAL: Function 'initialize' in contract 'VulnerableDiamondFacet' uses a custom require check for initialization instead of OpenZeppelin's initializer modifier. This pattern is vulnerable to storage collision attacks during upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:375:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Replace custom require check with OpenZeppelin's initializer modifier:

function initialize() public initializer {
// initialization logic
}

ğŸ”¥ CRITICAL: Proxy contract 'VulnerableDiamondFacet' has state variable '' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

âš ï¸  HIGH: Beacon contract 'VulnerableDiamondFacet' allows immediate upgrades without a timelock. Malicious or accidental upgrades will immediately affect all proxy contracts using this beacon, with no time for users to react.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: beacon-single-point-of-failure
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add a timelock to beacon upgrades:

uint256 public constant UPGRADE_DELAY = 2 days;
address public pendingImplementation;
uint256 public upgradeTimestamp;

function proposeUpgrade(address newImpl) external onlyOwner {
pendingImplementation = newImpl;
upgradeTimestamp = block.timestamp + UPGRADE_DELAY;
}

function executeUpgrade() external {
require(block.timestamp >= upgradeTimestamp);
_upgradeTo(pendingImplementation);
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableDiamondFacet' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableDiamondFacet' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableDiamondFacet' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableDiamondFacet' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableDiamondFacet' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableDiamondFacet' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableDiamondFacet' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableDiamondFacet' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Fallback function in Diamond contract 'VulnerableDiamondFacet' performs delegatecall without checking facet code existence. This can cause silent failures for any call to the Diamond when the selected facet has been destroyed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in fallback:

fallback() external payable {
address facet = selectorToFacet[msg.sig];
require(facet != address(0), "Function not found");
require(facet.code.length > 0, "Facet destroyed");
// delegatecall...
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableDiamondFacet' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableDiamondFacet' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function '_authorizeUpgrade' in contract 'VulnerableDiamondFacet' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:68:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableDiamondFacet' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableDiamondFacet' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeBeacon' in contract 'VulnerableDiamondFacet' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:164:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'changeAdmin' in contract 'VulnerableDiamondFacet' changes admin without emitting AdminChanged event.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Emit AdminChanged event:

function _changeAdmin(address newAdmin) internal {
emit AdminChanged(_getAdmin(), newAdmin);
_setAdmin(newAdmin);
}

âš ï¸  HIGH: Contract 'VulnerableDiamondFacet' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:6:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableDiamondFacet' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableDiamondFacet' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:44:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableDiamondFacet' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableDiamondFacet' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableDiamondFacet' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableDiamondFacet' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableDiamondFacet' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableDiamondFacet' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableDiamondFacet' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableDiamondFacet' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'VulnerableDiamondFacet' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:21:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'VulnerableDiamondFacet' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:22:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'VulnerableDiamondFacet' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:64:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'upgradeTo' in contract 'VulnerableDiamondFacet' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:33:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'upgradeToUnchecked' in contract 'VulnerableDiamondFacet' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'selfDestruct' in contract 'VulnerableDiamondFacet' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:418:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'selfDestruct' in contract 'VulnerableDiamondFacet' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'VulnerableDiamondFacet' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableDiamondFacet' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'clone' in contract 'VulnerableDiamondFacet' uses assembly create/create2. Ensure bytecode source is trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:304:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate assembly deployment:

1. Verify bytecode hash before create/create2
2. Use high-level new ContractName() when possible
3. Audit all sources of deployment bytecode

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableDiamondFacet' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableDiamondFacet' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:106:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableDiamondFacet' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:134:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableDiamondFacet' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:176:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableDiamondFacet' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:237:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableDiamondFacet' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:275:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableDiamondFacet' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:329:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableDiamondFacet' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:386:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableDiamondFacet' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableDiamondFacet' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableDiamondFacet' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableDiamondFacet' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:324:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Upgrade function 'upgradeTo' in contract 'VulnerableDiamondFacet' has weak protection. Owner-only upgrades without timelock allow rapid privilege changes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Strengthen upgrade protection:

1. Require timelock for upgrades
2. Use governance vote for implementation changes
3. Add upgrade delay period

Example:
function _authorizeUpgrade(address) internal override onlyTimelock {}

âš ï¸  HIGH: Function 'addFacet' in contract 'VulnerableDiamondFacet' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:224:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'addFacet' in contract 'VulnerableDiamondFacet' accepts unbounded array input. Large inputs can cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit input array size:

uint256 constant MAX_BATCH_SIZE = 100;

function processBatch(address[] calldata items) external {
require(
items.length <= MAX_BATCH_SIZE,
"Batch too large"
);
// ...
}

âš ï¸  HIGH: Function 'implementation' in contract 'VulnerableDiamondFacet' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:275:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

ğŸ”¥ CRITICAL: Function '' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:275:5
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in ''. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function '' has upgradeable proxy vulnerability. Delegatecall without validating implementation address, can delegate to non-contract or malicious code Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:275:5
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

âš ï¸  HIGH: Function '' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:275:5
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in ''. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš¡ MEDIUM: Function '' contains variable shadowing. Local variable 'facet' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:275:5
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in ''. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Contract 'DiamondWithoutStoragePattern' is a Diamond proxy but missing required ERC-2535 Loupe functions: facets(), facetFunctionSelectors(address), facetAddresses(), facetAddress(bytes4). The Diamond Loupe standard defines 4 introspection functions that enable tools, users, and contracts to discover which facets and functions a Diamond implements. Without these, the Diamond becomes a black box, hindering integration, debugging, and security auditing.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:267:10
   â”œâ”€ Detector: diamond-loupe-violation
   â”œâ”€ CWE: CWE-573
   â””â”€ Fix: Implement missing Loupe functions in 'DiamondWithoutStoragePattern': (1) facets() returning Facet[] array with address and selectors for each facet (2) facetFunctionSelectors(address _facet) returning bytes4[] of selectors for a facet (3) facetAddresses() returning address[] of all facet addresses (4) facetAddress(bytes4 _selector) returning address of facet for a selector (5) Implement IDiamondLoupe interface and add to supportsInterface

âš¡ MEDIUM: Contract 'DiamondWithoutStoragePattern' implements loupe functions but doesn't declare IDiamondLoupe interface support. The ERC-2535 standard requires supportsInterface(0x48e2b093) to return true for IDiamondLoupe. Without proper interface support, tools cannot reliably detect Diamond Loupe compliance.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:267:10
   â”œâ”€ Detector: diamond-loupe-violation
   â”œâ”€ CWE: CWE-573
   â””â”€ Fix: Add interface support to 'DiamondWithoutStoragePattern': (1) Import 'import "@openzeppelin/contracts/utils/introspection/IERC165.sol"' (2) Implement supportsInterface: 'return interfaceId == type(IDiamondLoupe).interfaceId || interfaceId == type(IERC165).interfaceId' (3) IDiamondLoupe interface ID is 0x48e2b093 (4) Ensure DiamondLoupeFacet is added during initialization (5) Test interface detection with supportsInterface

ğŸ”¥ CRITICAL: Contract 'DiamondWithoutStoragePattern' fallback performs delegatecall without validating facet != address(0). When a function selector is not registered in selectorToFacet, it returns address(0). Delegatecall to address(0) succeeds silently in assembly, returning success=true without executing any code. This creates false success responses for non-existent functions, breaking contract behavior and potentially bypassing security checks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:267:10
   â”œâ”€ Detector: diamond-delegatecall-zero
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add facet validation in 'DiamondWithoutStoragePattern' fallback: (1) After loading facet address, add 'require(facet != address(0), "Function does not exist")' (2) Check BEFORE delegatecall, not after (3) Use revert with custom error for gas efficiency: 'error FunctionNotFound(bytes4 selector)' (4) Consider explicit fallback failure rather than silent success (5) Validate facet in both Solidity and assembly implementations

ğŸ”¥ CRITICAL: Contract 'DiamondWithoutStoragePattern' fallback delegates without verifying facet has code. Even if facet != address(0), the address may be an EOA or a self-destructed contract with no code. Delegatecall to addresses without code succeeds silently, returning success=true. This allows unregistered selectors to succeed unexpectedly, bypassing access controls and validation logic.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:267:10
   â”œâ”€ Detector: diamond-delegatecall-zero
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in 'DiamondWithoutStoragePattern': (1) Validate 'require(facet.code.length > 0, "Facet has no code")' (2) In assembly, use EXTCODESIZE: 'if iszero(extcodesize(facet)) { revert(0, 0) }' (3) Perform check immediately after loading facet address (4) Consider caching code validation during facet registration (5) Handle self-destructed facets gracefully

ğŸ”¥ CRITICAL: Contract 'DiamondWithoutStoragePattern' uses assembly delegatecall without proper validation. Assembly delegatecall bypasses Solidity's address validation, making it critical to manually check facet != 0 and extcodesize > 0. Missing validation in assembly is more dangerous because there are no implicit safety checks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:267:10
   â”œâ”€ Detector: diamond-delegatecall-zero
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add assembly validation in 'DiamondWithoutStoragePattern': (1) After loading facet: 'if iszero(facet) { revert(0, 0) }' (2) Check code size: 'if iszero(extcodesize(facet)) { revert(0, 0) }' (3) Place checks immediately before delegatecall opcode (4) Use consistent error handling (revert with error code) (5) Document assembly validation logic clearly

âš ï¸  HIGH: Contract 'DiamondWithoutStoragePattern' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:267:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

âš ï¸  HIGH: Function '' performs delegatecall in fallback/receive without access control. Fallback/receive function performs delegatecall without validating the caller. Any address can trigger this by calling a non-existent function or sending ETH. This allows any caller to execute arbitrary code by calling non-existent functions or sending ETH to the contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:275:5
   â”œâ”€ Detector: fallback-delegatecall-unprotected
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Add access control to fallback function ''. Validate implementation address before delegatecall. Use modifiers like 'onlyOwner' or check msg.sender explicitly. Consider using OpenZeppelin's transparent or UUPS proxy patterns.

ğŸ”¥ CRITICAL: Implementation contract 'DiamondWithoutStoragePattern' has a constructor but does not call _disableInitializers(). The implementation contract can be initialized by an attacker.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:267:10
   â”œâ”€ Detector: implementation-not-initialized
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that calls _disableInitializers():

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This prevents the implementation contract from being initialized directly.

ğŸ”¥ CRITICAL: UUPS contract 'DiamondWithoutStoragePattern' does not call _disableInitializers() in constructor. An attacker can initialize the implementation contract directly and potentially call upgradeTo() to brick all proxies or take control.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:267:10
   â”œâ”€ Detector: uups-missing-disable-initializers
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that disables initializers:

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This is especially critical for UUPS contracts since the upgrade logic lives in the implementation.

ğŸ”¥ CRITICAL: Implementation contract 'DiamondWithoutStoragePattern' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Beacon contract 'DiamondWithoutStoragePattern' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'DiamondWithoutStoragePattern' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'DiamondWithoutStoragePattern' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

âš ï¸  HIGH: Implementation contract 'DiamondWithoutStoragePattern' has function 'changeAdmin' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'changeAdmin' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Implementation contract 'DiamondWithoutStoragePattern' has function 'implementation' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'implementation' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Transparent proxy 'DiamondWithoutStoragePattern': Setting admin to msg.sender in initializer - admin should be separate from users
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:410:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Ensure admin operations and user operations use separate addresses. The admin address can only call admin functions, not implementation functions.

âš ï¸  HIGH: Implementation contract 'DiamondWithoutStoragePattern': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'DiamondWithoutStoragePattern': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'DiamondWithoutStoragePattern': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'DiamondWithoutStoragePattern': Function 'implementation()' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš¡ MEDIUM: Upgradeable contract 'DiamondWithoutStoragePattern' has 22 state variable(s) but no storage gap. Adding new state variables in future upgrades may corrupt storage layout of derived contracts.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:0
   â”œâ”€ Detector: missing-storage-gap
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Add a storage gap at the end of the contract to reserve slots for future use:

contract UpgradeableBase is Initializable {
uint256 public value;

// Reserve 50 slots for future storage variables
// Reduce this number when adding new state variables
uint256[50] private __gap;
}

When adding new state variables, reduce the gap size accordingly:
uint256 public newValue; // Added in upgrade
uint256[49] private __gap; // Reduced from 50 to 49

ğŸ”¥ CRITICAL: Contract 'DiamondWithoutStoragePattern' uses custom initialization tracking variable instead of OpenZeppelin's Initializable pattern. Custom tracking can be corrupted by storage collision during upgrades, allowing re-initialization attacks. This was the root cause of the AllianceBlock staking exploit in 2024.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:366:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Use OpenZeppelin's Initializable contract instead of custom tracking:

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract MyContract is Initializable {
function initialize() public initializer {
// initialization logic
}
}

ğŸ”¥ CRITICAL: Function 'initialize' in contract 'DiamondWithoutStoragePattern' uses a custom require check for initialization instead of OpenZeppelin's initializer modifier. This pattern is vulnerable to storage collision attacks during upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:375:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Replace custom require check with OpenZeppelin's initializer modifier:

function initialize() public initializer {
// initialization logic
}

ğŸ”¥ CRITICAL: Proxy contract 'DiamondWithoutStoragePattern' has state variable '' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

âš ï¸  HIGH: Beacon contract 'DiamondWithoutStoragePattern' allows immediate upgrades without a timelock. Malicious or accidental upgrades will immediately affect all proxy contracts using this beacon, with no time for users to react.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: beacon-single-point-of-failure
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add a timelock to beacon upgrades:

uint256 public constant UPGRADE_DELAY = 2 days;
address public pendingImplementation;
uint256 public upgradeTimestamp;

function proposeUpgrade(address newImpl) external onlyOwner {
pendingImplementation = newImpl;
upgradeTimestamp = block.timestamp + UPGRADE_DELAY;
}

function executeUpgrade() external {
require(block.timestamp >= upgradeTimestamp);
_upgradeTo(pendingImplementation);
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'DiamondWithoutStoragePattern' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'DiamondWithoutStoragePattern' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'DiamondWithoutStoragePattern' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'DiamondWithoutStoragePattern' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'DiamondWithoutStoragePattern' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'DiamondWithoutStoragePattern' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'DiamondWithoutStoragePattern' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'DiamondWithoutStoragePattern' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Fallback function in Diamond contract 'DiamondWithoutStoragePattern' performs delegatecall without checking facet code existence. This can cause silent failures for any call to the Diamond when the selected facet has been destroyed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in fallback:

fallback() external payable {
address facet = selectorToFacet[msg.sig];
require(facet != address(0), "Function not found");
require(facet.code.length > 0, "Facet destroyed");
// delegatecall...
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'DiamondWithoutStoragePattern' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'DiamondWithoutStoragePattern' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function '_authorizeUpgrade' in contract 'DiamondWithoutStoragePattern' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:68:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'DiamondWithoutStoragePattern' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'DiamondWithoutStoragePattern' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeBeacon' in contract 'DiamondWithoutStoragePattern' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:164:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'changeAdmin' in contract 'DiamondWithoutStoragePattern' changes admin without emitting AdminChanged event.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Emit AdminChanged event:

function _changeAdmin(address newAdmin) internal {
emit AdminChanged(_getAdmin(), newAdmin);
_setAdmin(newAdmin);
}

âš ï¸  HIGH: Contract 'DiamondWithoutStoragePattern' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:6:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'DiamondWithoutStoragePattern' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'DiamondWithoutStoragePattern' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:44:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'DiamondWithoutStoragePattern' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'DiamondWithoutStoragePattern' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'DiamondWithoutStoragePattern' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'DiamondWithoutStoragePattern' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'DiamondWithoutStoragePattern' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'DiamondWithoutStoragePattern' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'DiamondWithoutStoragePattern' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'DiamondWithoutStoragePattern' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'DiamondWithoutStoragePattern' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:21:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'DiamondWithoutStoragePattern' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:22:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'DiamondWithoutStoragePattern' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:64:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'upgradeTo' in contract 'DiamondWithoutStoragePattern' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:33:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'upgradeToUnchecked' in contract 'DiamondWithoutStoragePattern' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'selfDestruct' in contract 'DiamondWithoutStoragePattern' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:418:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'selfDestruct' in contract 'DiamondWithoutStoragePattern' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'DiamondWithoutStoragePattern' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'DiamondWithoutStoragePattern' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'clone' in contract 'DiamondWithoutStoragePattern' uses assembly create/create2. Ensure bytecode source is trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:304:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate assembly deployment:

1. Verify bytecode hash before create/create2
2. Use high-level new ContractName() when possible
3. Audit all sources of deployment bytecode

ğŸ”¥ CRITICAL: Proxy fallback in contract 'DiamondWithoutStoragePattern' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'DiamondWithoutStoragePattern' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:106:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'DiamondWithoutStoragePattern' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:134:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'DiamondWithoutStoragePattern' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:176:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'DiamondWithoutStoragePattern' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:237:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'DiamondWithoutStoragePattern' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:275:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'DiamondWithoutStoragePattern' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:329:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'DiamondWithoutStoragePattern' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:386:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'DiamondWithoutStoragePattern' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'DiamondWithoutStoragePattern' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'DiamondWithoutStoragePattern' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'DiamondWithoutStoragePattern' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:324:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Upgrade function 'upgradeTo' in contract 'DiamondWithoutStoragePattern' has weak protection. Owner-only upgrades without timelock allow rapid privilege changes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Strengthen upgrade protection:

1. Require timelock for upgrades
2. Use governance vote for implementation changes
3. Add upgrade delay period

Example:
function _authorizeUpgrade(address) internal override onlyTimelock {}

âš ï¸  HIGH: Function 'addFacet' in contract 'DiamondWithoutStoragePattern' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:224:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'addFacet' in contract 'DiamondWithoutStoragePattern' accepts unbounded array input. Large inputs can cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit input array size:

uint256 constant MAX_BATCH_SIZE = 100;

function processBatch(address[] calldata items) external {
require(
items.length <= MAX_BATCH_SIZE,
"Batch too large"
);
// ...
}

âš ï¸  HIGH: Function 'implementation' in contract 'DiamondWithoutStoragePattern' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

ğŸ”¥ CRITICAL: Function 'createClone' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:309:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'createClone'

âš¡ MEDIUM: Address parameter '_implementation' in function 'clone' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:296:28
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_implementation != address(0), "Zero address not allowed");

âš ï¸  HIGH: Address parameter 'target' in function 'createClone' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:309:34
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(target != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter '_implementation' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:296:28
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_implementation != address(0), "Invalid address");

ğŸ“ LOW: Parameter 'target' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:309:34
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(target != address(0), "Invalid address");

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:296:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

ğŸ”¥ CRITICAL: Function 'clone' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:296:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'clone'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

âš ï¸  HIGH: Contract 'VulnerableMinimalProxy' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:292:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

ğŸ”¥ CRITICAL: Implementation contract 'VulnerableMinimalProxy' has a constructor but does not call _disableInitializers(). The implementation contract can be initialized by an attacker.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:292:10
   â”œâ”€ Detector: implementation-not-initialized
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that calls _disableInitializers():

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This prevents the implementation contract from being initialized directly.

ğŸ”¥ CRITICAL: UUPS contract 'VulnerableMinimalProxy' does not call _disableInitializers() in constructor. An attacker can initialize the implementation contract directly and potentially call upgradeTo() to brick all proxies or take control.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:292:10
   â”œâ”€ Detector: uups-missing-disable-initializers
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that disables initializers:

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This is especially critical for UUPS contracts since the upgrade logic lives in the implementation.

ğŸ”¥ CRITICAL: Implementation contract 'VulnerableMinimalProxy' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableMinimalProxy' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableMinimalProxy' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableMinimalProxy' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

âš ï¸  HIGH: Implementation contract 'VulnerableMinimalProxy' has function 'changeAdmin' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'changeAdmin' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Implementation contract 'VulnerableMinimalProxy' has function 'implementation' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'implementation' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Transparent proxy 'VulnerableMinimalProxy': Setting admin to msg.sender in initializer - admin should be separate from users
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:410:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Ensure admin operations and user operations use separate addresses. The admin address can only call admin functions, not implementation functions.

âš ï¸  HIGH: Implementation contract 'VulnerableMinimalProxy': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableMinimalProxy': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableMinimalProxy': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableMinimalProxy': Function 'implementation()' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš¡ MEDIUM: Upgradeable contract 'VulnerableMinimalProxy' has 22 state variable(s) but no storage gap. Adding new state variables in future upgrades may corrupt storage layout of derived contracts.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:0
   â”œâ”€ Detector: missing-storage-gap
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Add a storage gap at the end of the contract to reserve slots for future use:

contract UpgradeableBase is Initializable {
uint256 public value;

// Reserve 50 slots for future storage variables
// Reduce this number when adding new state variables
uint256[50] private __gap;
}

When adding new state variables, reduce the gap size accordingly:
uint256 public newValue; // Added in upgrade
uint256[49] private __gap; // Reduced from 50 to 49

ğŸ”¥ CRITICAL: Contract 'VulnerableMinimalProxy' uses custom initialization tracking variable instead of OpenZeppelin's Initializable pattern. Custom tracking can be corrupted by storage collision during upgrades, allowing re-initialization attacks. This was the root cause of the AllianceBlock staking exploit in 2024.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:366:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Use OpenZeppelin's Initializable contract instead of custom tracking:

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract MyContract is Initializable {
function initialize() public initializer {
// initialization logic
}
}

ğŸ”¥ CRITICAL: Function 'initialize' in contract 'VulnerableMinimalProxy' uses a custom require check for initialization instead of OpenZeppelin's initializer modifier. This pattern is vulnerable to storage collision attacks during upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:375:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Replace custom require check with OpenZeppelin's initializer modifier:

function initialize() public initializer {
// initialization logic
}

ğŸ”¥ CRITICAL: Proxy contract 'VulnerableMinimalProxy' has state variable '' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

âš ï¸  HIGH: Beacon contract 'VulnerableMinimalProxy' allows immediate upgrades without a timelock. Malicious or accidental upgrades will immediately affect all proxy contracts using this beacon, with no time for users to react.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: beacon-single-point-of-failure
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add a timelock to beacon upgrades:

uint256 public constant UPGRADE_DELAY = 2 days;
address public pendingImplementation;
uint256 public upgradeTimestamp;

function proposeUpgrade(address newImpl) external onlyOwner {
pendingImplementation = newImpl;
upgradeTimestamp = block.timestamp + UPGRADE_DELAY;
}

function executeUpgrade() external {
require(block.timestamp >= upgradeTimestamp);
_upgradeTo(pendingImplementation);
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableMinimalProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableMinimalProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableMinimalProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableMinimalProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableMinimalProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableMinimalProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableMinimalProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableMinimalProxy' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Fallback function in Diamond contract 'VulnerableMinimalProxy' performs delegatecall without checking facet code existence. This can cause silent failures for any call to the Diamond when the selected facet has been destroyed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in fallback:

fallback() external payable {
address facet = selectorToFacet[msg.sig];
require(facet != address(0), "Function not found");
require(facet.code.length > 0, "Facet destroyed");
// delegatecall...
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableMinimalProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableMinimalProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function '_authorizeUpgrade' in contract 'VulnerableMinimalProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:68:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableMinimalProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableMinimalProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeBeacon' in contract 'VulnerableMinimalProxy' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:164:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'changeAdmin' in contract 'VulnerableMinimalProxy' changes admin without emitting AdminChanged event.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Emit AdminChanged event:

function _changeAdmin(address newAdmin) internal {
emit AdminChanged(_getAdmin(), newAdmin);
_setAdmin(newAdmin);
}

âš ï¸  HIGH: Contract 'VulnerableMinimalProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:6:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableMinimalProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableMinimalProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:44:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableMinimalProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableMinimalProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableMinimalProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableMinimalProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableMinimalProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableMinimalProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableMinimalProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableMinimalProxy' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'VulnerableMinimalProxy' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:21:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'VulnerableMinimalProxy' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:22:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'VulnerableMinimalProxy' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:64:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'upgradeTo' in contract 'VulnerableMinimalProxy' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:33:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'upgradeToUnchecked' in contract 'VulnerableMinimalProxy' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'selfDestruct' in contract 'VulnerableMinimalProxy' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:418:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'selfDestruct' in contract 'VulnerableMinimalProxy' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'VulnerableMinimalProxy' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableMinimalProxy' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'clone' in contract 'VulnerableMinimalProxy' uses assembly create/create2. Ensure bytecode source is trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:304:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate assembly deployment:

1. Verify bytecode hash before create/create2
2. Use high-level new ContractName() when possible
3. Audit all sources of deployment bytecode

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableMinimalProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableMinimalProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:106:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableMinimalProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:134:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableMinimalProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:176:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableMinimalProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:237:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableMinimalProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:275:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableMinimalProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:329:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableMinimalProxy' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:386:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableMinimalProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableMinimalProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableMinimalProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableMinimalProxy' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:324:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Upgrade function 'upgradeTo' in contract 'VulnerableMinimalProxy' has weak protection. Owner-only upgrades without timelock allow rapid privilege changes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Strengthen upgrade protection:

1. Require timelock for upgrades
2. Use governance vote for implementation changes
3. Add upgrade delay period

Example:
function _authorizeUpgrade(address) internal override onlyTimelock {}

âš ï¸  HIGH: Function 'addFacet' in contract 'VulnerableMinimalProxy' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:224:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'addFacet' in contract 'VulnerableMinimalProxy' accepts unbounded array input. Large inputs can cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit input array size:

uint256 constant MAX_BATCH_SIZE = 100;

function processBatch(address[] calldata items) external {
require(
items.length <= MAX_BATCH_SIZE,
"Batch too large"
);
// ...
}

âš ï¸  HIGH: Function 'implementation' in contract 'VulnerableMinimalProxy' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:324:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

ğŸ”¥ CRITICAL: Function '' uses delegatecall which can cause storage collision. Delegatecall to variable target without storage layout verification Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:329:5
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in ''. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function '' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:329:5
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in ''. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:324:5
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:329:5
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

âš¡ MEDIUM: Function '' contains variable shadowing. Local variable 'impl' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:329:5
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in ''. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Contract 'ProxyWithStorageCollision' is a Diamond proxy but missing required ERC-2535 Loupe functions: facets(), facetFunctionSelectors(address), facetAddresses(), facetAddress(bytes4). The Diamond Loupe standard defines 4 introspection functions that enable tools, users, and contracts to discover which facets and functions a Diamond implements. Without these, the Diamond becomes a black box, hindering integration, debugging, and security auditing.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:319:10
   â”œâ”€ Detector: diamond-loupe-violation
   â”œâ”€ CWE: CWE-573
   â””â”€ Fix: Implement missing Loupe functions in 'ProxyWithStorageCollision': (1) facets() returning Facet[] array with address and selectors for each facet (2) facetFunctionSelectors(address _facet) returning bytes4[] of selectors for a facet (3) facetAddresses() returning address[] of all facet addresses (4) facetAddress(bytes4 _selector) returning address of facet for a selector (5) Implement IDiamondLoupe interface and add to supportsInterface

âš¡ MEDIUM: Contract 'ProxyWithStorageCollision' implements loupe functions but doesn't declare IDiamondLoupe interface support. The ERC-2535 standard requires supportsInterface(0x48e2b093) to return true for IDiamondLoupe. Without proper interface support, tools cannot reliably detect Diamond Loupe compliance.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:319:10
   â”œâ”€ Detector: diamond-loupe-violation
   â”œâ”€ CWE: CWE-573
   â””â”€ Fix: Add interface support to 'ProxyWithStorageCollision': (1) Import 'import "@openzeppelin/contracts/utils/introspection/IERC165.sol"' (2) Implement supportsInterface: 'return interfaceId == type(IDiamondLoupe).interfaceId || interfaceId == type(IERC165).interfaceId' (3) IDiamondLoupe interface ID is 0x48e2b093 (4) Ensure DiamondLoupeFacet is added during initialization (5) Test interface detection with supportsInterface

ğŸ”¥ CRITICAL: Contract 'ProxyWithStorageCollision' fallback performs delegatecall without validating facet != address(0). When a function selector is not registered in selectorToFacet, it returns address(0). Delegatecall to address(0) succeeds silently in assembly, returning success=true without executing any code. This creates false success responses for non-existent functions, breaking contract behavior and potentially bypassing security checks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:319:10
   â”œâ”€ Detector: diamond-delegatecall-zero
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add facet validation in 'ProxyWithStorageCollision' fallback: (1) After loading facet address, add 'require(facet != address(0), "Function does not exist")' (2) Check BEFORE delegatecall, not after (3) Use revert with custom error for gas efficiency: 'error FunctionNotFound(bytes4 selector)' (4) Consider explicit fallback failure rather than silent success (5) Validate facet in both Solidity and assembly implementations

ğŸ”¥ CRITICAL: Contract 'ProxyWithStorageCollision' fallback delegates without verifying facet has code. Even if facet != address(0), the address may be an EOA or a self-destructed contract with no code. Delegatecall to addresses without code succeeds silently, returning success=true. This allows unregistered selectors to succeed unexpectedly, bypassing access controls and validation logic.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:319:10
   â”œâ”€ Detector: diamond-delegatecall-zero
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in 'ProxyWithStorageCollision': (1) Validate 'require(facet.code.length > 0, "Facet has no code")' (2) In assembly, use EXTCODESIZE: 'if iszero(extcodesize(facet)) { revert(0, 0) }' (3) Perform check immediately after loading facet address (4) Consider caching code validation during facet registration (5) Handle self-destructed facets gracefully

ğŸ”¥ CRITICAL: Contract 'ProxyWithStorageCollision' uses assembly delegatecall without proper validation. Assembly delegatecall bypasses Solidity's address validation, making it critical to manually check facet != 0 and extcodesize > 0. Missing validation in assembly is more dangerous because there are no implicit safety checks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:319:10
   â”œâ”€ Detector: diamond-delegatecall-zero
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add assembly validation in 'ProxyWithStorageCollision': (1) After loading facet: 'if iszero(facet) { revert(0, 0) }' (2) Check code size: 'if iszero(extcodesize(facet)) { revert(0, 0) }' (3) Place checks immediately before delegatecall opcode (4) Use consistent error handling (revert with error code) (5) Document assembly validation logic clearly

âš ï¸  HIGH: Contract 'ProxyWithStorageCollision' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:319:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

âš ï¸  HIGH: Function '' performs delegatecall in fallback/receive without access control. Fallback/receive function performs delegatecall without validating the caller. Any address can trigger this by calling a non-existent function or sending ETH. This allows any caller to execute arbitrary code by calling non-existent functions or sending ETH to the contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:329:5
   â”œâ”€ Detector: fallback-delegatecall-unprotected
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Add access control to fallback function ''. Validate implementation address before delegatecall. Use modifiers like 'onlyOwner' or check msg.sender explicitly. Consider using OpenZeppelin's transparent or UUPS proxy patterns.

ğŸ”¥ CRITICAL: Implementation contract 'ProxyWithStorageCollision' has a constructor but does not call _disableInitializers(). The implementation contract can be initialized by an attacker.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:319:10
   â”œâ”€ Detector: implementation-not-initialized
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that calls _disableInitializers():

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This prevents the implementation contract from being initialized directly.

ğŸ”¥ CRITICAL: UUPS contract 'ProxyWithStorageCollision' does not call _disableInitializers() in constructor. An attacker can initialize the implementation contract directly and potentially call upgradeTo() to brick all proxies or take control.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:319:10
   â”œâ”€ Detector: uups-missing-disable-initializers
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that disables initializers:

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This is especially critical for UUPS contracts since the upgrade logic lives in the implementation.

ğŸ”¥ CRITICAL: Implementation contract 'ProxyWithStorageCollision' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Beacon contract 'ProxyWithStorageCollision' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'ProxyWithStorageCollision' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'ProxyWithStorageCollision' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

âš ï¸  HIGH: Implementation contract 'ProxyWithStorageCollision' has function 'changeAdmin' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'changeAdmin' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Implementation contract 'ProxyWithStorageCollision' has function 'implementation' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'implementation' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Transparent proxy 'ProxyWithStorageCollision': Setting admin to msg.sender in initializer - admin should be separate from users
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:410:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Ensure admin operations and user operations use separate addresses. The admin address can only call admin functions, not implementation functions.

âš ï¸  HIGH: Implementation contract 'ProxyWithStorageCollision': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'ProxyWithStorageCollision': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'ProxyWithStorageCollision': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'ProxyWithStorageCollision': Function 'implementation()' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš¡ MEDIUM: Upgradeable contract 'ProxyWithStorageCollision' has 22 state variable(s) but no storage gap. Adding new state variables in future upgrades may corrupt storage layout of derived contracts.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:0
   â”œâ”€ Detector: missing-storage-gap
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Add a storage gap at the end of the contract to reserve slots for future use:

contract UpgradeableBase is Initializable {
uint256 public value;

// Reserve 50 slots for future storage variables
// Reduce this number when adding new state variables
uint256[50] private __gap;
}

When adding new state variables, reduce the gap size accordingly:
uint256 public newValue; // Added in upgrade
uint256[49] private __gap; // Reduced from 50 to 49

ğŸ”¥ CRITICAL: Contract 'ProxyWithStorageCollision' uses custom initialization tracking variable instead of OpenZeppelin's Initializable pattern. Custom tracking can be corrupted by storage collision during upgrades, allowing re-initialization attacks. This was the root cause of the AllianceBlock staking exploit in 2024.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:366:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Use OpenZeppelin's Initializable contract instead of custom tracking:

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract MyContract is Initializable {
function initialize() public initializer {
// initialization logic
}
}

ğŸ”¥ CRITICAL: Function 'initialize' in contract 'ProxyWithStorageCollision' uses a custom require check for initialization instead of OpenZeppelin's initializer modifier. This pattern is vulnerable to storage collision attacks during upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:375:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Replace custom require check with OpenZeppelin's initializer modifier:

function initialize() public initializer {
// initialization logic
}

ğŸ”¥ CRITICAL: Proxy contract 'ProxyWithStorageCollision' has state variable '' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

âš ï¸  HIGH: Beacon contract 'ProxyWithStorageCollision' allows immediate upgrades without a timelock. Malicious or accidental upgrades will immediately affect all proxy contracts using this beacon, with no time for users to react.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: beacon-single-point-of-failure
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add a timelock to beacon upgrades:

uint256 public constant UPGRADE_DELAY = 2 days;
address public pendingImplementation;
uint256 public upgradeTimestamp;

function proposeUpgrade(address newImpl) external onlyOwner {
pendingImplementation = newImpl;
upgradeTimestamp = block.timestamp + UPGRADE_DELAY;
}

function executeUpgrade() external {
require(block.timestamp >= upgradeTimestamp);
_upgradeTo(pendingImplementation);
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'ProxyWithStorageCollision' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'ProxyWithStorageCollision' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'ProxyWithStorageCollision' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'ProxyWithStorageCollision' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'ProxyWithStorageCollision' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'ProxyWithStorageCollision' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'ProxyWithStorageCollision' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'ProxyWithStorageCollision' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Fallback function in Diamond contract 'ProxyWithStorageCollision' performs delegatecall without checking facet code existence. This can cause silent failures for any call to the Diamond when the selected facet has been destroyed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in fallback:

fallback() external payable {
address facet = selectorToFacet[msg.sig];
require(facet != address(0), "Function not found");
require(facet.code.length > 0, "Facet destroyed");
// delegatecall...
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'ProxyWithStorageCollision' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'ProxyWithStorageCollision' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function '_authorizeUpgrade' in contract 'ProxyWithStorageCollision' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:68:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'ProxyWithStorageCollision' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'ProxyWithStorageCollision' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeBeacon' in contract 'ProxyWithStorageCollision' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:164:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'changeAdmin' in contract 'ProxyWithStorageCollision' changes admin without emitting AdminChanged event.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Emit AdminChanged event:

function _changeAdmin(address newAdmin) internal {
emit AdminChanged(_getAdmin(), newAdmin);
_setAdmin(newAdmin);
}

âš ï¸  HIGH: Contract 'ProxyWithStorageCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:6:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ProxyWithStorageCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ProxyWithStorageCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:44:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ProxyWithStorageCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ProxyWithStorageCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ProxyWithStorageCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ProxyWithStorageCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ProxyWithStorageCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ProxyWithStorageCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ProxyWithStorageCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'ProxyWithStorageCollision' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'ProxyWithStorageCollision' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:21:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'ProxyWithStorageCollision' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:22:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'ProxyWithStorageCollision' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:64:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'upgradeTo' in contract 'ProxyWithStorageCollision' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:33:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'upgradeToUnchecked' in contract 'ProxyWithStorageCollision' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'selfDestruct' in contract 'ProxyWithStorageCollision' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:418:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'selfDestruct' in contract 'ProxyWithStorageCollision' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'ProxyWithStorageCollision' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'ProxyWithStorageCollision' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'clone' in contract 'ProxyWithStorageCollision' uses assembly create/create2. Ensure bytecode source is trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:304:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate assembly deployment:

1. Verify bytecode hash before create/create2
2. Use high-level new ContractName() when possible
3. Audit all sources of deployment bytecode

ğŸ”¥ CRITICAL: Proxy fallback in contract 'ProxyWithStorageCollision' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'ProxyWithStorageCollision' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:106:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'ProxyWithStorageCollision' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:134:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'ProxyWithStorageCollision' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:176:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'ProxyWithStorageCollision' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:237:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'ProxyWithStorageCollision' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:275:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'ProxyWithStorageCollision' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:329:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'ProxyWithStorageCollision' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:386:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'ProxyWithStorageCollision' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'ProxyWithStorageCollision' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'ProxyWithStorageCollision' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'ProxyWithStorageCollision' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:324:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Upgrade function 'upgradeTo' in contract 'ProxyWithStorageCollision' has weak protection. Owner-only upgrades without timelock allow rapid privilege changes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Strengthen upgrade protection:

1. Require timelock for upgrades
2. Use governance vote for implementation changes
3. Add upgrade delay period

Example:
function _authorizeUpgrade(address) internal override onlyTimelock {}

âš ï¸  HIGH: Function 'addFacet' in contract 'ProxyWithStorageCollision' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:224:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'addFacet' in contract 'ProxyWithStorageCollision' accepts unbounded array input. Large inputs can cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit input array size:

uint256 constant MAX_BATCH_SIZE = 100;

function processBatch(address[] calldata items) external {
require(
items.length <= MAX_BATCH_SIZE,
"Batch too large"
);
// ...
}

âš ï¸  HIGH: Function 'implementation' in contract 'ProxyWithStorageCollision' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

ğŸ”¥ CRITICAL: Function 'setCounter' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:348:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'setCounter'

ğŸ”¥ CRITICAL: Function 'setOwner' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:353:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'setOwner'

âš ï¸  HIGH: Address parameter '_owner' in function 'setOwner' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:353:31
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_owner != address(0), "Zero address not allowed");

âš ï¸  HIGH: Parameter '_owner' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:353:31
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_owner != address(0), "Invalid address");

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:348:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

ğŸ”¥ CRITICAL: Function 'setCounter' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:348:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'setCounter'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

âš ï¸  HIGH: Contract 'MismatchedStorageImplementation' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:343:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

âš¡ MEDIUM: Function 'setOwner' in proxy contract may shadow implementation. Function 'setOwner' may shadow implementation's function. In transparent proxies, use ifAdmin pattern to separate admin and user calls Real-world impact: Similar to issues in various proxy implementations where admin functions were shadowed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:353:14
   â”œâ”€ Detector: fallback-function-shadowing
   â””â”€ CWE: CWE-670

ğŸ”¥ CRITICAL: Implementation contract 'MismatchedStorageImplementation' has a constructor but does not call _disableInitializers(). The implementation contract can be initialized by an attacker.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:343:10
   â”œâ”€ Detector: implementation-not-initialized
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that calls _disableInitializers():

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This prevents the implementation contract from being initialized directly.

ğŸ”¥ CRITICAL: UUPS contract 'MismatchedStorageImplementation' does not call _disableInitializers() in constructor. An attacker can initialize the implementation contract directly and potentially call upgradeTo() to brick all proxies or take control.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:343:10
   â”œâ”€ Detector: uups-missing-disable-initializers
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that disables initializers:

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This is especially critical for UUPS contracts since the upgrade logic lives in the implementation.

ğŸ”¥ CRITICAL: Implementation contract 'MismatchedStorageImplementation' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Beacon contract 'MismatchedStorageImplementation' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'MismatchedStorageImplementation' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'MismatchedStorageImplementation' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

âš ï¸  HIGH: Implementation contract 'MismatchedStorageImplementation' has function 'changeAdmin' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'changeAdmin' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Implementation contract 'MismatchedStorageImplementation' has function 'implementation' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'implementation' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Transparent proxy 'MismatchedStorageImplementation': Setting admin to msg.sender in initializer - admin should be separate from users
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:410:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Ensure admin operations and user operations use separate addresses. The admin address can only call admin functions, not implementation functions.

âš ï¸  HIGH: Implementation contract 'MismatchedStorageImplementation': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'MismatchedStorageImplementation': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'MismatchedStorageImplementation': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'MismatchedStorageImplementation': Function 'implementation()' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš¡ MEDIUM: Upgradeable contract 'MismatchedStorageImplementation' has 22 state variable(s) but no storage gap. Adding new state variables in future upgrades may corrupt storage layout of derived contracts.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:0
   â”œâ”€ Detector: missing-storage-gap
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Add a storage gap at the end of the contract to reserve slots for future use:

contract UpgradeableBase is Initializable {
uint256 public value;

// Reserve 50 slots for future storage variables
// Reduce this number when adding new state variables
uint256[50] private __gap;
}

When adding new state variables, reduce the gap size accordingly:
uint256 public newValue; // Added in upgrade
uint256[49] private __gap; // Reduced from 50 to 49

ğŸ”¥ CRITICAL: Contract 'MismatchedStorageImplementation' uses custom initialization tracking variable instead of OpenZeppelin's Initializable pattern. Custom tracking can be corrupted by storage collision during upgrades, allowing re-initialization attacks. This was the root cause of the AllianceBlock staking exploit in 2024.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:366:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Use OpenZeppelin's Initializable contract instead of custom tracking:

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract MyContract is Initializable {
function initialize() public initializer {
// initialization logic
}
}

ğŸ”¥ CRITICAL: Function 'initialize' in contract 'MismatchedStorageImplementation' uses a custom require check for initialization instead of OpenZeppelin's initializer modifier. This pattern is vulnerable to storage collision attacks during upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:375:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Replace custom require check with OpenZeppelin's initializer modifier:

function initialize() public initializer {
// initialization logic
}

ğŸ”¥ CRITICAL: Proxy contract 'MismatchedStorageImplementation' has state variable '' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

âš ï¸  HIGH: Beacon contract 'MismatchedStorageImplementation' allows immediate upgrades without a timelock. Malicious or accidental upgrades will immediately affect all proxy contracts using this beacon, with no time for users to react.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: beacon-single-point-of-failure
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add a timelock to beacon upgrades:

uint256 public constant UPGRADE_DELAY = 2 days;
address public pendingImplementation;
uint256 public upgradeTimestamp;

function proposeUpgrade(address newImpl) external onlyOwner {
pendingImplementation = newImpl;
upgradeTimestamp = block.timestamp + UPGRADE_DELAY;
}

function executeUpgrade() external {
require(block.timestamp >= upgradeTimestamp);
_upgradeTo(pendingImplementation);
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'MismatchedStorageImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'MismatchedStorageImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'MismatchedStorageImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'MismatchedStorageImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'MismatchedStorageImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'MismatchedStorageImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'MismatchedStorageImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'MismatchedStorageImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Fallback function in Diamond contract 'MismatchedStorageImplementation' performs delegatecall without checking facet code existence. This can cause silent failures for any call to the Diamond when the selected facet has been destroyed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in fallback:

fallback() external payable {
address facet = selectorToFacet[msg.sig];
require(facet != address(0), "Function not found");
require(facet.code.length > 0, "Facet destroyed");
// delegatecall...
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'MismatchedStorageImplementation' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'MismatchedStorageImplementation' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function '_authorizeUpgrade' in contract 'MismatchedStorageImplementation' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:68:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'MismatchedStorageImplementation' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'MismatchedStorageImplementation' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeBeacon' in contract 'MismatchedStorageImplementation' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:164:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'changeAdmin' in contract 'MismatchedStorageImplementation' changes admin without emitting AdminChanged event.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Emit AdminChanged event:

function _changeAdmin(address newAdmin) internal {
emit AdminChanged(_getAdmin(), newAdmin);
_setAdmin(newAdmin);
}

âš ï¸  HIGH: Contract 'MismatchedStorageImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:6:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MismatchedStorageImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MismatchedStorageImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:44:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MismatchedStorageImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MismatchedStorageImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MismatchedStorageImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MismatchedStorageImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MismatchedStorageImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MismatchedStorageImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MismatchedStorageImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MismatchedStorageImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'MismatchedStorageImplementation' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:21:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'MismatchedStorageImplementation' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:22:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'MismatchedStorageImplementation' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:64:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'upgradeTo' in contract 'MismatchedStorageImplementation' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:33:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'upgradeToUnchecked' in contract 'MismatchedStorageImplementation' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'selfDestruct' in contract 'MismatchedStorageImplementation' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:418:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'selfDestruct' in contract 'MismatchedStorageImplementation' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'MismatchedStorageImplementation' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'MismatchedStorageImplementation' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'clone' in contract 'MismatchedStorageImplementation' uses assembly create/create2. Ensure bytecode source is trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:304:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate assembly deployment:

1. Verify bytecode hash before create/create2
2. Use high-level new ContractName() when possible
3. Audit all sources of deployment bytecode

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MismatchedStorageImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MismatchedStorageImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:106:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MismatchedStorageImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:134:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MismatchedStorageImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:176:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MismatchedStorageImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:237:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MismatchedStorageImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:275:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MismatchedStorageImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:329:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MismatchedStorageImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:386:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'MismatchedStorageImplementation' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'MismatchedStorageImplementation' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'MismatchedStorageImplementation' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'MismatchedStorageImplementation' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:324:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Upgrade function 'upgradeTo' in contract 'MismatchedStorageImplementation' has weak protection. Owner-only upgrades without timelock allow rapid privilege changes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Strengthen upgrade protection:

1. Require timelock for upgrades
2. Use governance vote for implementation changes
3. Add upgrade delay period

Example:
function _authorizeUpgrade(address) internal override onlyTimelock {}

âš ï¸  HIGH: Function 'addFacet' in contract 'MismatchedStorageImplementation' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:224:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'addFacet' in contract 'MismatchedStorageImplementation' accepts unbounded array input. Large inputs can cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit input array size:

uint256 constant MAX_BATCH_SIZE = 100;

function processBatch(address[] calldata items) external {
require(
items.length <= MAX_BATCH_SIZE,
"Batch too large"
);
// ...
}

âš ï¸  HIGH: Function 'implementation' in contract 'MismatchedStorageImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

ğŸ”¥ CRITICAL: Function 'initialize' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:374:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'initialize'

ğŸ”¥ CRITICAL: Function 'reinitialize' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:381:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'reinitialize'

âš ï¸  HIGH: Initializer function 'initialize' lacks access control and can be called by anyone
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:374:14
   â”œâ”€ Detector: unprotected-initializer
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier to 'initialize' or ensure it can only be called once during deployment

âš ï¸  HIGH: Initializer function 'reinitialize' lacks access control and can be called by anyone
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:381:14
   â”œâ”€ Detector: unprotected-initializer
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier to 'reinitialize' or ensure it can only be called once during deployment

âš ï¸  HIGH: State variable 'initialized' is modified without proper validation or state checks
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:377:9
   â”œâ”€ Detector: invalid-state-transition
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Add proper validation before modifying state variables

âš ï¸  HIGH: Address parameter '_owner' in function 'initialize' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:374:33
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_owner != address(0), "Zero address not allowed");

âš ï¸  HIGH: Address parameter '_owner' in function 'reinitialize' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:381:35
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_owner != address(0), "Zero address not allowed");

âš ï¸  HIGH: Parameter '_owner' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:374:33
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_owner != address(0), "Invalid address");

âš ï¸  HIGH: Parameter '_owner' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:381:35
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_owner != address(0), "Invalid address");

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:368:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

ğŸ”¥ CRITICAL: Function '' uses delegatecall which can cause storage collision. Delegatecall to variable target without storage layout verification Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:386:5
   â”œâ”€ Detector: storage-collision
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Ensure storage layout compatibility in ''. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.

ğŸ”¥ CRITICAL: Function '' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:386:5
   â”œâ”€ Detector: dangerous-delegatecall
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Restrict delegatecall target in ''. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], "Unauthorized target");

ğŸ”¥ CRITICAL: Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:368:5
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:386:5
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ“ LOW: Function 'initialize' contains excessive gas usage pattern. Multiple storage reads detected (4). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:374:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'initialize'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

âš¡ MEDIUM: Function '' contains variable shadowing. Local variable 'impl' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:386:5
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in ''. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš ï¸  HIGH: Contract 'VulnerableProxyInitialization' supports initialization but doesn't track initialization status. Without 'initialized' flag, the contract can be reinitialized multiple times through reentrancy, allowing attackers to reset state, change ownership, or register malicious facets after initial setup.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:363:10
   â”œâ”€ Detector: diamond-init-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Implement initialization tracking in 'VulnerableProxyInitialization': (1) Add 'bool private _initialized' storage variable (2) Create 'initializer' modifier: 'require(!_initialized, "Already initialized")' (3) Set '_initialized = true' at start of initialization (4) Use OpenZeppelin's Initializable pattern for upgradeable contracts (5) Consider version tracking for multiple initialization phases

âš¡ MEDIUM: Contract 'VulnerableProxyInitialization' is a Diamond proxy but missing required ERC-2535 Loupe functions: facets(), facetFunctionSelectors(address), facetAddresses(), facetAddress(bytes4). The Diamond Loupe standard defines 4 introspection functions that enable tools, users, and contracts to discover which facets and functions a Diamond implements. Without these, the Diamond becomes a black box, hindering integration, debugging, and security auditing.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:363:10
   â”œâ”€ Detector: diamond-loupe-violation
   â”œâ”€ CWE: CWE-573
   â””â”€ Fix: Implement missing Loupe functions in 'VulnerableProxyInitialization': (1) facets() returning Facet[] array with address and selectors for each facet (2) facetFunctionSelectors(address _facet) returning bytes4[] of selectors for a facet (3) facetAddresses() returning address[] of all facet addresses (4) facetAddress(bytes4 _selector) returning address of facet for a selector (5) Implement IDiamondLoupe interface and add to supportsInterface

âš¡ MEDIUM: Contract 'VulnerableProxyInitialization' implements loupe functions but doesn't declare IDiamondLoupe interface support. The ERC-2535 standard requires supportsInterface(0x48e2b093) to return true for IDiamondLoupe. Without proper interface support, tools cannot reliably detect Diamond Loupe compliance.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:363:10
   â”œâ”€ Detector: diamond-loupe-violation
   â”œâ”€ CWE: CWE-573
   â””â”€ Fix: Add interface support to 'VulnerableProxyInitialization': (1) Import 'import "@openzeppelin/contracts/utils/introspection/IERC165.sol"' (2) Implement supportsInterface: 'return interfaceId == type(IDiamondLoupe).interfaceId || interfaceId == type(IERC165).interfaceId' (3) IDiamondLoupe interface ID is 0x48e2b093 (4) Ensure DiamondLoupeFacet is added during initialization (5) Test interface detection with supportsInterface

ğŸ”¥ CRITICAL: Contract 'VulnerableProxyInitialization' fallback performs delegatecall without validating facet != address(0). When a function selector is not registered in selectorToFacet, it returns address(0). Delegatecall to address(0) succeeds silently in assembly, returning success=true without executing any code. This creates false success responses for non-existent functions, breaking contract behavior and potentially bypassing security checks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:363:10
   â”œâ”€ Detector: diamond-delegatecall-zero
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add facet validation in 'VulnerableProxyInitialization' fallback: (1) After loading facet address, add 'require(facet != address(0), "Function does not exist")' (2) Check BEFORE delegatecall, not after (3) Use revert with custom error for gas efficiency: 'error FunctionNotFound(bytes4 selector)' (4) Consider explicit fallback failure rather than silent success (5) Validate facet in both Solidity and assembly implementations

ğŸ”¥ CRITICAL: Contract 'VulnerableProxyInitialization' fallback delegates without verifying facet has code. Even if facet != address(0), the address may be an EOA or a self-destructed contract with no code. Delegatecall to addresses without code succeeds silently, returning success=true. This allows unregistered selectors to succeed unexpectedly, bypassing access controls and validation logic.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:363:10
   â”œâ”€ Detector: diamond-delegatecall-zero
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in 'VulnerableProxyInitialization': (1) Validate 'require(facet.code.length > 0, "Facet has no code")' (2) In assembly, use EXTCODESIZE: 'if iszero(extcodesize(facet)) { revert(0, 0) }' (3) Perform check immediately after loading facet address (4) Consider caching code validation during facet registration (5) Handle self-destructed facets gracefully

ğŸ”¥ CRITICAL: Contract 'VulnerableProxyInitialization' uses assembly delegatecall without proper validation. Assembly delegatecall bypasses Solidity's address validation, making it critical to manually check facet != 0 and extcodesize > 0. Missing validation in assembly is more dangerous because there are no implicit safety checks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:363:10
   â”œâ”€ Detector: diamond-delegatecall-zero
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add assembly validation in 'VulnerableProxyInitialization': (1) After loading facet: 'if iszero(facet) { revert(0, 0) }' (2) Check code size: 'if iszero(extcodesize(facet)) { revert(0, 0) }' (3) Place checks immediately before delegatecall opcode (4) Use consistent error handling (revert with error code) (5) Document assembly validation logic clearly

âš ï¸  HIGH: Contract 'VulnerableProxyInitialization' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:363:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

âš ï¸  HIGH: Function '' performs delegatecall in fallback/receive without access control. Fallback/receive function performs delegatecall without validating the caller. Any address can trigger this by calling a non-existent function or sending ETH. This allows any caller to execute arbitrary code by calling non-existent functions or sending ETH to the contract.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:386:5
   â”œâ”€ Detector: fallback-delegatecall-unprotected
   â”œâ”€ CWE: CWE-829
   â””â”€ Fix: Add access control to fallback function ''. Validate implementation address before delegatecall. Use modifiers like 'onlyOwner' or check msg.sender explicitly. Consider using OpenZeppelin's transparent or UUPS proxy patterns.

âš¡ MEDIUM: Function 'initialize' in proxy contract may shadow implementation. Function 'initialize' may shadow implementation's function. In transparent proxies, use ifAdmin pattern to separate admin and user calls Real-world impact: Similar to issues in various proxy implementations where admin functions were shadowed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:374:14
   â”œâ”€ Detector: fallback-function-shadowing
   â””â”€ CWE: CWE-670

âš¡ MEDIUM: Function 'reinitialize' in proxy contract may shadow implementation. Function 'reinitialize' may shadow implementation's function. In transparent proxies, use ifAdmin pattern to separate admin and user calls Real-world impact: Similar to issues in various proxy implementations where admin functions were shadowed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:381:14
   â”œâ”€ Detector: fallback-function-shadowing
   â””â”€ CWE: CWE-670

ğŸ”¥ CRITICAL: Unprotected initialization in 'initialize' - vulnerable to front-running takeover ($1.54M August 2025 attack)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:374:0
   â”œâ”€ Detector: eip7702-init-frontrun
   â””â”€ Fix: EIP-7702 Front-Running Attack:

Current code (VULNERABLE):
function initialize(...) public {
require(owner == address(0));
owner = newOwner;  // âŒ Attacker can front-run!
}

Attack sequence:
1. User signs EIP-7702 authorization
2. Attacker sees authorization in mempool
3. Attacker front-runs with initialize(attackerAddress)
4. User's delegation is now controlled by attacker
5. Attacker drains all assets

Fix 1: Authorization-based initialization
function initialize(address _owner, bytes memory signature) public {
require(owner == address(0));

// âœ… Verify user signed this specific initialization
bytes32 hash = keccak256(abi.encodePacked(_owner, address(this)));
address signer = ECDSA.recover(hash, signature);
require(signer == _owner, "Invalid signature");

owner = _owner;
}

Fix 2: Constructor initialization (if possible)
constructor(address _owner) {
owner = _owner;  // âœ… Set during deployment
}

Fix 3: Factory pattern with immediate initialization
contract DelegateFactory {
function createDelegate() public returns (address) {
Delegate delegate = new Delegate(msg.sender);
return address(delegate);
}
}

Fix 4: Commit-reveal with time-lock
mapping(bytes32 => uint256) public commitments;

function commitInit(bytes32 commitment) public {
commitments[commitment] = block.timestamp;
}

function initialize(address _owner, bytes32 salt) public {
bytes32 commitment = keccak256(abi.encodePacked(_owner, salt));
require(commitments[commitment] > 0, "No commitment");
require(block.timestamp >= commitments[commitment] + 10 minutes);

owner = _owner;
}

Real-World Loss: $1.54M (August 2025)

ğŸ”¥ CRITICAL: Unprotected initialization in 'reinitialize' - vulnerable to front-running takeover ($1.54M August 2025 attack)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:381:0
   â”œâ”€ Detector: eip7702-init-frontrun
   â””â”€ Fix: EIP-7702 Front-Running Attack:

Current code (VULNERABLE):
function reinitialize(...) public {
require(owner == address(0));
owner = newOwner;  // âŒ Attacker can front-run!
}

Attack sequence:
1. User signs EIP-7702 authorization
2. Attacker sees authorization in mempool
3. Attacker front-runs with initialize(attackerAddress)
4. User's delegation is now controlled by attacker
5. Attacker drains all assets

Fix 1: Authorization-based initialization
function initialize(address _owner, bytes memory signature) public {
require(owner == address(0));

// âœ… Verify user signed this specific initialization
bytes32 hash = keccak256(abi.encodePacked(_owner, address(this)));
address signer = ECDSA.recover(hash, signature);
require(signer == _owner, "Invalid signature");

owner = _owner;
}

Fix 2: Constructor initialization (if possible)
constructor(address _owner) {
owner = _owner;  // âœ… Set during deployment
}

Fix 3: Factory pattern with immediate initialization
contract DelegateFactory {
function createDelegate() public returns (address) {
Delegate delegate = new Delegate(msg.sender);
return address(delegate);
}
}

Fix 4: Commit-reveal with time-lock
mapping(bytes32 => uint256) public commitments;

function commitInit(bytes32 commitment) public {
commitments[commitment] = block.timestamp;
}

function initialize(address _owner, bytes32 salt) public {
bytes32 commitment = keccak256(abi.encodePacked(_owner, salt));
require(commitments[commitment] > 0, "No commitment");
require(block.timestamp >= commitments[commitment] + 10 minutes);

owner = _owner;
}

Real-World Loss: $1.54M (August 2025)

ğŸ”¥ CRITICAL: Implementation contract 'VulnerableProxyInitialization' has a constructor but does not call _disableInitializers(). The implementation contract can be initialized by an attacker.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:363:10
   â”œâ”€ Detector: implementation-not-initialized
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that calls _disableInitializers():

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This prevents the implementation contract from being initialized directly.

ğŸ”¥ CRITICAL: UUPS contract 'VulnerableProxyInitialization' does not call _disableInitializers() in constructor. An attacker can initialize the implementation contract directly and potentially call upgradeTo() to brick all proxies or take control.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:363:10
   â”œâ”€ Detector: uups-missing-disable-initializers
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that disables initializers:

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This is especially critical for UUPS contracts since the upgrade logic lives in the implementation.

ğŸ”¥ CRITICAL: Implementation contract 'VulnerableProxyInitialization' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableProxyInitialization' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableProxyInitialization' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'VulnerableProxyInitialization' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

âš ï¸  HIGH: Implementation contract 'VulnerableProxyInitialization' has function 'changeAdmin' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'changeAdmin' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Implementation contract 'VulnerableProxyInitialization' has function 'implementation' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'implementation' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Transparent proxy 'VulnerableProxyInitialization': Setting admin to msg.sender in initializer - admin should be separate from users
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:410:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Ensure admin operations and user operations use separate addresses. The admin address can only call admin functions, not implementation functions.

âš ï¸  HIGH: Implementation contract 'VulnerableProxyInitialization': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableProxyInitialization': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableProxyInitialization': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'VulnerableProxyInitialization': Function 'implementation()' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš¡ MEDIUM: Upgradeable contract 'VulnerableProxyInitialization' has 22 state variable(s) but no storage gap. Adding new state variables in future upgrades may corrupt storage layout of derived contracts.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:0
   â”œâ”€ Detector: missing-storage-gap
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Add a storage gap at the end of the contract to reserve slots for future use:

contract UpgradeableBase is Initializable {
uint256 public value;

// Reserve 50 slots for future storage variables
// Reduce this number when adding new state variables
uint256[50] private __gap;
}

When adding new state variables, reduce the gap size accordingly:
uint256 public newValue; // Added in upgrade
uint256[49] private __gap; // Reduced from 50 to 49

ğŸ”¥ CRITICAL: Contract 'VulnerableProxyInitialization' uses custom initialization tracking variable instead of OpenZeppelin's Initializable pattern. Custom tracking can be corrupted by storage collision during upgrades, allowing re-initialization attacks. This was the root cause of the AllianceBlock staking exploit in 2024.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:366:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Use OpenZeppelin's Initializable contract instead of custom tracking:

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract MyContract is Initializable {
function initialize() public initializer {
// initialization logic
}
}

ğŸ”¥ CRITICAL: Function 'initialize' in contract 'VulnerableProxyInitialization' uses a custom require check for initialization instead of OpenZeppelin's initializer modifier. This pattern is vulnerable to storage collision attacks during upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:375:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Replace custom require check with OpenZeppelin's initializer modifier:

function initialize() public initializer {
// initialization logic
}

ğŸ”¥ CRITICAL: Proxy contract 'VulnerableProxyInitialization' has state variable '' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

âš ï¸  HIGH: Beacon contract 'VulnerableProxyInitialization' allows immediate upgrades without a timelock. Malicious or accidental upgrades will immediately affect all proxy contracts using this beacon, with no time for users to react.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: beacon-single-point-of-failure
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add a timelock to beacon upgrades:

uint256 public constant UPGRADE_DELAY = 2 days;
address public pendingImplementation;
uint256 public upgradeTimestamp;

function proposeUpgrade(address newImpl) external onlyOwner {
pendingImplementation = newImpl;
upgradeTimestamp = block.timestamp + UPGRADE_DELAY;
}

function executeUpgrade() external {
require(block.timestamp >= upgradeTimestamp);
_upgradeTo(pendingImplementation);
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableProxyInitialization' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableProxyInitialization' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableProxyInitialization' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableProxyInitialization' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableProxyInitialization' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableProxyInitialization' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableProxyInitialization' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'VulnerableProxyInitialization' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Fallback function in Diamond contract 'VulnerableProxyInitialization' performs delegatecall without checking facet code existence. This can cause silent failures for any call to the Diamond when the selected facet has been destroyed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in fallback:

fallback() external payable {
address facet = selectorToFacet[msg.sig];
require(facet != address(0), "Function not found");
require(facet.code.length > 0, "Facet destroyed");
// delegatecall...
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableProxyInitialization' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableProxyInitialization' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function '_authorizeUpgrade' in contract 'VulnerableProxyInitialization' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:68:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableProxyInitialization' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'VulnerableProxyInitialization' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeBeacon' in contract 'VulnerableProxyInitialization' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:164:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'changeAdmin' in contract 'VulnerableProxyInitialization' changes admin without emitting AdminChanged event.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Emit AdminChanged event:

function _changeAdmin(address newAdmin) internal {
emit AdminChanged(_getAdmin(), newAdmin);
_setAdmin(newAdmin);
}

âš ï¸  HIGH: Contract 'VulnerableProxyInitialization' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:6:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableProxyInitialization' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableProxyInitialization' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:44:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableProxyInitialization' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableProxyInitialization' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableProxyInitialization' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableProxyInitialization' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableProxyInitialization' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableProxyInitialization' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableProxyInitialization' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'VulnerableProxyInitialization' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'VulnerableProxyInitialization' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:21:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'VulnerableProxyInitialization' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:22:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'VulnerableProxyInitialization' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:64:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'upgradeTo' in contract 'VulnerableProxyInitialization' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:33:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'upgradeToUnchecked' in contract 'VulnerableProxyInitialization' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'selfDestruct' in contract 'VulnerableProxyInitialization' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:418:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'selfDestruct' in contract 'VulnerableProxyInitialization' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'VulnerableProxyInitialization' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableProxyInitialization' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'clone' in contract 'VulnerableProxyInitialization' uses assembly create/create2. Ensure bytecode source is trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:304:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate assembly deployment:

1. Verify bytecode hash before create/create2
2. Use high-level new ContractName() when possible
3. Audit all sources of deployment bytecode

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableProxyInitialization' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableProxyInitialization' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:106:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableProxyInitialization' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:134:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableProxyInitialization' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:176:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableProxyInitialization' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:237:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableProxyInitialization' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:275:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableProxyInitialization' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:329:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'VulnerableProxyInitialization' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:386:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableProxyInitialization' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableProxyInitialization' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableProxyInitialization' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableProxyInitialization' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:324:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Upgrade function 'upgradeTo' in contract 'VulnerableProxyInitialization' has weak protection. Owner-only upgrades without timelock allow rapid privilege changes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Strengthen upgrade protection:

1. Require timelock for upgrades
2. Use governance vote for implementation changes
3. Add upgrade delay period

Example:
function _authorizeUpgrade(address) internal override onlyTimelock {}

âš ï¸  HIGH: Function 'addFacet' in contract 'VulnerableProxyInitialization' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:224:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'addFacet' in contract 'VulnerableProxyInitialization' accepts unbounded array input. Large inputs can cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit input array size:

uint256 constant MAX_BATCH_SIZE = 100;

function processBatch(address[] calldata items) external {
require(
items.length <= MAX_BATCH_SIZE,
"Batch too large"
);
// ...
}

âš ï¸  HIGH: Function 'implementation' in contract 'VulnerableProxyInitialization' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

ğŸ”¥ CRITICAL: Function 'takeOwnership' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:408:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'takeOwnership'

ğŸ”¥ CRITICAL: Function 'changeImplementation' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:413:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'changeImplementation'

ğŸ”¥ CRITICAL: Function 'selfDestruct' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:418:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'selfDestruct'

âš¡ MEDIUM: Address parameter 'newImpl' in function 'changeImplementation' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:413:43
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(newImpl != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter 'newImpl' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:413:43
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(newImpl != address(0), "Invalid address");

âš ï¸  HIGH: Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:408:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Implement snapshot-based voting power using block-based or time-based snapshots.

âš ï¸  HIGH: Function 'selfDestruct' contains selfdestruct abuse vulnerability. Selfdestruct is publicly accessible without access control, allowing anyone to destroy the contract Selfdestruct permanently destroys the contract and can force-send ether to any address, bypassing fallback functions and breaking assumptions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:418:14
   â”œâ”€ Detector: selfdestruct-abuse
   â”œâ”€ CWE: CWE-670
   â””â”€ Fix: Restrict or remove selfdestruct in 'selfDestruct'. Add access control (onlyOwner), implement time-lock, or use withdraw pattern instead of selfdestruct. Consider that contracts expecting ether may not have payable fallback.

âš ï¸  HIGH: Function 'takeOwnership' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:408:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'takeOwnership'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function 'selfDestruct' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:418:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'selfDestruct'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

ğŸ”¥ CRITICAL: Function 'changeImplementation' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:413:14
   â”œâ”€ Detector: upgradeable-proxy-issues
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Fix proxy implementation in 'changeImplementation'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.

ğŸ”¥ CRITICAL: Function 'changeImplementation' is an unprotected proxy upgrade function. The upgrade function 'changeImplementation' is public and lacks access control modifiers. It modifies implementation storage without verifying msg.sender permissions. This allows any address to upgrade the implementation contract, potentially leading to complete takeover with fund theft and data manipulation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:413:14
   â”œâ”€ Detector: proxy-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'changeImplementation'. Use modifiers like 'onlyOwner', 'onlyAdmin', or implement role-based access control. Example: function changeImplementation(...) external onlyOwner { ... }

âš ï¸  HIGH: Contract 'MaliciousProxyImplementation' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:403:10
   â”œâ”€ Detector: proxy-storage-collision
   â”œâ”€ CWE: CWE-1321
   â””â”€ Fix: Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.

âš¡ MEDIUM: Function 'changeImplementation' in proxy contract may shadow implementation. Function 'changeImplementation' may shadow implementation's function. In transparent proxies, use ifAdmin pattern to separate admin and user calls Real-world impact: Similar to issues in various proxy implementations where admin functions were shadowed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:413:14
   â”œâ”€ Detector: fallback-function-shadowing
   â””â”€ CWE: CWE-670

ğŸ”¥ CRITICAL: Function 'selfDestruct' contains selfdestruct that publicly accessible without access control. Selfdestruct permanently destroys the contract and sends all remaining Ether to the specified address, bypassing any fallback functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:418:14
   â”œâ”€ Detector: swc106-unprotected-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Protect selfdestruct in 'selfDestruct' with:
1. Add 'onlyOwner' modifier or equivalent access control
2. Implement a timelock (e.g., 48-hour delay) before destruction
3. Consider using upgradeable proxy patterns instead of selfdestruct
4. If selfdestruct is necessary, hardcode a safe beneficiary address
Note: After EIP-6780 (Cancun), selfdestruct only destroys in same transaction as creation

ğŸ”¥ CRITICAL: Implementation contract 'MaliciousProxyImplementation' has a constructor but does not call _disableInitializers(). The implementation contract can be initialized by an attacker.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:403:10
   â”œâ”€ Detector: implementation-not-initialized
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that calls _disableInitializers():

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This prevents the implementation contract from being initialized directly.

ğŸ”¥ CRITICAL: UUPS contract 'MaliciousProxyImplementation' does not call _disableInitializers() in constructor. An attacker can initialize the implementation contract directly and potentially call upgradeTo() to brick all proxies or take control.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:403:10
   â”œâ”€ Detector: uups-missing-disable-initializers
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Add a constructor that disables initializers:

/// @custom:oz-upgrades-unsafe-allow constructor
constructor() {
_disableInitializers();
}

This is especially critical for UUPS contracts since the upgrade logic lives in the implementation.

ğŸ”¥ CRITICAL: Implementation contract 'MaliciousProxyImplementation' contains unprotected selfdestruct. An attacker can destroy the implementation, permanently bricking all proxy contracts. This was the root cause of the $150M Parity wallet freeze.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:0
   â”œâ”€ Detector: implementation-selfdestruct
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Remove selfdestruct from implementation contracts entirely. If you need emergency functionality:

1. Use a pause mechanism instead of selfdestruct
2. Implement upgrades to migrate to a new implementation
3. If selfdestruct is absolutely necessary, add multi-sig + timelock protection

Note: Post-Dencun, selfdestruct only deletes storage in same-tx creation.

ğŸ”¥ CRITICAL: Beacon contract 'MaliciousProxyImplementation' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'MaliciousProxyImplementation' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

ğŸ”¥ CRITICAL: Beacon contract 'MaliciousProxyImplementation' has unprotected upgrade function 'upgradeTo'. An attacker can call this function to change the implementation for ALL beacon proxies simultaneously, affecting every user.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: beacon-upgrade-unprotected
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'upgradeTo':

function upgradeTo(address newImplementation) public onlyOwner {
_upgradeTo(newImplementation);
}

Consider also adding a timelock for additional security.

âš ï¸  HIGH: Implementation contract 'MaliciousProxyImplementation' has function 'changeAdmin' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'changeAdmin' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Implementation contract 'MaliciousProxyImplementation' has function 'implementation' which may clash with transparent proxy admin functions. This could cause unexpected routing behavior when called through a proxy.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: function-selector-clash
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename function 'implementation' to avoid selector clash with proxy admin functions. Consider using a different name like 'getAdmin()' or 'contractAdmin()'.

âš ï¸  HIGH: Transparent proxy 'MaliciousProxyImplementation': Setting admin to msg.sender in initializer - admin should be separate from users
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:410:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Ensure admin operations and user operations use separate addresses. The admin address can only call admin functions, not implementation functions.

âš ï¸  HIGH: Implementation contract 'MaliciousProxyImplementation': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'MaliciousProxyImplementation': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'MaliciousProxyImplementation': Function 'upgradeTo(address)' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš ï¸  HIGH: Implementation contract 'MaliciousProxyImplementation': Function 'implementation()' in implementation will be unreachable by admin in transparent proxy pattern
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:0
   â”œâ”€ Detector: transparent-proxy-admin-issues
   â”œâ”€ CWE: CWE-436
   â””â”€ Fix: Rename functions that clash with transparent proxy admin functions. Consider using UUPS pattern if implementation needs these function names.

âš¡ MEDIUM: Upgradeable contract 'MaliciousProxyImplementation' has 22 state variable(s) but no storage gap. Adding new state variables in future upgrades may corrupt storage layout of derived contracts.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:0
   â”œâ”€ Detector: missing-storage-gap
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Add a storage gap at the end of the contract to reserve slots for future use:

contract UpgradeableBase is Initializable {
uint256 public value;

// Reserve 50 slots for future storage variables
// Reduce this number when adding new state variables
uint256[50] private __gap;
}

When adding new state variables, reduce the gap size accordingly:
uint256 public newValue; // Added in upgrade
uint256[49] private __gap; // Reduced from 50 to 49

ğŸ”¥ CRITICAL: Contract 'MaliciousProxyImplementation' uses custom initialization tracking variable instead of OpenZeppelin's Initializable pattern. Custom tracking can be corrupted by storage collision during upgrades, allowing re-initialization attacks. This was the root cause of the AllianceBlock staking exploit in 2024.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:366:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Use OpenZeppelin's Initializable contract instead of custom tracking:

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract MyContract is Initializable {
function initialize() public initializer {
// initialization logic
}
}

ğŸ”¥ CRITICAL: Function 'initialize' in contract 'MaliciousProxyImplementation' uses a custom require check for initialization instead of OpenZeppelin's initializer modifier. This pattern is vulnerable to storage collision attacks during upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:375:1
   â”œâ”€ Detector: reinitializer-vulnerability
   â”œâ”€ CWE: CWE-665
   â””â”€ Fix: Replace custom require check with OpenZeppelin's initializer modifier:

function initialize() public initializer {
// initialization logic
}

ğŸ”¥ CRITICAL: Proxy contract 'MaliciousProxyImplementation' has state variable '' declared before critical proxy variables. This can shift storage slots and corrupt the implementation pointer or other proxy state. This pattern caused the $6M Audius exploit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: storage-layout-inheritance-shift
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Move state variables to implementation contract or use EIP-1967 storage slots that don't conflict with regular storage:

// Use pseudo-random slot from EIP-1967
bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

Or declare proxy variables FIRST before any other state.

âš ï¸  HIGH: Beacon contract 'MaliciousProxyImplementation' allows immediate upgrades without a timelock. Malicious or accidental upgrades will immediately affect all proxy contracts using this beacon, with no time for users to react.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: beacon-single-point-of-failure
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add a timelock to beacon upgrades:

uint256 public constant UPGRADE_DELAY = 2 days;
address public pendingImplementation;
uint256 public upgradeTimestamp;

function proposeUpgrade(address newImpl) external onlyOwner {
pendingImplementation = newImpl;
upgradeTimestamp = block.timestamp + UPGRADE_DELAY;
}

function executeUpgrade() external {
require(block.timestamp >= upgradeTimestamp);
_upgradeTo(pendingImplementation);
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'MaliciousProxyImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'MaliciousProxyImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'MaliciousProxyImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'MaliciousProxyImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'MaliciousProxyImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'MaliciousProxyImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'MaliciousProxyImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Function 'fallback' in Diamond contract 'MaliciousProxyImplementation' performs delegatecall without verifying code exists at the target address. If a facet is destroyed or never deployed, delegatecall returns success but executes no code, causing silent failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check before delegatecall:

// Solidity check:
require(facet.code.length > 0, "Facet has no code");

// Or in assembly:
assembly {
if iszero(extcodesize(facet)) {
revert(0, 0) // or custom error
}
// then delegatecall
}

âš ï¸  HIGH: Fallback function in Diamond contract 'MaliciousProxyImplementation' performs delegatecall without checking facet code existence. This can cause silent failures for any call to the Diamond when the selected facet has been destroyed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: diamond-facet-code-existence
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add code existence check in fallback:

fallback() external payable {
address facet = selectorToFacet[msg.sig];
require(facet != address(0), "Function not found");
require(facet.code.length > 0, "Facet destroyed");
// delegatecall...
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'MaliciousProxyImplementation' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'MaliciousProxyImplementation' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:37:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function '_authorizeUpgrade' in contract 'MaliciousProxyImplementation' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:68:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'MaliciousProxyImplementation' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:73:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeTo' in contract 'MaliciousProxyImplementation' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:93:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'upgradeBeacon' in contract 'MaliciousProxyImplementation' doesn't emit an upgrade event. Monitoring tools, block explorers, and security systems rely on standard events (Upgraded, AdminChanged) to track proxy upgrades.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:164:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Add standard EIP-1967 events:

event Upgraded(address indexed implementation);
event AdminChanged(address previousAdmin, address newAdmin);
event BeaconUpgraded(address indexed beacon);

function _authorizeUpgrade(address newImpl) internal override {
// authorization logic
emit Upgraded(newImpl);
}

âš¡ MEDIUM: Function 'changeAdmin' in contract 'MaliciousProxyImplementation' changes admin without emitting AdminChanged event.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:128:1
   â”œâ”€ Detector: upgrade-event-missing
   â”œâ”€ CWE: CWE-778
   â””â”€ Fix: Emit AdminChanged event:

function _changeAdmin(address newAdmin) internal {
emit AdminChanged(_getAdmin(), newAdmin);
_setAdmin(newAdmin);
}

âš ï¸  HIGH: Contract 'MaliciousProxyImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:6:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousProxyImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:8:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousProxyImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:44:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousProxyImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:50:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousProxyImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:112:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousProxyImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:139:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousProxyImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:181:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousProxyImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:244:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousProxyImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:279:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousProxyImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:333:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

âš ï¸  HIGH: Contract 'MaliciousProxyImplementation' performs delegatecall inside a for loop. This is dangerous: each delegatecall can modify state, potentially causing reentrancy or unexpected behavior. Gas consumption is also unpredictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:390:1
   â”œâ”€ Detector: delegatecall-in-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid delegatecall in loops. Consider:

1. Batch operations in a single delegatecall:
bytes memory batchData = abi.encode(targets, data);
implementation.delegatecall(batchData);

2. Use a trusted multicall contract:
multicall.aggregate(calls);

3. Implement loop in the target contract instead

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'MaliciousProxyImplementation' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:21:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'MaliciousProxyImplementation' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:22:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'implementation' (address) in contract 'MaliciousProxyImplementation' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:64:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'upgradeTo' in contract 'MaliciousProxyImplementation' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:33:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'upgradeToUnchecked' in contract 'MaliciousProxyImplementation' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:41:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'selfDestruct' in contract 'MaliciousProxyImplementation' exposes selfdestruct without access control. Anyone can destroy the contract and redirect funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:418:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to selfdestruct:

function destroy() external onlyOwner {
selfdestruct(payable(owner));
}

Note: selfdestruct behavior changed after Dencun upgrade.

âš ï¸  HIGH: Function 'selfDestruct' in contract 'MaliciousProxyImplementation' uses msg.sender as selfdestruct recipient. Without access control, any caller can receive contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:419:1
   â”œâ”€ Detector: selfdestruct-recipient-control
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Restrict who can trigger selfdestruct:

function destroy() external onlyOwner {
// msg.sender is now guaranteed to be owner
selfdestruct(payable(msg.sender));
}

âš ï¸  HIGH: Constructor in contract 'MaliciousProxyImplementation' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'MaliciousProxyImplementation' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'clone' in contract 'MaliciousProxyImplementation' uses assembly create/create2. Ensure bytecode source is trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:304:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate assembly deployment:

1. Verify bytecode hash before create/create2
2. Use high-level new ContractName() when possible
3. Audit all sources of deployment bytecode

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MaliciousProxyImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:45:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MaliciousProxyImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:106:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MaliciousProxyImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:134:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MaliciousProxyImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:176:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MaliciousProxyImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:237:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MaliciousProxyImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:275:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MaliciousProxyImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:329:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Proxy fallback in contract 'MaliciousProxyImplementation' can bypass timelock through implementation switch. Admins can change implementation to bypass timelocked functions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:386:1
   â”œâ”€ Detector: timelock-bypass-delegatecall
   â”œâ”€ CWE: CWE-863
   â””â”€ Fix: Protect proxy implementation changes:

1. Require timelock for implementation upgrades
2. Add upgrade delay longer than max proposal timelock
3. Emit events for all implementation changes

ğŸ”¥ CRITICAL: Constructor in contract 'MaliciousProxyImplementation' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:24:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'MaliciousProxyImplementation' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:87:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'MaliciousProxyImplementation' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:194:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'MaliciousProxyImplementation' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:324:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Upgrade function 'upgradeTo' in contract 'MaliciousProxyImplementation' has weak protection. Owner-only upgrades without timelock allow rapid privilege changes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:30:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Strengthen upgrade protection:

1. Require timelock for upgrades
2. Use governance vote for implementation changes
3. Add upgrade delay period

Example:
function _authorizeUpgrade(address) internal override onlyTimelock {}

âš ï¸  HIGH: Function 'addFacet' in contract 'MaliciousProxyImplementation' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:224:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'addFacet' in contract 'MaliciousProxyImplementation' accepts unbounded array input. Large inputs can cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:222:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit input array size:

uint256 constant MAX_BATCH_SIZE = 100;

function processBatch(address[] calldata items) external {
require(
items.length <= MAX_BATCH_SIZE,
"Batch too large"
);
// ...
}

âš ï¸  HIGH: Function 'implementation' in contract 'MaliciousProxyImplementation' may recursively call itself via delegatecall. This can cause stack overflow or gas exhaustion.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DelegatecallProxies.sol:153:1
   â”œâ”€ Detector: delegatecall-to-self
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Prevent recursive delegatecall:

1. Add reentrancy guard for delegatecall functions
2. Validate selector before delegatecall
3. Use a depth counter to limit recursion
4. Consider using staticcall for read-only operations

âš ï¸  HIGH: Function 'bid' is vulnerable to block stuffing attacks. Auction closes in single block without multi-block finalization period, vulnerable to block stuffing to prevent last-minute bids Attackers can fill blocks with transactions to prevent legitimate users from executing time-sensitive operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:15:14
   â”œâ”€ Detector: block-stuffing-vulnerable
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate block stuffing in 'bid'. Implement: (1) Grace periods extending deadlines, (2) Multi-block operation windows, (3) Commit-reveal with extended reveal period, (4) Allow batch processing across multiple blocks, (5) Emergency pause mechanisms.

âš ï¸  HIGH: Function 'bid' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:15:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'bid'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš¡ MEDIUM: Function 'bid' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:15:14
   â”œâ”€ Detector: gas-griefing
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Mitigate gas griefing in 'bid'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.

âš ï¸  HIGH: Function 'bid' uses push pattern for transfers which can cause DoS if recipient reverts. A malicious or buggy recipient contract can block this function by rejecting payments. Use the pull pattern (withdrawal pattern) instead where users withdraw their own funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:15:14
   â”œâ”€ Detector: dos-failed-transfer
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Refactor 'bid' to use pull pattern instead of push. Store pending withdrawals in a mapping and let users withdraw their own funds. Example: balances[user] = amount; then separate withdraw() function. Use OpenZeppelin's PullPayment contract for reference.

âš ï¸  HIGH: Function 'bid' lacks front-running protection. Bidding function 'bid' lacks commit-reveal scheme. Attackers can see your bid and outbid you Front-runners can extract MEV by observing mempool and inserting their transactions before yours.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:15:14
   â”œâ”€ Detector: front-running-mitigation
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add front-running protection to 'bid'. Implement: (1) Commit-reveal scheme with time delay, (2) Deadline parameter for transaction validity, (3) Minimum output amount (slippage protection), (4) Batch auctions or frequent batch auctions (FBA), (5) Private mempool (Flashbots Protect), (6) Time-weighted average pricing (TWAP).

âš¡ MEDIUM: Function 'bid' contains variable shadowing. Parameter 'currentBid' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:15:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'bid'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Token transfer lacks return data size validation - vulnerable to return bomb DOS
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:1:1
   â”œâ”€ Detector: erc20-transfer-return-bomb
   â””â”€ Fix: Check returndatasize() and reject if excessive (>64 bytes): require(returndatasize() <= 64)

ğŸ“ LOW: Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:2:0
   â”œâ”€ Detector: floating-pragma
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.

âš¡ MEDIUM: Auction/bidding without commit-reveal - bids can be front-run
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:1:0
   â”œâ”€ Detector: missing-commit-reveal
   â””â”€ Fix: Implement commit-reveal pattern:

mapping(address => bytes32) public commitments;
mapping(address => uint256) public bids;
uint256 public commitDeadline;
uint256 public revealDeadline;

// Phase 1: Commit (hide bid amount)
function commitBid(bytes32 commitment) external {
require(block.timestamp < commitDeadline);
commitments[msg.sender] = commitment;
}

// Phase 2: Reveal (after commit deadline)
function revealBid(uint256 amount, bytes32 salt) external payable {
require(block.timestamp >= commitDeadline);
require(block.timestamp < revealDeadline);

bytes32 commitment = keccak256(abi.encode(amount, salt));
require(commitment == commitments[msg.sender], "Invalid reveal");
require(msg.value == amount, "Amount mismatch");

bids[msg.sender] = amount;
}

âš ï¸  HIGH: Potential division before multiplication - causes precision loss (OWASP 2025)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:1:0
   â”œâ”€ Detector: logic-error-patterns
   â””â”€ Fix: âŒ PRECISION LOSS ($63.8M in losses):
uint256 reward = (amount / totalSupply) * rewardRate;
// Result: 0 if amount < totalSupply!

âœ… CORRECT ORDER:
uint256 reward = (amount * rewardRate) / totalSupply;
// Maximizes precision, multiply before divide

âœ… BEST: Use fixed-point math:
uint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;

Real incidents:
- Cork Protocol: $11M (May 2025) - Division rounding
- SIR.trading: $355K (March 2025) - Reward calculation
- Multiple 2024 incidents: $63.8M total

âš¡ MEDIUM: Transfer function without zero-value check - validate non-zero amounts
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ MISSING ZERO-VALUE CHECK:
function transfer(address to, uint256 amount) external {
_transfer(msg.sender, to, amount);
// What if amount is 0? Wastes gas, may break accounting
}

âœ… VALIDATE NON-ZERO:
function transfer(address to, uint256 amount) external {
require(amount > 0, "Zero amount");
require(to != address(0), "Zero address");
_transfer(msg.sender, to, amount);
}

âœ… COMPLETE VALIDATION:
function deposit(uint256 amount) external payable {
// For ERC20 deposits
require(amount > 0, "Zero amount");
require(amount <= MAX_DEPOSIT, "Exceeds maximum");

// For native ETH deposits
if (msg.value > 0) {
require(msg.value == amount, "Value mismatch");
}

// Proceed with deposit
}

ğŸ”¥ CRITICAL: Function 'bid' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:15:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'bid'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

ğŸ”¥ CRITICAL: Function 'bid' in contract 'VulnerableAuction' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:23:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'bid' in contract 'VulnerableAuction' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:24:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableAuction' distributes rewards without vesting. Backrunners can deposit just before rewards and withdraw immediately after to capture disproportionate rewards.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:42:1
   â”œâ”€ Detector: backrunning-opportunity
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add vesting to reward distributions:

function notifyRewardAmount(uint256 reward) external {
rewardRate = reward / DURATION;
lastUpdateTime = block.timestamp;
periodFinish = block.timestamp + DURATION;
}

// Rewards vest over DURATION, preventing instant capture

âš ï¸  HIGH: Function 'bid' in contract 'VulnerableAuction' accepts bids without manipulation protection. Searchers can game the bidding process.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:15:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add bid manipulation protections:

1. Implement sealed-bid auctions with commit-reveal
2. Add minimum bid increments
3. Use time-weighted bidding
4. Implement bid bonds to prevent spam

âš ï¸  HIGH: Function 'addShareholder' in contract 'VulnerableAuction' has DoS vulnerability: Unbounded push to array 'shareholders'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:37:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'register' in contract 'VulnerableAuction' has DoS vulnerability: Unbounded push to array 'users'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:67:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'addRecipient' in contract 'VulnerableAuction' has DoS vulnerability: Unbounded push to array 'recipients'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:101:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableAuction' iterates over unbounded array: Iteration over unbounded array 'shareholders'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:46:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableAuction' iterates over unbounded array: Iteration over unbounded array 'shareholders'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:50:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'reset' in contract 'VulnerableAuction' iterates over unbounded array: Iteration over unbounded array 'users'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:74:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'getUserCount' in contract 'VulnerableAuction' iterates over unbounded array: Iteration over unbounded array 'users'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:84:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'splitPayment' in contract 'VulnerableAuction' iterates over unbounded array: Iteration over unbounded array 'recipients'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:109:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableAuction' performs gas-intensive operations in a loop. This can exceed block gas limit with large arrays.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:50:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Move gas-intensive operations outside loops:

1. Use pull pattern for transfers
2. Batch operations with limits
3. Use events for off-chain processing
4. Consider withdrawal patterns

âš ï¸  HIGH: Function 'splitPayment' in contract 'VulnerableAuction' performs gas-intensive operations in a loop. This can exceed block gas limit with large arrays.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:109:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Move gas-intensive operations outside loops:

1. Use pull pattern for transfers
2. Batch operations with limits
3. Use events for off-chain processing
4. Consider withdrawal patterns

âš ï¸  HIGH: Contract 'VulnerableAuction' has unbounded storage array 'shareholders'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:33:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Contract 'VulnerableAuction' has unbounded storage array 'users'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:62:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Contract 'VulnerableAuction' has unbounded storage array 'recipients'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:98:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableAuction' has DoS vulnerability: transfer() in loop. A single malicious or failing recipient can block the entire operation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:50:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use pull-over-push pattern:

// Instead of:
for (uint i = 0; i < recipients.length; i++) {
recipients[i].transfer(amounts[i]); // DoS risk
}

// Use:
mapping(address => uint256) pendingWithdrawals;

function withdraw() external {
uint256 amount = pendingWithdrawals[msg.sender];
pendingWithdrawals[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

âš ï¸  HIGH: Function 'splitPayment' in contract 'VulnerableAuction' has DoS vulnerability: transfer() in loop. A single malicious or failing recipient can block the entire operation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:109:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use pull-over-push pattern:

// Instead of:
for (uint i = 0; i < recipients.length; i++) {
recipients[i].transfer(amounts[i]); // DoS risk
}

// Use:
mapping(address => uint256) pendingWithdrawals;

function withdraw() external {
uint256 amount = pendingWithdrawals[msg.sender];
pendingWithdrawals[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableAuction' uses push payment pattern for distribution. Single failing recipient will revert entire distribution.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:42:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Convert to pull payment pattern:

1. Store amounts in mapping instead of sending
2. Let recipients claim their share
3. Or use try-catch with failure tracking:

try recipient.call{value: amount}("") {
// success
} catch {
failedPayments[recipient] = amount;
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableAuction' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:46:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableAuction' has gas limit risk: Unbounded loop with gas-intensive operations. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:50:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'reset' in contract 'VulnerableAuction' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:74:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'getUserCount' in contract 'VulnerableAuction' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:84:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'splitPayment' in contract 'VulnerableAuction' has gas limit risk: Unbounded loop with gas-intensive operations. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:109:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'bid' in contract 'VulnerableAuction' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:20:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableAuction' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:52:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'splitPayment' in contract 'VulnerableAuction' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:110:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'bid' in contract 'VulnerableAuction' depends on external callback behavior. Malicious contracts can force reverts during callbacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:15:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use try-catch for external calls:

try externalContract.callback() {
// success path
} catch {
// failure path - handle gracefully
emit CallbackFailed(target);
}

ğŸ”¥ CRITICAL: Function 'addShareholder' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:36:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'addShareholder'

ğŸ”¥ CRITICAL: Function 'distributeRewards' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:42:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'distributeRewards'

âš ï¸  HIGH: Function 'addShareholder' may be vulnerable to reentrancy attacks due to state changes after external calls
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:36:14
   â”œâ”€ Detector: classic-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Apply checks-effects-interactions pattern or use a reentrancy guard in function 'addShareholder'

âš¡ MEDIUM: Address parameter '_shareholder' in function 'addShareholder' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:36:37
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_shareholder != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter '_shareholder' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:36:37
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_shareholder != address(0), "Invalid address");

âš ï¸  HIGH: Function 'addShareholder' relies on a single oracle source, creating centralization risk
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:36:14
   â”œâ”€ Detector: single-oracle-source
   â”œâ”€ CWE: CWE-693
   â””â”€ Fix: Use multiple oracle sources and implement price aggregation in function 'addShareholder'

âš¡ MEDIUM: External call in function 'addShareholder' does not check return value
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:36:14
   â”œâ”€ Detector: unchecked-external-call
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check the return value of external calls in function 'addShareholder'

âš ï¸  HIGH: Function 'distributeRewards' contains external calls within loops. This can lead to DoS attacks if any external call fails or consumes excessive gas, and can be exploited in governance systems to block proposal execution.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:42:0
   â”œâ”€ Detector: external-calls-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid external calls in loops. Consider using a withdrawal pattern, batch processing, or fail-safe mechanisms for critical operations.

âš ï¸  HIGH: Function 'distributeRewards' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:42:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'distributeRewards'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function 'distributeRewards' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:42:14
   â”œâ”€ Detector: validator-front-running
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate validator front-running in 'distributeRewards'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.

âš¡ MEDIUM: Function 'distributeRewards' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:42:14
   â”œâ”€ Detector: gas-griefing
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Mitigate gas griefing in 'distributeRewards'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.

âš ï¸  HIGH: Function 'distributeRewards' has DOS vulnerability via unbounded operation. Loop over unbounded array without iteration limit, large arrays cause out-of-gas Can cause out-of-gas errors blocking contract functionality.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:42:14
   â”œâ”€ Detector: dos-unbounded-operation
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Fix unbounded operation in 'distributeRewards'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.

âš ï¸  HIGH: Function 'distributeRewards' uses push pattern for transfers which can cause DoS if recipient reverts. A malicious or buggy recipient contract can block this function by rejecting payments. Use the pull pattern (withdrawal pattern) instead where users withdraw their own funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:42:14
   â”œâ”€ Detector: dos-failed-transfer
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Refactor 'distributeRewards' to use pull pattern instead of push. Store pending withdrawals in a mapping and let users withdraw their own funds. Example: balances[user] = amount; then separate withdraw() function. Use OpenZeppelin's PullPayment contract for reference.

ğŸ“ LOW: Function 'distributeRewards' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:42:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'distributeRewards'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

âš¡ MEDIUM: Function 'distributeRewards' contains variable shadowing. Local variable 'totalShares' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:42:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'distributeRewards'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

ğŸ”¥ CRITICAL: Vulnerable to transient storage reentrancy in 'distributeRewards' - transfer()/send() no longer safe with EIP-1153
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:42:0
   â”œâ”€ Detector: transient-storage-reentrancy
   â””â”€ Fix: EIP-1153 breaks transfer()/send() safety assumption:

CRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within
the 2300 gas stipend of transfer() and send().

Fix 1: Use checks-effects-interactions pattern
function withdraw() public {
uint256 amount = balances[msg.sender];
require(amount > 0);

// âœ… Update state BEFORE external call
balances[msg.sender] = 0;

payable(msg.sender).transfer(amount);
}

Fix 2: Use ReentrancyGuard
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

function withdraw() public nonReentrant {
uint256 amount = balances[msg.sender];
require(amount > 0);

balances[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

Reference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)

ğŸ”¥ CRITICAL: Function 'distributeRewards' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:42:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'distributeRewards'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

ğŸ”¥ CRITICAL: Function 'bid' in contract 'VulnerableDistributor' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:23:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'bid' in contract 'VulnerableDistributor' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:24:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableDistributor' distributes rewards without vesting. Backrunners can deposit just before rewards and withdraw immediately after to capture disproportionate rewards.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:42:1
   â”œâ”€ Detector: backrunning-opportunity
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add vesting to reward distributions:

function notifyRewardAmount(uint256 reward) external {
rewardRate = reward / DURATION;
lastUpdateTime = block.timestamp;
periodFinish = block.timestamp + DURATION;
}

// Rewards vest over DURATION, preventing instant capture

âš ï¸  HIGH: Function 'bid' in contract 'VulnerableDistributor' accepts bids without manipulation protection. Searchers can game the bidding process.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:15:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add bid manipulation protections:

1. Implement sealed-bid auctions with commit-reveal
2. Add minimum bid increments
3. Use time-weighted bidding
4. Implement bid bonds to prevent spam

âš ï¸  HIGH: Function 'addShareholder' in contract 'VulnerableDistributor' has DoS vulnerability: Unbounded push to array 'shareholders'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:37:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'register' in contract 'VulnerableDistributor' has DoS vulnerability: Unbounded push to array 'users'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:67:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'addRecipient' in contract 'VulnerableDistributor' has DoS vulnerability: Unbounded push to array 'recipients'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:101:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableDistributor' iterates over unbounded array: Iteration over unbounded array 'shareholders'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:46:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableDistributor' iterates over unbounded array: Iteration over unbounded array 'shareholders'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:50:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'reset' in contract 'VulnerableDistributor' iterates over unbounded array: Iteration over unbounded array 'users'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:74:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'getUserCount' in contract 'VulnerableDistributor' iterates over unbounded array: Iteration over unbounded array 'users'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:84:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'splitPayment' in contract 'VulnerableDistributor' iterates over unbounded array: Iteration over unbounded array 'recipients'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:109:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableDistributor' performs gas-intensive operations in a loop. This can exceed block gas limit with large arrays.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:50:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Move gas-intensive operations outside loops:

1. Use pull pattern for transfers
2. Batch operations with limits
3. Use events for off-chain processing
4. Consider withdrawal patterns

âš ï¸  HIGH: Function 'splitPayment' in contract 'VulnerableDistributor' performs gas-intensive operations in a loop. This can exceed block gas limit with large arrays.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:109:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Move gas-intensive operations outside loops:

1. Use pull pattern for transfers
2. Batch operations with limits
3. Use events for off-chain processing
4. Consider withdrawal patterns

âš ï¸  HIGH: Contract 'VulnerableDistributor' has unbounded storage array 'shareholders'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:33:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Contract 'VulnerableDistributor' has unbounded storage array 'users'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:62:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Contract 'VulnerableDistributor' has unbounded storage array 'recipients'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:98:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableDistributor' has DoS vulnerability: transfer() in loop. A single malicious or failing recipient can block the entire operation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:50:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use pull-over-push pattern:

// Instead of:
for (uint i = 0; i < recipients.length; i++) {
recipients[i].transfer(amounts[i]); // DoS risk
}

// Use:
mapping(address => uint256) pendingWithdrawals;

function withdraw() external {
uint256 amount = pendingWithdrawals[msg.sender];
pendingWithdrawals[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

âš ï¸  HIGH: Function 'splitPayment' in contract 'VulnerableDistributor' has DoS vulnerability: transfer() in loop. A single malicious or failing recipient can block the entire operation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:109:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use pull-over-push pattern:

// Instead of:
for (uint i = 0; i < recipients.length; i++) {
recipients[i].transfer(amounts[i]); // DoS risk
}

// Use:
mapping(address => uint256) pendingWithdrawals;

function withdraw() external {
uint256 amount = pendingWithdrawals[msg.sender];
pendingWithdrawals[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableDistributor' uses push payment pattern for distribution. Single failing recipient will revert entire distribution.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:42:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Convert to pull payment pattern:

1. Store amounts in mapping instead of sending
2. Let recipients claim their share
3. Or use try-catch with failure tracking:

try recipient.call{value: amount}("") {
// success
} catch {
failedPayments[recipient] = amount;
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableDistributor' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:46:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableDistributor' has gas limit risk: Unbounded loop with gas-intensive operations. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:50:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'reset' in contract 'VulnerableDistributor' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:74:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'getUserCount' in contract 'VulnerableDistributor' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:84:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'splitPayment' in contract 'VulnerableDistributor' has gas limit risk: Unbounded loop with gas-intensive operations. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:109:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'bid' in contract 'VulnerableDistributor' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:20:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableDistributor' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:52:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'splitPayment' in contract 'VulnerableDistributor' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:110:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'bid' in contract 'VulnerableDistributor' depends on external callback behavior. Malicious contracts can force reverts during callbacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:15:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use try-catch for external calls:

try externalContract.callback() {
// success path
} catch {
// failure path - handle gracefully
emit CallbackFailed(target);
}

ğŸ”¥ CRITICAL: Function 'reset' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:72:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'reset'

âš ï¸  HIGH: Function 'register' may be vulnerable to reentrancy attacks due to state changes after external calls
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:65:14
   â”œâ”€ Detector: classic-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Apply checks-effects-interactions pattern or use a reentrancy guard in function 'register'

âš ï¸  HIGH: Function 'register' relies on a single oracle source, creating centralization risk
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:65:14
   â”œâ”€ Detector: single-oracle-source
   â”œâ”€ CWE: CWE-693
   â””â”€ Fix: Use multiple oracle sources and implement price aggregation in function 'register'

âš¡ MEDIUM: External call in function 'register' does not check return value
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:65:14
   â”œâ”€ Detector: unchecked-external-call
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check the return value of external calls in function 'register'

âš ï¸  HIGH: Function 'register' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:65:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'register'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function 'reset' has DOS vulnerability via unbounded operation. Loop over unbounded array without iteration limit, large arrays cause out-of-gas Can cause out-of-gas errors blocking contract functionality.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:72:14
   â”œâ”€ Detector: dos-unbounded-operation
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Fix unbounded operation in 'reset'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.

âš ï¸  HIGH: Function 'getUserCount' has DOS vulnerability via unbounded operation. Loop over unbounded array without iteration limit, large arrays cause out-of-gas Can cause out-of-gas errors blocking contract functionality.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:81:14
   â”œâ”€ Detector: dos-unbounded-operation
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Fix unbounded operation in 'getUserCount'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.

ğŸ“ LOW: Function 'reset' contains excessive gas usage pattern. Storage write operation inside loop. Consider using memory array Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:72:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'reset'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Function 'reset' contains excessive gas usage pattern. Storage deletion inside loop. Each delete costs significant gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:72:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'reset'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Function 'reset' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:72:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'reset'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Function 'getUserCount' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:81:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'getUserCount'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

âš¡ MEDIUM: Function 'getUserCount' contains variable shadowing. Local variable 'count' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:81:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'getUserCount'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

ğŸ”¥ CRITICAL: Function 'bid' in contract 'VulnerableRegistry' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:23:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'bid' in contract 'VulnerableRegistry' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:24:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableRegistry' distributes rewards without vesting. Backrunners can deposit just before rewards and withdraw immediately after to capture disproportionate rewards.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:42:1
   â”œâ”€ Detector: backrunning-opportunity
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add vesting to reward distributions:

function notifyRewardAmount(uint256 reward) external {
rewardRate = reward / DURATION;
lastUpdateTime = block.timestamp;
periodFinish = block.timestamp + DURATION;
}

// Rewards vest over DURATION, preventing instant capture

âš ï¸  HIGH: Function 'bid' in contract 'VulnerableRegistry' accepts bids without manipulation protection. Searchers can game the bidding process.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:15:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add bid manipulation protections:

1. Implement sealed-bid auctions with commit-reveal
2. Add minimum bid increments
3. Use time-weighted bidding
4. Implement bid bonds to prevent spam

âš ï¸  HIGH: Function 'addShareholder' in contract 'VulnerableRegistry' has DoS vulnerability: Unbounded push to array 'shareholders'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:37:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'register' in contract 'VulnerableRegistry' has DoS vulnerability: Unbounded push to array 'users'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:67:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'addRecipient' in contract 'VulnerableRegistry' has DoS vulnerability: Unbounded push to array 'recipients'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:101:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableRegistry' iterates over unbounded array: Iteration over unbounded array 'shareholders'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:46:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableRegistry' iterates over unbounded array: Iteration over unbounded array 'shareholders'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:50:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'reset' in contract 'VulnerableRegistry' iterates over unbounded array: Iteration over unbounded array 'users'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:74:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'getUserCount' in contract 'VulnerableRegistry' iterates over unbounded array: Iteration over unbounded array 'users'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:84:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'splitPayment' in contract 'VulnerableRegistry' iterates over unbounded array: Iteration over unbounded array 'recipients'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:109:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableRegistry' performs gas-intensive operations in a loop. This can exceed block gas limit with large arrays.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:50:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Move gas-intensive operations outside loops:

1. Use pull pattern for transfers
2. Batch operations with limits
3. Use events for off-chain processing
4. Consider withdrawal patterns

âš ï¸  HIGH: Function 'splitPayment' in contract 'VulnerableRegistry' performs gas-intensive operations in a loop. This can exceed block gas limit with large arrays.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:109:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Move gas-intensive operations outside loops:

1. Use pull pattern for transfers
2. Batch operations with limits
3. Use events for off-chain processing
4. Consider withdrawal patterns

âš ï¸  HIGH: Contract 'VulnerableRegistry' has unbounded storage array 'shareholders'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:33:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Contract 'VulnerableRegistry' has unbounded storage array 'users'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:62:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Contract 'VulnerableRegistry' has unbounded storage array 'recipients'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:98:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableRegistry' has DoS vulnerability: transfer() in loop. A single malicious or failing recipient can block the entire operation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:50:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use pull-over-push pattern:

// Instead of:
for (uint i = 0; i < recipients.length; i++) {
recipients[i].transfer(amounts[i]); // DoS risk
}

// Use:
mapping(address => uint256) pendingWithdrawals;

function withdraw() external {
uint256 amount = pendingWithdrawals[msg.sender];
pendingWithdrawals[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

âš ï¸  HIGH: Function 'splitPayment' in contract 'VulnerableRegistry' has DoS vulnerability: transfer() in loop. A single malicious or failing recipient can block the entire operation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:109:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use pull-over-push pattern:

// Instead of:
for (uint i = 0; i < recipients.length; i++) {
recipients[i].transfer(amounts[i]); // DoS risk
}

// Use:
mapping(address => uint256) pendingWithdrawals;

function withdraw() external {
uint256 amount = pendingWithdrawals[msg.sender];
pendingWithdrawals[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableRegistry' uses push payment pattern for distribution. Single failing recipient will revert entire distribution.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:42:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Convert to pull payment pattern:

1. Store amounts in mapping instead of sending
2. Let recipients claim their share
3. Or use try-catch with failure tracking:

try recipient.call{value: amount}("") {
// success
} catch {
failedPayments[recipient] = amount;
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableRegistry' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:46:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableRegistry' has gas limit risk: Unbounded loop with gas-intensive operations. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:50:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'reset' in contract 'VulnerableRegistry' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:74:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'getUserCount' in contract 'VulnerableRegistry' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:84:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'splitPayment' in contract 'VulnerableRegistry' has gas limit risk: Unbounded loop with gas-intensive operations. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:109:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'bid' in contract 'VulnerableRegistry' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:20:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerableRegistry' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:52:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'splitPayment' in contract 'VulnerableRegistry' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:110:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'bid' in contract 'VulnerableRegistry' depends on external callback behavior. Malicious contracts can force reverts during callbacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:15:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use try-catch for external calls:

try externalContract.callback() {
// success path
} catch {
// failure path - handle gracefully
emit CallbackFailed(target);
}

ğŸ”¥ CRITICAL: Function 'addRecipient' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:100:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'addRecipient'

âš ï¸  HIGH: Address parameter '_recipient' in function 'addRecipient' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:100:35
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_recipient != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter '_recipient' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:100:35
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_recipient != address(0), "Invalid address");

âš ï¸  HIGH: Function 'addRecipient' relies on a single oracle source, creating centralization risk
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:100:14
   â”œâ”€ Detector: single-oracle-source
   â”œâ”€ CWE: CWE-693
   â””â”€ Fix: Use multiple oracle sources and implement price aggregation in function 'addRecipient'

âš¡ MEDIUM: External call in function 'addRecipient' does not check return value
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:100:14
   â”œâ”€ Detector: unchecked-external-call
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check the return value of external calls in function 'addRecipient'

âš ï¸  HIGH: Function 'splitPayment' contains external calls within loops. This can lead to DoS attacks if any external call fails or consumes excessive gas, and can be exploited in governance systems to block proposal execution.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:105:0
   â”œâ”€ Detector: external-calls-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid external calls in loops. Consider using a withdrawal pattern, batch processing, or fail-safe mechanisms for critical operations.

âš ï¸  HIGH: Function 'splitPayment' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:105:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'splitPayment'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš¡ MEDIUM: Function 'splitPayment' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:105:14
   â”œâ”€ Detector: gas-griefing
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Mitigate gas griefing in 'splitPayment'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.

âš ï¸  HIGH: Function 'splitPayment' has DOS vulnerability via unbounded operation. Loop over unbounded array without iteration limit, large arrays cause out-of-gas Can cause out-of-gas errors blocking contract functionality.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:105:14
   â”œâ”€ Detector: dos-unbounded-operation
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Fix unbounded operation in 'splitPayment'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.

âš ï¸  HIGH: Function 'splitPayment' uses push pattern for transfers which can cause DoS if recipient reverts. A malicious or buggy recipient contract can block this function by rejecting payments. Use the pull pattern (withdrawal pattern) instead where users withdraw their own funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:105:14
   â”œâ”€ Detector: dos-failed-transfer
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Refactor 'splitPayment' to use pull pattern instead of push. Store pending withdrawals in a mapping and let users withdraw their own funds. Example: balances[user] = amount; then separate withdraw() function. Use OpenZeppelin's PullPayment contract for reference.

ğŸ“ LOW: Function 'splitPayment' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:105:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'splitPayment'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

âš¡ MEDIUM: Function 'splitPayment' contains variable shadowing. Local variable 'share' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:105:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'splitPayment'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

ğŸ”¥ CRITICAL: Vulnerable to transient storage reentrancy in 'splitPayment' - transfer()/send() no longer safe with EIP-1153
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:105:0
   â”œâ”€ Detector: transient-storage-reentrancy
   â””â”€ Fix: EIP-1153 breaks transfer()/send() safety assumption:

CRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within
the 2300 gas stipend of transfer() and send().

Fix 1: Use checks-effects-interactions pattern
function withdraw() public {
uint256 amount = balances[msg.sender];
require(amount > 0);

// âœ… Update state BEFORE external call
balances[msg.sender] = 0;

payable(msg.sender).transfer(amount);
}

Fix 2: Use ReentrancyGuard
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

function withdraw() public nonReentrant {
uint256 amount = balances[msg.sender];
require(amount > 0);

balances[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

Reference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)

ğŸ”¥ CRITICAL: Function 'splitPayment' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:105:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'splitPayment'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

ğŸ”¥ CRITICAL: Function 'bid' in contract 'VulnerablePaymentSplitter' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:23:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'bid' in contract 'VulnerablePaymentSplitter' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:24:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerablePaymentSplitter' distributes rewards without vesting. Backrunners can deposit just before rewards and withdraw immediately after to capture disproportionate rewards.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:42:1
   â”œâ”€ Detector: backrunning-opportunity
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add vesting to reward distributions:

function notifyRewardAmount(uint256 reward) external {
rewardRate = reward / DURATION;
lastUpdateTime = block.timestamp;
periodFinish = block.timestamp + DURATION;
}

// Rewards vest over DURATION, preventing instant capture

âš ï¸  HIGH: Function 'bid' in contract 'VulnerablePaymentSplitter' accepts bids without manipulation protection. Searchers can game the bidding process.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:15:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add bid manipulation protections:

1. Implement sealed-bid auctions with commit-reveal
2. Add minimum bid increments
3. Use time-weighted bidding
4. Implement bid bonds to prevent spam

âš ï¸  HIGH: Function 'addShareholder' in contract 'VulnerablePaymentSplitter' has DoS vulnerability: Unbounded push to array 'shareholders'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:37:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'register' in contract 'VulnerablePaymentSplitter' has DoS vulnerability: Unbounded push to array 'users'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:67:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'addRecipient' in contract 'VulnerablePaymentSplitter' has DoS vulnerability: Unbounded push to array 'recipients'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:101:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerablePaymentSplitter' iterates over unbounded array: Iteration over unbounded array 'shareholders'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:46:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerablePaymentSplitter' iterates over unbounded array: Iteration over unbounded array 'shareholders'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:50:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'reset' in contract 'VulnerablePaymentSplitter' iterates over unbounded array: Iteration over unbounded array 'users'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:74:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'getUserCount' in contract 'VulnerablePaymentSplitter' iterates over unbounded array: Iteration over unbounded array 'users'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:84:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'splitPayment' in contract 'VulnerablePaymentSplitter' iterates over unbounded array: Iteration over unbounded array 'recipients'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:109:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerablePaymentSplitter' performs gas-intensive operations in a loop. This can exceed block gas limit with large arrays.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:50:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Move gas-intensive operations outside loops:

1. Use pull pattern for transfers
2. Batch operations with limits
3. Use events for off-chain processing
4. Consider withdrawal patterns

âš ï¸  HIGH: Function 'splitPayment' in contract 'VulnerablePaymentSplitter' performs gas-intensive operations in a loop. This can exceed block gas limit with large arrays.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:109:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Move gas-intensive operations outside loops:

1. Use pull pattern for transfers
2. Batch operations with limits
3. Use events for off-chain processing
4. Consider withdrawal patterns

âš ï¸  HIGH: Contract 'VulnerablePaymentSplitter' has unbounded storage array 'shareholders'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:33:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Contract 'VulnerablePaymentSplitter' has unbounded storage array 'users'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:62:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Contract 'VulnerablePaymentSplitter' has unbounded storage array 'recipients'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:98:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerablePaymentSplitter' has DoS vulnerability: transfer() in loop. A single malicious or failing recipient can block the entire operation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:50:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use pull-over-push pattern:

// Instead of:
for (uint i = 0; i < recipients.length; i++) {
recipients[i].transfer(amounts[i]); // DoS risk
}

// Use:
mapping(address => uint256) pendingWithdrawals;

function withdraw() external {
uint256 amount = pendingWithdrawals[msg.sender];
pendingWithdrawals[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

âš ï¸  HIGH: Function 'splitPayment' in contract 'VulnerablePaymentSplitter' has DoS vulnerability: transfer() in loop. A single malicious or failing recipient can block the entire operation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:109:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use pull-over-push pattern:

// Instead of:
for (uint i = 0; i < recipients.length; i++) {
recipients[i].transfer(amounts[i]); // DoS risk
}

// Use:
mapping(address => uint256) pendingWithdrawals;

function withdraw() external {
uint256 amount = pendingWithdrawals[msg.sender];
pendingWithdrawals[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerablePaymentSplitter' uses push payment pattern for distribution. Single failing recipient will revert entire distribution.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:42:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Convert to pull payment pattern:

1. Store amounts in mapping instead of sending
2. Let recipients claim their share
3. Or use try-catch with failure tracking:

try recipient.call{value: amount}("") {
// success
} catch {
failedPayments[recipient] = amount;
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerablePaymentSplitter' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:46:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerablePaymentSplitter' has gas limit risk: Unbounded loop with gas-intensive operations. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:50:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'reset' in contract 'VulnerablePaymentSplitter' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:74:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'getUserCount' in contract 'VulnerablePaymentSplitter' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:84:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'splitPayment' in contract 'VulnerablePaymentSplitter' has gas limit risk: Unbounded loop with gas-intensive operations. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:109:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'bid' in contract 'VulnerablePaymentSplitter' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:20:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'VulnerablePaymentSplitter' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:52:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'splitPayment' in contract 'VulnerablePaymentSplitter' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:110:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'bid' in contract 'VulnerablePaymentSplitter' depends on external callback behavior. Malicious contracts can force reverts during callbacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:15:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use try-catch for external calls:

try externalContract.callback() {
// success path
} catch {
// failure path - handle gracefully
emit CallbackFailed(target);
}

ğŸ”¥ CRITICAL: Function 'bid' in contract 'MaliciousBidder' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:23:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'bid' in contract 'MaliciousBidder' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:24:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'MaliciousBidder' distributes rewards without vesting. Backrunners can deposit just before rewards and withdraw immediately after to capture disproportionate rewards.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:42:1
   â”œâ”€ Detector: backrunning-opportunity
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add vesting to reward distributions:

function notifyRewardAmount(uint256 reward) external {
rewardRate = reward / DURATION;
lastUpdateTime = block.timestamp;
periodFinish = block.timestamp + DURATION;
}

// Rewards vest over DURATION, preventing instant capture

âš ï¸  HIGH: Function 'bid' in contract 'MaliciousBidder' accepts bids without manipulation protection. Searchers can game the bidding process.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:15:1
   â”œâ”€ Detector: order-flow-auction-abuse
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add bid manipulation protections:

1. Implement sealed-bid auctions with commit-reveal
2. Add minimum bid increments
3. Use time-weighted bidding
4. Implement bid bonds to prevent spam

âš ï¸  HIGH: Function 'addShareholder' in contract 'MaliciousBidder' has DoS vulnerability: Unbounded push to array 'shareholders'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:37:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'register' in contract 'MaliciousBidder' has DoS vulnerability: Unbounded push to array 'users'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:67:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'addRecipient' in contract 'MaliciousBidder' has DoS vulnerability: Unbounded push to array 'recipients'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:101:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'distributeRewards' in contract 'MaliciousBidder' iterates over unbounded array: Iteration over unbounded array 'shareholders'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:46:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'distributeRewards' in contract 'MaliciousBidder' iterates over unbounded array: Iteration over unbounded array 'shareholders'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:50:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'reset' in contract 'MaliciousBidder' iterates over unbounded array: Iteration over unbounded array 'users'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:74:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'getUserCount' in contract 'MaliciousBidder' iterates over unbounded array: Iteration over unbounded array 'users'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:84:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'splitPayment' in contract 'MaliciousBidder' iterates over unbounded array: Iteration over unbounded array 'recipients'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:109:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'distributeRewards' in contract 'MaliciousBidder' performs gas-intensive operations in a loop. This can exceed block gas limit with large arrays.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:50:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Move gas-intensive operations outside loops:

1. Use pull pattern for transfers
2. Batch operations with limits
3. Use events for off-chain processing
4. Consider withdrawal patterns

âš ï¸  HIGH: Function 'splitPayment' in contract 'MaliciousBidder' performs gas-intensive operations in a loop. This can exceed block gas limit with large arrays.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:109:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Move gas-intensive operations outside loops:

1. Use pull pattern for transfers
2. Batch operations with limits
3. Use events for off-chain processing
4. Consider withdrawal patterns

âš ï¸  HIGH: Contract 'MaliciousBidder' has unbounded storage array 'shareholders'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:33:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Contract 'MaliciousBidder' has unbounded storage array 'users'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:62:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Contract 'MaliciousBidder' has unbounded storage array 'recipients'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:98:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Function 'distributeRewards' in contract 'MaliciousBidder' has DoS vulnerability: transfer() in loop. A single malicious or failing recipient can block the entire operation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:50:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use pull-over-push pattern:

// Instead of:
for (uint i = 0; i < recipients.length; i++) {
recipients[i].transfer(amounts[i]); // DoS risk
}

// Use:
mapping(address => uint256) pendingWithdrawals;

function withdraw() external {
uint256 amount = pendingWithdrawals[msg.sender];
pendingWithdrawals[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

âš ï¸  HIGH: Function 'splitPayment' in contract 'MaliciousBidder' has DoS vulnerability: transfer() in loop. A single malicious or failing recipient can block the entire operation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:109:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use pull-over-push pattern:

// Instead of:
for (uint i = 0; i < recipients.length; i++) {
recipients[i].transfer(amounts[i]); // DoS risk
}

// Use:
mapping(address => uint256) pendingWithdrawals;

function withdraw() external {
uint256 amount = pendingWithdrawals[msg.sender];
pendingWithdrawals[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'MaliciousBidder' uses push payment pattern for distribution. Single failing recipient will revert entire distribution.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:42:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Convert to pull payment pattern:

1. Store amounts in mapping instead of sending
2. Let recipients claim their share
3. Or use try-catch with failure tracking:

try recipient.call{value: amount}("") {
// success
} catch {
failedPayments[recipient] = amount;
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'MaliciousBidder' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:46:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'MaliciousBidder' has gas limit risk: Unbounded loop with gas-intensive operations. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:50:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'reset' in contract 'MaliciousBidder' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:74:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'getUserCount' in contract 'MaliciousBidder' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:84:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'splitPayment' in contract 'MaliciousBidder' has gas limit risk: Unbounded loop with gas-intensive operations. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:109:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'bid' in contract 'MaliciousBidder' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:20:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'distributeRewards' in contract 'MaliciousBidder' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:52:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'splitPayment' in contract 'MaliciousBidder' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:110:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'bid' in contract 'MaliciousBidder' depends on external callback behavior. Malicious contracts can force reverts during callbacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/DenialOfService.sol:15:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use try-catch for external calls:

try externalContract.callback() {
// success path
} catch {
// failure path - handle gracefully
emit CallbackFailed(target);
}

ğŸ”¥ CRITICAL: State variables modified after external call - potential reentrancy affecting state machine
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:30:9
   â”œâ”€ Detector: invalid-state-transition
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Use checks-effects-interactions pattern or reentrancy guards

âš¡ MEDIUM: External call in function 'submitSolution' does not check return value
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:23:14
   â”œâ”€ Detector: unchecked-external-call
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check the return value of external calls in function 'submitSolution'

âš ï¸  HIGH: Function 'submitSolution' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:23:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'submitSolution'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function 'submitSolution' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:23:14
   â”œâ”€ Detector: validator-front-running
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate validator front-running in 'submitSolution'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.

âš¡ MEDIUM: Function 'submitSolution' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:23:14
   â”œâ”€ Detector: gas-griefing
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Mitigate gas griefing in 'submitSolution'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.

ğŸ“ LOW: Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:15:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Variable initialized with constant value but not marked as constant/immutable. Use constant or immutable Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:43:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Variable initialized with constant value but not marked as constant/immutable. Use constant or immutable Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:44:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Variable initialized with constant value but not marked as constant/immutable. Use constant or immutable Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:83:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Function 'updatePrice' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:92:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Function 'transferFrom' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:136:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

âš ï¸  HIGH: Contract has centralization risk. Contract uses single owner without multi-signature protection. Single private key compromise leads to total contract control Single point of failure can lead to fund loss, governance attacks, or complete system compromise.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:1:0
   â”œâ”€ Detector: centralization-risk
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.

âš ï¸  HIGH: Function 'submitSolution' uses weak randomness source. Uses user address in randomness without commitment scheme. Users can predict outcomes and selectively participate Predictable randomness enables attackers to manipulate outcomes in lotteries, games, or selection processes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:23:14
   â”œâ”€ Detector: insufficient-randomness
   â”œâ”€ CWE: CWE-338
   â””â”€ Fix: Use secure randomness in 'submitSolution'. Implement: (1) Chainlink VRF for verifiable randomness, (2) Commit-reveal scheme with multi-block delay, (3) External oracle for random number generation, (4) Avoid block.timestamp, blockhash, or block.number, (5) Use Randao for Ethereum 2.0.

âš¡ MEDIUM: Token transfer lacks return data size validation - vulnerable to return bomb DOS
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:1:1
   â”œâ”€ Detector: erc20-transfer-return-bomb
   â””â”€ Fix: Check returndatasize() and reject if excessive (>64 bytes): require(returndatasize() <= 64)

âš ï¸  HIGH: Token price/exchange calculation without decimal normalization - incorrect conversions
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:1:1
   â”œâ”€ Detector: token-decimal-confusion
   â””â”€ Fix: Normalize decimals: amount * 10**token1.decimals() / 10**token2.decimals()

âš¡ MEDIUM: Static fees on AMM - no protection against toxic flow from informed traders
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:1:1
   â”œâ”€ Detector: mev-toxic-flow-exposure
   â””â”€ Fix: Implement dynamic fees that increase with volatility or trade size to discourage toxic flow

âš¡ MEDIUM: No trade size limits - large informed trades can extract maximum value from LPs
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:1:1
   â”œâ”€ Detector: mev-toxic-flow-exposure
   â””â”€ Fix: Add maximum trade size as percentage of reserves: require(amountIn < reserves * maxBps / 10000)

âš¡ MEDIUM: Instant arbitrage possible - informed traders can extract value with zero risk
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:1:1
   â”œâ”€ Detector: mev-toxic-flow-exposure
   â””â”€ Fix: Add block delay or use time-weighted pricing to reduce instant arbitrage opportunities

âš¡ MEDIUM: Swaps don't check oracle price - no protection against informed traders exploiting price deviations
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:1:1
   â”œâ”€ Detector: mev-toxic-flow-exposure
   â””â”€ Fix: Compare swap price against TWAP oracle; reject if deviation exceeds threshold

ğŸ”¥ CRITICAL: AMM function 'submitSolution' violates constant product invariant: Token transfers don't account for fee-on-transfer tokens, incorrect reserve calculations may result in pool drainage
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:23:14
   â”œâ”€ Detector: amm-k-invariant-violation
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Secure AMM function 'submitSolution': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks

ğŸ“ LOW: Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:2:0
   â”œâ”€ Detector: floating-pragma
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.

âš ï¸  HIGH: Potential division before multiplication - causes precision loss (OWASP 2025)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:1:0
   â”œâ”€ Detector: logic-error-patterns
   â””â”€ Fix: âŒ PRECISION LOSS ($63.8M in losses):
uint256 reward = (amount / totalSupply) * rewardRate;
// Result: 0 if amount < totalSupply!

âœ… CORRECT ORDER:
uint256 reward = (amount * rewardRate) / totalSupply;
// Maximizes precision, multiply before divide

âœ… BEST: Use fixed-point math:
uint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;

Real incidents:
- Cork Protocol: $11M (May 2025) - Division rounding
- SIR.trading: $355K (March 2025) - Reward calculation
- Multiple 2024 incidents: $63.8M total

âš¡ MEDIUM: Reward distribution logic detected - verify precision and rounding
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:1:0
   â”œâ”€ Detector: logic-error-patterns
   â””â”€ Fix: Common reward distribution errors:

1. Integer division truncation:
âŒ reward = balance / users;  // Loses remainder
âœ… reward = balance * 1e18 / users / 1e18;

2. Accumulating rounding errors:
âŒ Track individual rewards that sum != total
âœ… Use lastUser = total - sum(others)

3. Division before multiplication:
âŒ (balance / total) * multiplier
âœ… (balance * multiplier) / total

4. Missing remainder handling:
uint256 perUser = total / userCount;
uint256 remainder = total % userCount;
// Handle remainder explicitly!

âš¡ MEDIUM: Oracle price usage without time-weighted average - consider TWAP
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:1:0
   â”œâ”€ Detector: oracle-time-window-attack
   â””â”€ Fix: Single-block price oracles are manipulable:

âŒ Vulnerable patterns:
- Using spot price from DEX
- Single block price snapshot
- No time-weighting
- No price deviation checks

âœ… Recommended solutions:

1. Use Uniswap V3 TWAP (30+ minute window)
2. Use Chainlink Price Feeds (aggregated off-chain)
3. Combine multiple oracle sources
4. Implement price deviation bounds:
require(abs(newPrice - lastPrice) < maxDelta);
5. Use time-weighted moving average:
priceSum += currentPrice;
priceCount++;
avgPrice = priceSum / priceCount;

Minimum TWAP window: 30 minutes (longer is better)
Maximum price deviation: 2-5% from last update

âš¡ MEDIUM: Array access without length validation - can cause out-of-bounds access
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ MISSING ARRAY VALIDATION (OWASP 2025 - $14.6M impact):
function process(uint256[] calldata ids) external {
for (uint256 i = 0; i < ids.length; i++) {
// What if ids is empty? Or too large?
}
}

âœ… VALIDATE ARRAY LENGTH:
function process(uint256[] calldata ids) external {
// Check minimum length
require(ids.length > 0, "Empty array");

// Check maximum length (prevent DoS)
require(ids.length <= MAX_BATCH_SIZE, "Batch too large");

for (uint256 i = 0; i < ids.length; i++) {
// Safe to access ids[i]
}
}

âœ… VALIDATE ARRAY MATCHING:
function batchTransfer(
address[] calldata recipients,
uint256[] calldata amounts
) external {
// Arrays must match in length
require(
recipients.length == amounts.length,
"Length mismatch"
);
require(recipients.length > 0, "Empty arrays");
require(recipients.length <= MAX_BATCH, "Too many");

for (uint256 i = 0; i < recipients.length; i++) {
// Safe parallel access
}
}

âš¡ MEDIUM: Transfer function without zero-value check - validate non-zero amounts
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ MISSING ZERO-VALUE CHECK:
function transfer(address to, uint256 amount) external {
_transfer(msg.sender, to, amount);
// What if amount is 0? Wastes gas, may break accounting
}

âœ… VALIDATE NON-ZERO:
function transfer(address to, uint256 amount) external {
require(amount > 0, "Zero amount");
require(to != address(0), "Zero address");
_transfer(msg.sender, to, amount);
}

âœ… COMPLETE VALIDATION:
function deposit(uint256 amount) external payable {
// For ERC20 deposits
require(amount > 0, "Zero amount");
require(amount <= MAX_DEPOSIT, "Exceeds maximum");

// For native ETH deposits
if (msg.value > 0) {
require(msg.value == amount, "Value mismatch");
}

// Proceed with deposit
}

âš¡ MEDIUM: Address parameter without zero-address validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ MISSING ADDRESS VALIDATION:
function setOwner(address newOwner) external {
owner = newOwner;  // What if newOwner is address(0)?
}

âœ… VALIDATE ADDRESS:
function setOwner(address newOwner) external onlyOwner {
require(newOwner != address(0), "Zero address");
require(newOwner != owner, "Same address");
owner = newOwner;
}

âœ… VALIDATE MULTIPLE ADDRESSES:
function initialize(
address _token,
address _oracle,
address _treasury
) external {
require(_token != address(0), "Zero token");
require(_oracle != address(0), "Zero oracle");
require(_treasury != address(0), "Zero treasury");

// Check for duplicates if needed
require(_token != _oracle, "Token == oracle");
require(_token != _treasury, "Token == treasury");

token = _token;
oracle = _oracle;
treasury = _treasury;
}

âš¡ MEDIUM: Percentage/fee parameter without bounds validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ UNBOUNDED PERCENTAGE:
function setFee(uint256 newFee) external {
fee = newFee;  // Could be set to 100% or higher!
}

âœ… VALIDATE PERCENTAGE BOUNDS:
uint256 public constant MAX_FEE = 1000;  // 10% in basis points
uint256 public constant BASIS_POINTS = 10000;  // 100%

function setFee(uint256 newFee) external onlyOwner {
require(newFee <= MAX_FEE, "Fee too high");
fee = newFee;
}

âœ… COMPREHENSIVE RATIO VALIDATION:
function setCollateralRatio(uint256 ratio) external {
// Must be between 110% and 200%
uint256 MIN_RATIO = 11000;  // 110%
uint256 MAX_RATIO = 20000;  // 200%

require(ratio >= MIN_RATIO, "Ratio too low");
require(ratio <= MAX_RATIO, "Ratio too high");
collateralRatio = ratio;
}

âš ï¸  HIGH: Liquidity becomes active immediately - may enable JIT sandwich attacks
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:1:1
   â”œâ”€ Detector: jit-liquidity-sandwich
   â””â”€ Fix: Consider delaying liquidity activation to the next epoch or block to mitigate JIT attacks

âš¡ MEDIUM: No minimum staking duration enforced - allows instant reward farming
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:1:1
   â”œâ”€ Detector: yield-farming-manipulation
   â””â”€ Fix: Add minimum staking duration requirement before allowing reward claims

âš ï¸  HIGH: No minimum deposit requirement - small deposits may round down to zero shares
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:1:1
   â”œâ”€ Detector: pool-donation-enhanced
   â””â”€ Fix: Enforce minimum deposit amount or minimum shares minted to prevent rounding attacks

âš ï¸  HIGH: Pool initialization lacks protection - first depositor can manipulate initial share price
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:1:1
   â”œâ”€ Detector: pool-donation-enhanced
   â””â”€ Fix: Require minimum initial deposit, mint dead shares on initialization, or use time-delayed activation

âš ï¸  HIGH: Price oracle uses spot price without TWAP - vulnerable to flash loan price manipulation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:1:1
   â”œâ”€ Detector: amm-invariant-manipulation
   â””â”€ Fix: Implement time-weighted average price (TWAP) using cumulative price observations to resist manipulation

âš ï¸  HIGH: Swap function supports callbacks without reentrancy guard - vulnerable to reentrancy via flash swaps
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:1:1
   â”œâ”€ Detector: amm-invariant-manipulation
   â””â”€ Fix: Add reentrancy guard to swap function or validate invariants before and after callback execution

ğŸ”¥ CRITICAL: Function 'submitSolution' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:23:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'submitSolution'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

ğŸ”¥ CRITICAL: Function 'submitSolution' in contract 'VulnerablePuzzle' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:29:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'getSwapAmount' in contract 'VulnerablePuzzle' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:48:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'updatePrice' in contract 'VulnerablePuzzle' updates prices without backrun protection. Arbitrageurs can monitor for price updates and immediately backrun to profit from the price change.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:92:1
   â”œâ”€ Detector: backrunning-opportunity
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Implement backrun protection for price updates:

1. Use batch updates with commit-reveal:
function commitPriceUpdate(bytes32 hash) external;
function revealPriceUpdate(uint256 price, bytes32 salt) external;

2. Use time-weighted average prices (TWAP)
3. Add smoothing to prevent instant large changes
4. Use frequent small updates instead of rare large ones

âš ï¸  HIGH: Function 'updatePrice' in contract 'VulnerablePuzzle' updates oracle prices without MEV protection. Searchers can front-run price updates to profit from the change.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:92:1
   â”œâ”€ Detector: oracle-update-mev
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Protect oracle updates from front-running:

1. Use commit-reveal for price updates
2. Aggregate multiple oracle reports
3. Add delay between update and usage
4. Use pull-based oracles (Chainlink)
5. Implement price smoothing

âš ï¸  HIGH: Constructor in contract 'VulnerablePuzzle' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:17:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerablePuzzle' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:87:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerablePuzzle' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:120:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'submitSolution' in contract 'VulnerablePuzzle' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:27:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

âš ï¸  HIGH: Function 'getSwapAmount' in contract 'VulnerablePuzzle' is vulnerable to sequencer MEV: Swap without slippage protection. L2 sequencers can reorder transactions for profit extraction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:47:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate sequencer MEV:

1. Implement slippage protection (minAmountOut)
2. Add transaction deadlines
3. Use commit-reveal schemes for sensitive operations
4. Consider private transaction pools
5. Implement fair sequencing protocols

âš ï¸  HIGH: Function 'getSwapAmount' in contract 'VulnerablePuzzle' is vulnerable to sequencer MEV: Swap without deadline protection. L2 sequencers can reorder transactions for profit extraction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:47:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate sequencer MEV:

1. Implement slippage protection (minAmountOut)
2. Add transaction deadlines
3. Use commit-reveal schemes for sensitive operations
4. Consider private transaction pools
5. Implement fair sequencing protocols

âš ï¸  HIGH: Function 'swapAforB' in contract 'VulnerablePuzzle' is vulnerable to sequencer MEV: Swap without slippage protection. L2 sequencers can reorder transactions for profit extraction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:56:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate sequencer MEV:

1. Implement slippage protection (minAmountOut)
2. Add transaction deadlines
3. Use commit-reveal schemes for sensitive operations
4. Consider private transaction pools
5. Implement fair sequencing protocols

âš ï¸  HIGH: Function 'swapAforB' in contract 'VulnerablePuzzle' is vulnerable to sequencer MEV: Swap without deadline protection. L2 sequencers can reorder transactions for profit extraction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:56:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate sequencer MEV:

1. Implement slippage protection (minAmountOut)
2. Add transaction deadlines
3. Use commit-reveal schemes for sensitive operations
4. Consider private transaction pools
5. Implement fair sequencing protocols

âš ï¸  HIGH: Function 'submitSolution' in contract 'VulnerablePuzzle' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:30:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

ğŸ“ LOW: Parameter '_tokenAAmount' of type 'uint' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:56:32
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_tokenAAmount > 0, "Amount must be positive");

âš ï¸  HIGH: Function 'getSwapAmount' vulnerable to price impact manipulation. No maximum trade size limit enforced, allowing trades of any size that can cause extreme price impact and drain pool liquidity Large trades without size limits or impact checks can drain liquidity, manipulate prices, and cause excessive slippage for other users.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:47:14
   â”œâ”€ Detector: price-impact-manipulation
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add price impact protection to 'getSwapAmount'. Implement maximum trade size limits (e.g., max 10% of pool), calculate and validate price impact percentage, enforce minimum output amounts with slippage tolerance, or split large trades across multiple blocks.

âš ï¸  HIGH: Function 'swapAforB' vulnerable to price impact manipulation. No maximum trade size limit enforced, allowing trades of any size that can cause extreme price impact and drain pool liquidity Large trades without size limits or impact checks can drain liquidity, manipulate prices, and cause excessive slippage for other users.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:56:14
   â”œâ”€ Detector: price-impact-manipulation
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add price impact protection to 'swapAforB'. Implement maximum trade size limits (e.g., max 10% of pool), calculate and validate price impact percentage, enforce minimum output amounts with slippage tolerance, or split large trades across multiple blocks.

âš ï¸  HIGH: Function 'getSwapAmount' lacks sandwich attack protection. No minimum output amount (amountOutMin) parameter for slippage protection, leaving swap vulnerable to sandwich attacks MEV bots can front-run user swaps, manipulate price, then back-run to profit from the price difference at user's expense.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:47:14
   â”œâ”€ Detector: sandwich-resistant-swap
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add sandwich attack protection to 'getSwapAmount'. Implement: (1) Slippage tolerance with amountOutMin parameter, (2) Commit-reveal scheme for swap parameters, (3) Private mempool submission, (4) MEV-resistant AMM curve, (5) Batch auctions instead of continuous trading.

âš ï¸  HIGH: Function 'swapAforB' lacks sandwich attack protection. No deadline parameter to prevent delayed execution, allowing validators to hold and execute swap at unfavorable prices MEV bots can front-run user swaps, manipulate price, then back-run to profit from the price difference at user's expense.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:56:14
   â”œâ”€ Detector: sandwich-resistant-swap
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add sandwich attack protection to 'swapAforB'. Implement: (1) Slippage tolerance with amountOutMin parameter, (2) Commit-reveal scheme for swap parameters, (3) Private mempool submission, (4) MEV-resistant AMM curve, (5) Batch auctions instead of continuous trading.

âš ï¸  HIGH: Function 'swapAforB' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:56:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'swapAforB'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function 'deposit' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:71:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'deposit'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function 'swapAforB' has validator front-running vulnerability. Price-sensitive operations without fair sequencing, validators can reorder transactions for MEV extraction Validators can observe pending transactions and extract value by front-running users.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:56:14
   â”œâ”€ Detector: validator-front-running
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate validator front-running in 'swapAforB'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.

âš¡ MEDIUM: Function 'swapAforB' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:56:14
   â”œâ”€ Detector: gas-griefing
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Mitigate gas griefing in 'swapAforB'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.

âš ï¸  HIGH: Function 'swapAforB' lacks front-running protection. Trading function 'swapAforB' missing slippage protection (minAmountOut). Vulnerable to sandwich attacks Front-runners can extract MEV by observing mempool and inserting their transactions before yours.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:56:14
   â”œâ”€ Detector: front-running-mitigation
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add front-running protection to 'swapAforB'. Implement: (1) Commit-reveal scheme with time delay, (2) Deadline parameter for transaction validity, (3) Minimum output amount (slippage protection), (4) Batch auctions or frequent batch auctions (FBA), (5) Private mempool (Flashbots Protect), (6) Time-weighted average pricing (TWAP).

âš¡ MEDIUM: Function 'getSwapAmount' contains variable shadowing. Local variable 'k' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:47:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'getSwapAmount'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Function 'getSwapAmount' contains variable shadowing. Local variable 'newTokenAReserve' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:47:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'getSwapAmount'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Function 'getSwapAmount' contains variable shadowing. Local variable 'newTokenBReserve' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:47:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'getSwapAmount'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

ğŸ”¥ CRITICAL: No reentrancy protection (flash loan attack risk) in 'getSwapAmount'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:47:0
   â”œâ”€ Detector: defi-liquidity-pool-manipulation
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add reentrancy guard: modifier nonReentrant or use ReentrancyGuard from OpenZeppelin

âš¡ MEDIUM: Missing deadline parameter (stuck transaction risk) in 'getSwapAmount'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:47:0
   â”œâ”€ Detector: defi-liquidity-pool-manipulation
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline: require(block.timestamp <= deadline, "Transaction expired");

ğŸ”¥ CRITICAL: No reentrancy protection (flash loan attack risk) in 'swapAforB'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:56:0
   â”œâ”€ Detector: defi-liquidity-pool-manipulation
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add reentrancy guard: modifier nonReentrant or use ReentrancyGuard from OpenZeppelin

âš¡ MEDIUM: Missing deadline parameter (stuck transaction risk) in 'swapAforB'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:56:0
   â”œâ”€ Detector: defi-liquidity-pool-manipulation
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline: require(block.timestamp <= deadline, "Transaction expired");

ğŸ”¥ CRITICAL: No first depositor protection (inflation attack on vault initialization) in 'deposit'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:71:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Lock initial shares: if (totalSupply() == 0) { _mint(address(0), INITIAL_SHARES); }

ğŸ“ LOW: No deposit cap (unlimited exposure risk) in 'deposit'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:71:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add cap: require(totalAssets() + amount <= depositCap, "Cap exceeded");

âš¡ MEDIUM: Function 'swapAforB' is missing transaction deadline. Missing transaction deadline. Swap operation 'swapAforB' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:56:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'swapAforB'. Implement: (1) Add 'deadline' parameter: function swapAforB(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

ğŸ”¥ CRITICAL: AMM function 'getSwapAmount' violates constant product invariant: Swap lacks slippage protection (minAmountOut parameter), users vulnerable to sandwich attacks and MEV
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:47:14
   â”œâ”€ Detector: amm-k-invariant-violation
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Secure AMM function 'getSwapAmount': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks

ğŸ”¥ CRITICAL: AMM function 'swapAforB' violates constant product invariant: Swap lacks deadline parameter, transactions may execute at unfavorable prices if delayed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:56:14
   â”œâ”€ Detector: amm-k-invariant-violation
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Secure AMM function 'swapAforB': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks

ğŸ”¥ CRITICAL: Function 'submitSolution' in contract 'VulnerableDEX' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:29:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'getSwapAmount' in contract 'VulnerableDEX' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:48:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'updatePrice' in contract 'VulnerableDEX' updates prices without backrun protection. Arbitrageurs can monitor for price updates and immediately backrun to profit from the price change.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:92:1
   â”œâ”€ Detector: backrunning-opportunity
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Implement backrun protection for price updates:

1. Use batch updates with commit-reveal:
function commitPriceUpdate(bytes32 hash) external;
function revealPriceUpdate(uint256 price, bytes32 salt) external;

2. Use time-weighted average prices (TWAP)
3. Add smoothing to prevent instant large changes
4. Use frequent small updates instead of rare large ones

âš ï¸  HIGH: Function 'updatePrice' in contract 'VulnerableDEX' updates oracle prices without MEV protection. Searchers can front-run price updates to profit from the change.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:92:1
   â”œâ”€ Detector: oracle-update-mev
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Protect oracle updates from front-running:

1. Use commit-reveal for price updates
2. Aggregate multiple oracle reports
3. Add delay between update and usage
4. Use pull-based oracles (Chainlink)
5. Implement price smoothing

âš ï¸  HIGH: Constructor in contract 'VulnerableDEX' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:17:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableDEX' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:87:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableDEX' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:120:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'submitSolution' in contract 'VulnerableDEX' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:27:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

âš ï¸  HIGH: Function 'getSwapAmount' in contract 'VulnerableDEX' is vulnerable to sequencer MEV: Swap without slippage protection. L2 sequencers can reorder transactions for profit extraction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:47:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate sequencer MEV:

1. Implement slippage protection (minAmountOut)
2. Add transaction deadlines
3. Use commit-reveal schemes for sensitive operations
4. Consider private transaction pools
5. Implement fair sequencing protocols

âš ï¸  HIGH: Function 'getSwapAmount' in contract 'VulnerableDEX' is vulnerable to sequencer MEV: Swap without deadline protection. L2 sequencers can reorder transactions for profit extraction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:47:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate sequencer MEV:

1. Implement slippage protection (minAmountOut)
2. Add transaction deadlines
3. Use commit-reveal schemes for sensitive operations
4. Consider private transaction pools
5. Implement fair sequencing protocols

âš ï¸  HIGH: Function 'swapAforB' in contract 'VulnerableDEX' is vulnerable to sequencer MEV: Swap without slippage protection. L2 sequencers can reorder transactions for profit extraction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:56:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate sequencer MEV:

1. Implement slippage protection (minAmountOut)
2. Add transaction deadlines
3. Use commit-reveal schemes for sensitive operations
4. Consider private transaction pools
5. Implement fair sequencing protocols

âš ï¸  HIGH: Function 'swapAforB' in contract 'VulnerableDEX' is vulnerable to sequencer MEV: Swap without deadline protection. L2 sequencers can reorder transactions for profit extraction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:56:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate sequencer MEV:

1. Implement slippage protection (minAmountOut)
2. Add transaction deadlines
3. Use commit-reveal schemes for sensitive operations
4. Consider private transaction pools
5. Implement fair sequencing protocols

âš ï¸  HIGH: Function 'submitSolution' in contract 'VulnerableDEX' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:30:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

ğŸ“ LOW: Parameter '_newPrice' of type 'uint' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:92:34
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Add appropriate range validation for _newPrice

âš ï¸  HIGH: Function 'updatePrice' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:92:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'updatePrice'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function 'buyTokens' lacks front-running protection. Trading function 'buyTokens' missing slippage protection (minAmountOut). Vulnerable to sandwich attacks Front-runners can extract MEV by observing mempool and inserting their transactions before yours.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:98:14
   â”œâ”€ Detector: front-running-mitigation
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add front-running protection to 'buyTokens'. Implement: (1) Commit-reveal scheme with time delay, (2) Deadline parameter for transaction validity, (3) Minimum output amount (slippage protection), (4) Batch auctions or frequent batch auctions (FBA), (5) Private mempool (Flashbots Protect), (6) Time-weighted average pricing (TWAP).

âš¡ MEDIUM: Function 'updatePrice' contains variable shadowing. Parameter 'owner' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:92:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'updatePrice'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Function 'buyTokens' contains variable shadowing. Parameter 'tokensAvailable' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:98:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'buyTokens'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš ï¸  HIGH: Reward update doesn't handle zero totalSupply (division by zero) in 'updatePrice'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:92:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Handle zero: if (totalSupply() > 0) { rewardPerToken = ...; }

âš¡ MEDIUM: Function 'buyTokens' is missing transaction deadline. Missing transaction deadline. Purchase/Sale operation 'buyTokens' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:98:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'buyTokens'. Implement: (1) Add 'deadline' parameter: function buyTokens(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

ğŸ”¥ CRITICAL: Function 'submitSolution' in contract 'VulnerableICO' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:29:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'getSwapAmount' in contract 'VulnerableICO' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:48:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'updatePrice' in contract 'VulnerableICO' updates prices without backrun protection. Arbitrageurs can monitor for price updates and immediately backrun to profit from the price change.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:92:1
   â”œâ”€ Detector: backrunning-opportunity
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Implement backrun protection for price updates:

1. Use batch updates with commit-reveal:
function commitPriceUpdate(bytes32 hash) external;
function revealPriceUpdate(uint256 price, bytes32 salt) external;

2. Use time-weighted average prices (TWAP)
3. Add smoothing to prevent instant large changes
4. Use frequent small updates instead of rare large ones

âš ï¸  HIGH: Function 'updatePrice' in contract 'VulnerableICO' updates oracle prices without MEV protection. Searchers can front-run price updates to profit from the change.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:92:1
   â”œâ”€ Detector: oracle-update-mev
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Protect oracle updates from front-running:

1. Use commit-reveal for price updates
2. Aggregate multiple oracle reports
3. Add delay between update and usage
4. Use pull-based oracles (Chainlink)
5. Implement price smoothing

âš ï¸  HIGH: Constructor in contract 'VulnerableICO' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:17:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableICO' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:87:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableICO' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:120:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'submitSolution' in contract 'VulnerableICO' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:27:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

âš ï¸  HIGH: Function 'getSwapAmount' in contract 'VulnerableICO' is vulnerable to sequencer MEV: Swap without slippage protection. L2 sequencers can reorder transactions for profit extraction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:47:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate sequencer MEV:

1. Implement slippage protection (minAmountOut)
2. Add transaction deadlines
3. Use commit-reveal schemes for sensitive operations
4. Consider private transaction pools
5. Implement fair sequencing protocols

âš ï¸  HIGH: Function 'getSwapAmount' in contract 'VulnerableICO' is vulnerable to sequencer MEV: Swap without deadline protection. L2 sequencers can reorder transactions for profit extraction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:47:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate sequencer MEV:

1. Implement slippage protection (minAmountOut)
2. Add transaction deadlines
3. Use commit-reveal schemes for sensitive operations
4. Consider private transaction pools
5. Implement fair sequencing protocols

âš ï¸  HIGH: Function 'swapAforB' in contract 'VulnerableICO' is vulnerable to sequencer MEV: Swap without slippage protection. L2 sequencers can reorder transactions for profit extraction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:56:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate sequencer MEV:

1. Implement slippage protection (minAmountOut)
2. Add transaction deadlines
3. Use commit-reveal schemes for sensitive operations
4. Consider private transaction pools
5. Implement fair sequencing protocols

âš ï¸  HIGH: Function 'swapAforB' in contract 'VulnerableICO' is vulnerable to sequencer MEV: Swap without deadline protection. L2 sequencers can reorder transactions for profit extraction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:56:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate sequencer MEV:

1. Implement slippage protection (minAmountOut)
2. Add transaction deadlines
3. Use commit-reveal schemes for sensitive operations
4. Consider private transaction pools
5. Implement fair sequencing protocols

âš ï¸  HIGH: Function 'submitSolution' in contract 'VulnerableICO' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:30:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

ğŸ“ LOW: Parameter '_spender' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:125:30
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_spender != address(0), "Invalid address");

ğŸ“ LOW: Parameter '_amount' of type 'uint' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:125:48
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_amount > 0, "Amount must be positive");

âš ï¸  HIGH: Parameter '_from' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:136:35
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_from != address(0), "Invalid address");

âš ï¸  HIGH: Parameter '_to' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:136:50
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_to != address(0), "Invalid address");

âš ï¸  HIGH: Function 'approve' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:125:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'approve'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

ğŸ“ LOW: Function 'transferFrom' contains excessive gas usage pattern. Multiple storage reads detected (9). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:136:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'transferFrom'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ”¥ CRITICAL: AMM function 'approve' violates constant product invariant: Token transfers don't account for fee-on-transfer tokens, incorrect reserve calculations may result in pool drainage
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:125:14
   â”œâ”€ Detector: amm-k-invariant-violation
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Secure AMM function 'approve': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks

ğŸ”¥ CRITICAL: Function 'submitSolution' in contract 'VulnerableERC20' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:29:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'getSwapAmount' in contract 'VulnerableERC20' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:48:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'updatePrice' in contract 'VulnerableERC20' updates prices without backrun protection. Arbitrageurs can monitor for price updates and immediately backrun to profit from the price change.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:92:1
   â”œâ”€ Detector: backrunning-opportunity
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Implement backrun protection for price updates:

1. Use batch updates with commit-reveal:
function commitPriceUpdate(bytes32 hash) external;
function revealPriceUpdate(uint256 price, bytes32 salt) external;

2. Use time-weighted average prices (TWAP)
3. Add smoothing to prevent instant large changes
4. Use frequent small updates instead of rare large ones

âš ï¸  HIGH: Function 'updatePrice' in contract 'VulnerableERC20' updates oracle prices without MEV protection. Searchers can front-run price updates to profit from the change.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:92:1
   â”œâ”€ Detector: oracle-update-mev
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Protect oracle updates from front-running:

1. Use commit-reveal for price updates
2. Aggregate multiple oracle reports
3. Add delay between update and usage
4. Use pull-based oracles (Chainlink)
5. Implement price smoothing

âš ï¸  HIGH: Constructor in contract 'VulnerableERC20' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:17:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableERC20' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:87:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableERC20' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:120:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'submitSolution' in contract 'VulnerableERC20' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:27:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

âš ï¸  HIGH: Function 'getSwapAmount' in contract 'VulnerableERC20' is vulnerable to sequencer MEV: Swap without slippage protection. L2 sequencers can reorder transactions for profit extraction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:47:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate sequencer MEV:

1. Implement slippage protection (minAmountOut)
2. Add transaction deadlines
3. Use commit-reveal schemes for sensitive operations
4. Consider private transaction pools
5. Implement fair sequencing protocols

âš ï¸  HIGH: Function 'getSwapAmount' in contract 'VulnerableERC20' is vulnerable to sequencer MEV: Swap without deadline protection. L2 sequencers can reorder transactions for profit extraction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:47:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate sequencer MEV:

1. Implement slippage protection (minAmountOut)
2. Add transaction deadlines
3. Use commit-reveal schemes for sensitive operations
4. Consider private transaction pools
5. Implement fair sequencing protocols

âš ï¸  HIGH: Function 'swapAforB' in contract 'VulnerableERC20' is vulnerable to sequencer MEV: Swap without slippage protection. L2 sequencers can reorder transactions for profit extraction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:56:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate sequencer MEV:

1. Implement slippage protection (minAmountOut)
2. Add transaction deadlines
3. Use commit-reveal schemes for sensitive operations
4. Consider private transaction pools
5. Implement fair sequencing protocols

âš ï¸  HIGH: Function 'swapAforB' in contract 'VulnerableERC20' is vulnerable to sequencer MEV: Swap without deadline protection. L2 sequencers can reorder transactions for profit extraction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:56:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate sequencer MEV:

1. Implement slippage protection (minAmountOut)
2. Add transaction deadlines
3. Use commit-reveal schemes for sensitive operations
4. Consider private transaction pools
5. Implement fair sequencing protocols

âš ï¸  HIGH: Function 'submitSolution' in contract 'VulnerableERC20' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/FrontRunning.sol:30:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'withdraw' may be vulnerable to reentrancy attacks due to state changes after external calls
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:14
   â”œâ”€ Detector: classic-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Apply checks-effects-interactions pattern or use a reentrancy guard in function 'withdraw'

âš¡ MEDIUM: View function 'getBalance' reads state that may be inconsistent during reentrancy. Contract has state-changing functions that make external calls before updating state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:31:14
   â”œâ”€ Detector: readonly-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Add a reentrancy guard to state-changing functions or ensure view function 'getBalance' cannot be called during callbacks (e.g., using a reentrancy lock check in the view function)

âš ï¸  HIGH: Function 'withdraw' may be vulnerable to withdrawal DOS attack. Withdrawal requires successful external call. Failing calls can permanently block withdrawals. Consider using pull-over-push pattern Attacker can block withdrawals, causing funds to be locked indefinitely.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:14
   â”œâ”€ Detector: vault-withdrawal-dos
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Protect 'withdraw' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.

âš ï¸  HIGH: Function 'withdraw' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'withdraw'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš¡ MEDIUM: Function 'withdraw' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:14
   â”œâ”€ Detector: gas-griefing
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Mitigate gas griefing in 'withdraw'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.

ğŸ“ LOW: Function 'withdraw' contains excessive gas usage pattern. Multiple storage reads detected (5). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'withdraw'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Inefficient storage pattern detected. Function 'withdraw' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

âš ï¸  HIGH: Contract has centralization risk. Critical operations (withdraw/pause/upgrade) lack timelock delays. Malicious owner can drain funds or brick contract instantly Single point of failure can lead to fund loss, governance attacks, or complete system compromise.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:1:0
   â”œâ”€ Detector: centralization-risk
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.

âš¡ MEDIUM: Function 'withdraw' contains variable shadowing. Parameter 'amount' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'withdraw'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Function 'withdraw' contains variable shadowing. Local variable 'amount' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'withdraw'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Function 'withdraw' is missing transaction deadline. Missing transaction deadline. Withdrawal operation 'withdraw' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'withdraw'. Implement: (1) Add 'deadline' parameter: function withdraw(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

ğŸ“ LOW: Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:2:0
   â”œâ”€ Detector: floating-pragma
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.

ğŸ”¥ CRITICAL: Vulnerable to transient storage reentrancy in 'withdraw' - transfer()/send() no longer safe with EIP-1153
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:0
   â”œâ”€ Detector: transient-storage-reentrancy
   â””â”€ Fix: EIP-1153 breaks transfer()/send() safety assumption:

CRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within
the 2300 gas stipend of transfer() and send().

Fix 1: Use checks-effects-interactions pattern
function withdraw() public {
uint256 amount = balances[msg.sender];
require(amount > 0);

// âœ… Update state BEFORE external call
balances[msg.sender] = 0;

payable(msg.sender).transfer(amount);
}

Fix 2: Use ReentrancyGuard
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

function withdraw() public nonReentrant {
uint256 amount = balances[msg.sender];
require(amount > 0);

balances[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

Reference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)

âš ï¸  HIGH: Potential division before multiplication - causes precision loss (OWASP 2025)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:1:0
   â”œâ”€ Detector: logic-error-patterns
   â””â”€ Fix: âŒ PRECISION LOSS ($63.8M in losses):
uint256 reward = (amount / totalSupply) * rewardRate;
// Result: 0 if amount < totalSupply!

âœ… CORRECT ORDER:
uint256 reward = (amount * rewardRate) / totalSupply;
// Maximizes precision, multiply before divide

âœ… BEST: Use fixed-point math:
uint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;

Real incidents:
- Cork Protocol: $11M (May 2025) - Division rounding
- SIR.trading: $355K (March 2025) - Reward calculation
- Multiple 2024 incidents: $63.8M total

âš¡ MEDIUM: Array access without length validation - can cause out-of-bounds access
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ MISSING ARRAY VALIDATION (OWASP 2025 - $14.6M impact):
function process(uint256[] calldata ids) external {
for (uint256 i = 0; i < ids.length; i++) {
// What if ids is empty? Or too large?
}
}

âœ… VALIDATE ARRAY LENGTH:
function process(uint256[] calldata ids) external {
// Check minimum length
require(ids.length > 0, "Empty array");

// Check maximum length (prevent DoS)
require(ids.length <= MAX_BATCH_SIZE, "Batch too large");

for (uint256 i = 0; i < ids.length; i++) {
// Safe to access ids[i]
}
}

âœ… VALIDATE ARRAY MATCHING:
function batchTransfer(
address[] calldata recipients,
uint256[] calldata amounts
) external {
// Arrays must match in length
require(
recipients.length == amounts.length,
"Length mismatch"
);
require(recipients.length > 0, "Empty arrays");
require(recipients.length <= MAX_BATCH, "Too many");

for (uint256 i = 0; i < recipients.length; i++) {
// Safe parallel access
}
}

âš¡ MEDIUM: Address parameter without zero-address validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ MISSING ADDRESS VALIDATION:
function setOwner(address newOwner) external {
owner = newOwner;  // What if newOwner is address(0)?
}

âœ… VALIDATE ADDRESS:
function setOwner(address newOwner) external onlyOwner {
require(newOwner != address(0), "Zero address");
require(newOwner != owner, "Same address");
owner = newOwner;
}

âœ… VALIDATE MULTIPLE ADDRESSES:
function initialize(
address _token,
address _oracle,
address _treasury
) external {
require(_token != address(0), "Zero token");
require(_oracle != address(0), "Zero oracle");
require(_treasury != address(0), "Zero treasury");

// Check for duplicates if needed
require(_token != _oracle, "Token == oracle");
require(_token != _treasury, "Token == treasury");

token = _token;
oracle = _oracle;
treasury = _treasury;
}

âš ï¸  HIGH: Liquidity removal without time-lock protection - vulnerable to JIT attacks
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:1:1
   â”œâ”€ Detector: jit-liquidity-sandwich
   â””â”€ Fix: Add a minimum lock time for liquidity positions (e.g., 1 block or epoch-based system) to prevent JIT liquidity attacks

âš ï¸  HIGH: Liquidity becomes active immediately - may enable JIT sandwich attacks
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:1:1
   â”œâ”€ Detector: jit-liquidity-sandwich
   â””â”€ Fix: Consider delaying liquidity activation to the next epoch or block to mitigate JIT attacks

âš ï¸  HIGH: No minimum deposit requirement - small deposits may round down to zero shares
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:1:1
   â”œâ”€ Detector: pool-donation-enhanced
   â””â”€ Fix: Enforce minimum deposit amount or minimum shares minted to prevent rounding attacks

âš ï¸  HIGH: Pool initialization lacks protection - first depositor can manipulate initial share price
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:1:1
   â”œâ”€ Detector: pool-donation-enhanced
   â””â”€ Fix: Require minimum initial deposit, mint dead shares on initialization, or use time-delayed activation

ğŸ”¥ CRITICAL: Function 'withdraw' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'withdraw'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableBank' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:24:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableBank' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:28:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableBank' has sweeper-like naming and contains asset transfers. If used as an EIP-7702 delegation target, this could allow draining all assets from the delegating EOA.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: If this is a legitimate rescue function:

1. Add strict access control (onlyOwner, multi-sig)
2. Add timelock delays for large withdrawals
3. Emit events for all asset movements
4. Consider withdrawal limits
5. Document the function's intended use

NEVER use as EIP-7702 delegation target without safeguards.

ğŸ”¥ CRITICAL: Contract 'VulnerableBank' allows instant liquidity add/remove without time lock. Attackers can perform JIT liquidity attacks by adding liquidity just before large swaps and removing immediately after to capture fees.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:14:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add time lock for liquidity operations:

mapping(address => uint256) public depositTime;
uint256 public constant MIN_LOCK_TIME = 1 hours;

function addLiquidity(uint256 amount) external {
depositTime[msg.sender] = block.timestamp;
// ... add liquidity
}

function removeLiquidity(uint256 shares) external {
require(
block.timestamp >= depositTime[msg.sender] + MIN_LOCK_TIME,
"Liquidity locked"
);
// ... remove liquidity
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableBank' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

ğŸ”¥ CRITICAL: Function 'unknown' in contract 'VulnerableBank' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:54:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

âš ï¸  HIGH: Function 'withdraw' in contract 'VulnerableBank' has withdrawal race vulnerability. State changes during withdrawal period can be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:1
   â”œâ”€ Detector: cross-l2-frontrunning
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add withdrawal protection:

1. Use pending/confirmed state pattern
2. Lock funds during withdrawal period
3. Add delay before withdrawal completion
4. Implement challenge mechanism

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableBank' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableBank' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

âš ï¸  HIGH: Function 'withdraw' in contract 'VulnerableBank' may be vulnerable to cross-chain double-spend. Balances updated before cross-chain confirmation could be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:1
   â”œâ”€ Detector: cross-rollup-state-mismatch
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Prevent double-spending:

1. Lock funds during cross-chain transfers
2. Use pending/confirmed state pattern
3. Implement nullifiers for withdrawal claims
4. Update balances only after confirmation

âš ï¸  HIGH: Function 'withdraw' in contract 'VulnerableBank' depends on external callback behavior. Malicious contracts can force reverts during callbacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use try-catch for external calls:

try externalContract.callback() {
// success path
} catch {
// failure path - handle gracefully
emit CallbackFailed(target);
}

âš ï¸  HIGH: Function 'withdraw' in contract 'VulnerableBank' forwards unlimited gas to external call. Recipient can consume all gas causing out-of-gas revert.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:24:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit gas for external calls:

// Limit gas to prevent griefing
(bool success, ) = recipient.call{value: amount, gas: 10000}("");

// Or use transfer() which limits gas to 2300

âš ï¸  HIGH: Function 'attack' relies on a single oracle source, creating centralization risk
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:48:14
   â”œâ”€ Detector: single-oracle-source
   â”œâ”€ CWE: CWE-693
   â””â”€ Fix: Use multiple oracle sources and implement price aggregation in function 'attack'

âš¡ MEDIUM: External call in function 'attack' does not check return value
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:48:14
   â”œâ”€ Detector: unchecked-external-call
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check the return value of external calls in function 'attack'

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'ReentrancyAttacker' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:24:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'ReentrancyAttacker' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:28:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'ReentrancyAttacker' has sweeper-like naming and contains asset transfers. If used as an EIP-7702 delegation target, this could allow draining all assets from the delegating EOA.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: If this is a legitimate rescue function:

1. Add strict access control (onlyOwner, multi-sig)
2. Add timelock delays for large withdrawals
3. Emit events for all asset movements
4. Consider withdrawal limits
5. Document the function's intended use

NEVER use as EIP-7702 delegation target without safeguards.

ğŸ”¥ CRITICAL: Contract 'ReentrancyAttacker' allows instant liquidity add/remove without time lock. Attackers can perform JIT liquidity attacks by adding liquidity just before large swaps and removing immediately after to capture fees.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:14:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add time lock for liquidity operations:

mapping(address => uint256) public depositTime;
uint256 public constant MIN_LOCK_TIME = 1 hours;

function addLiquidity(uint256 amount) external {
depositTime[msg.sender] = block.timestamp;
// ... add liquidity
}

function removeLiquidity(uint256 shares) external {
require(
block.timestamp >= depositTime[msg.sender] + MIN_LOCK_TIME,
"Liquidity locked"
);
// ... remove liquidity
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'ReentrancyAttacker' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

ğŸ”¥ CRITICAL: Function 'unknown' in contract 'ReentrancyAttacker' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:54:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

âš ï¸  HIGH: Function 'withdraw' in contract 'ReentrancyAttacker' has withdrawal race vulnerability. State changes during withdrawal period can be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:1
   â”œâ”€ Detector: cross-l2-frontrunning
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add withdrawal protection:

1. Use pending/confirmed state pattern
2. Lock funds during withdrawal period
3. Add delay before withdrawal completion
4. Implement challenge mechanism

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'ReentrancyAttacker' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'ReentrancyAttacker' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

âš ï¸  HIGH: Function 'withdraw' in contract 'ReentrancyAttacker' may be vulnerable to cross-chain double-spend. Balances updated before cross-chain confirmation could be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:1
   â”œâ”€ Detector: cross-rollup-state-mismatch
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Prevent double-spending:

1. Lock funds during cross-chain transfers
2. Use pending/confirmed state pattern
3. Implement nullifiers for withdrawal claims
4. Update balances only after confirmation

âš ï¸  HIGH: Function 'withdraw' in contract 'ReentrancyAttacker' depends on external callback behavior. Malicious contracts can force reverts during callbacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:19:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use try-catch for external calls:

try externalContract.callback() {
// success path
} catch {
// failure path - handle gracefully
emit CallbackFailed(target);
}

âš ï¸  HIGH: Function 'withdraw' in contract 'ReentrancyAttacker' forwards unlimited gas to external call. Recipient can consume all gas causing out-of-gas revert.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/Reentrancy.sol:24:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit gas for external calls:

// Limit gas to prevent griefing
(bool success, ) = recipient.call{value: amount, gas: 10000}("");

// Or use transfer() which limits gas to 2300

âš ï¸  HIGH: Parameter '_to' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:30:31
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_to != address(0), "Invalid address");

âš¡ MEDIUM: Parameter '_receivers' of type 'array' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:43:45
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_receivers.length > 0, "Array cannot be empty");

ğŸ“ LOW: Parameter '_value' of type 'uint' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:43:65
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Add appropriate range validation for _value

ğŸ”¥ CRITICAL: Function '' has batch transfer overflow vulnerability. Multiplication of array length with value (count * value) can overflow in Solidity <0.8.0 or in unchecked blocks, bypassing balance checks and allowing unlimited token minting. This was exploited in the BeautyChain (BEC) token hack causing $1B in damage.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:24:5
   â”œâ”€ Detector: batch-transfer-overflow
   â”œâ”€ CWE: CWE-190
   â””â”€ Fix: Fix batch transfer overflow in ''. Options: (1) Use Solidity 0.8.0+ with checked arithmetic, (2) Use SafeMath library for multiplication, (3) Check each transfer individually: for each receiver require(balance >= value), (4) Validate count * value >= count && count * value >= value before use.

ğŸ”¥ CRITICAL: Function 'transfer' has batch transfer overflow vulnerability. Multiplication of array length with value (count * value) can overflow in Solidity <0.8.0 or in unchecked blocks, bypassing balance checks and allowing unlimited token minting. This was exploited in the BeautyChain (BEC) token hack causing $1B in damage.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:30:14
   â”œâ”€ Detector: batch-transfer-overflow
   â”œâ”€ CWE: CWE-190
   â””â”€ Fix: Fix batch transfer overflow in 'transfer'. Options: (1) Use Solidity 0.8.0+ with checked arithmetic, (2) Use SafeMath library for multiplication, (3) Check each transfer individually: for each receiver require(balance >= value), (4) Validate count * value >= count && count * value >= value before use.

ğŸ”¥ CRITICAL: Function 'batchTransfer' has batch transfer overflow vulnerability. Multiplication of array length with value (count * value) can overflow in Solidity <0.8.0 or in unchecked blocks, bypassing balance checks and allowing unlimited token minting. This was exploited in the BeautyChain (BEC) token hack causing $1B in damage.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:43:14
   â”œâ”€ Detector: batch-transfer-overflow
   â”œâ”€ CWE: CWE-190
   â””â”€ Fix: Fix batch transfer overflow in 'batchTransfer'. Options: (1) Use Solidity 0.8.0+ with checked arithmetic, (2) Use SafeMath library for multiplication, (3) Check each transfer individually: for each receiver require(balance >= value), (4) Validate count * value >= count && count * value >= value before use.

âš ï¸  HIGH: Function 'transfer' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:30:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'transfer'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

ğŸ”¥ CRITICAL: Function '' has token supply manipulation vulnerability. Function directly modifies totalSupply variable, bypasses mint/burn controls for supply manipulation Improper supply controls can lead to unlimited minting, hyperinflation, or complete token devaluation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:24:5
   â”œâ”€ Detector: token-supply-manipulation
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Fix token supply controls in ''. Implement maximum supply cap, add minting rate limits, require multi-signature for minting, add supply change events, validate burn amounts, and implement supply monitoring.

âš¡ MEDIUM: Function 'batchTransfer' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:43:14
   â”œâ”€ Detector: gas-griefing
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Mitigate gas griefing in 'batchTransfer'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.

ğŸ“ LOW: Function 'transfer' contains excessive gas usage pattern. Multiple storage reads detected (7). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:30:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'transfer'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Function 'batchTransfer' contains excessive gas usage pattern. Multiple storage reads detected (7). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:43:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'batchTransfer'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Function 'batchTransfer' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:43:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'batchTransfer'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Function 'batchTransfer' contains excessive gas usage pattern. Event emission inside loop. Can cause excessive gas costs for large arrays Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:43:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'batchTransfer'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Inefficient storage pattern detected. Small uint type as standalone storage variable. Use uint256 or pack with other variables Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:19:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Function 'transfer' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:30:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Function 'batchTransfer' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:43:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

âš ï¸  HIGH: Contract has centralization risk. Critical operations (withdraw/pause/upgrade) lack timelock delays. Malicious owner can drain funds or brick contract instantly Single point of failure can lead to fund loss, governance attacks, or complete system compromise.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:1:0
   â”œâ”€ Detector: centralization-risk
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.

âš¡ MEDIUM: Function 'batchTransfer' contains variable shadowing. Local variable 'count' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:43:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'batchTransfer'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Function 'batchTransfer' contains variable shadowing. Local variable 'amount' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:43:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'batchTransfer'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš ï¸  HIGH: Token price/exchange calculation without decimal normalization - incorrect conversions
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:1:1
   â”œâ”€ Detector: token-decimal-confusion
   â””â”€ Fix: Normalize decimals: amount * 10**token1.decimals() / 10**token2.decimals()

âš ï¸  HIGH: Decimal-sensitive math operations without validation - verify decimal assumptions
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:1:1
   â”œâ”€ Detector: token-decimal-confusion
   â””â”€ Fix: Validate expected decimals: require(token.decimals() == EXPECTED_DECIMALS)

âš¡ MEDIUM: First-come-first-served mint - creates PGA where users bid up gas to mint first
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:1:1
   â”œâ”€ Detector: mev-priority-gas-auction
   â””â”€ Fix: Use commit-reveal, whitelist, or fair launch mechanism instead of FCFS

ğŸ“ LOW: Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:2:0
   â”œâ”€ Detector: floating-pragma
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.

âš¡ MEDIUM: Missing domain separator in signature hash (cross-contract/chain replay)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:0:0
   â”œâ”€ Detector: multisig-bypass
   â”œâ”€ CWE: CWE-347
   â””â”€ Fix: Include domain separator: bytes32 domainSeparator = keccak256(abi.encode(TYPEHASH, address(this), block.chainid)); bytes32 hash = keccak256(abi.encodePacked(domainSeparator, data));

âš¡ MEDIUM: Signatures without expiration/deadline (indefinite validity risk)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:0:0
   â”œâ”€ Detector: multisig-bypass
   â”œâ”€ CWE: CWE-347
   â””â”€ Fix: Add expiration: Include deadline in signature data; require(block.timestamp <= deadline, "Signature expired"); Prevents execution of stale signatures.

âš¡ MEDIUM: EIP-7702 delegate uses storage - verify no collision with EOA state
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:1:0
   â”œâ”€ Detector: eip7702-storage-collision
   â””â”€ Fix: Use EIP-7201 namespaced storage to avoid collisions:

bytes32 private constant STORAGE_LOCATION = 
keccak256("myprotocol.delegate.storage");

struct DelegateStorage {
address owner;
mapping(address => uint256) balances;
}

function _getStorage() private pure returns (DelegateStorage storage $) {
assembly { $.slot := STORAGE_LOCATION }
}

âš ï¸  HIGH: Potential division before multiplication - causes precision loss (OWASP 2025)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:1:0
   â”œâ”€ Detector: logic-error-patterns
   â””â”€ Fix: âŒ PRECISION LOSS ($63.8M in losses):
uint256 reward = (amount / totalSupply) * rewardRate;
// Result: 0 if amount < totalSupply!

âœ… CORRECT ORDER:
uint256 reward = (amount * rewardRate) / totalSupply;
// Maximizes precision, multiply before divide

âœ… BEST: Use fixed-point math:
uint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;

Real incidents:
- Cork Protocol: $11M (May 2025) - Division rounding
- SIR.trading: $355K (March 2025) - Reward calculation
- Multiple 2024 incidents: $63.8M total

âš¡ MEDIUM: Address parameter without zero-address validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ MISSING ADDRESS VALIDATION:
function setOwner(address newOwner) external {
owner = newOwner;  // What if newOwner is address(0)?
}

âœ… VALIDATE ADDRESS:
function setOwner(address newOwner) external onlyOwner {
require(newOwner != address(0), "Zero address");
require(newOwner != owner, "Same address");
owner = newOwner;
}

âœ… VALIDATE MULTIPLE ADDRESSES:
function initialize(
address _token,
address _oracle,
address _treasury
) external {
require(_token != address(0), "Zero token");
require(_oracle != address(0), "Zero oracle");
require(_treasury != address(0), "Zero treasury");

// Check for duplicates if needed
require(_token != _oracle, "Token == oracle");
require(_token != _treasury, "Token == treasury");

token = _token;
oracle = _oracle;
treasury = _treasury;
}

ğŸ“ LOW: Type casting to smaller uint - verify no overflow on downcast
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:1:0
   â”œâ”€ Detector: post-080-overflow
   â””â”€ Fix: Downcasting can silently overflow even in Solidity 0.8.0+!

âŒ UNSAFE DOWNCAST:
uint256 bigValue = 1000;
uint8 smallValue = uint8(bigValue);  // Wraps to 232! (1000 % 256)

âœ… SAFE DOWNCAST with validation:
uint256 bigValue = 1000;
require(bigValue <= type(uint8).max, "Value too large");
uint8 smallValue = uint8(bigValue);  // Safe now

âœ… USE SafeCast library (OpenZeppelin):
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

uint256 bigValue = 1000;
uint8 smallValue = SafeCast.toUint8(bigValue);  // Reverts if > 255

Type limits:
- uint8:   0 to 255
- uint16:  0 to 65,535
- uint32:  0 to 4,294,967,295
- uint64:  0 to 18,446,744,073,709,551,615
- uint256: 0 to 2^256-1

âš ï¸  HIGH: Liquidity removal without time-lock protection - vulnerable to JIT attacks
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:1:1
   â”œâ”€ Detector: jit-liquidity-sandwich
   â””â”€ Fix: Add a minimum lock time for liquidity positions (e.g., 1 block or epoch-based system) to prevent JIT liquidity attacks

âš ï¸  HIGH: Liquidity becomes active immediately - may enable JIT sandwich attacks
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:1:1
   â”œâ”€ Detector: jit-liquidity-sandwich
   â””â”€ Fix: Consider delaying liquidity activation to the next epoch or block to mitigate JIT attacks

âš ï¸  HIGH: No minimum deposit requirement - small deposits may round down to zero shares
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:1:1
   â”œâ”€ Detector: pool-donation-enhanced
   â””â”€ Fix: Enforce minimum deposit amount or minimum shares minted to prevent rounding attacks

âš ï¸  HIGH: Pool initialization lacks protection - first depositor can manipulate initial share price
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:1:1
   â”œâ”€ Detector: pool-donation-enhanced
   â””â”€ Fix: Require minimum initial deposit, mint dead shares on initialization, or use time-delayed activation

âš¡ MEDIUM: Function 'claimTokens' in contract 'VulnerableToken' has first-come-first-served logic that depends on transaction ordering. Attackers can front-run legitimate users to claim rewards, spots, or limited supply.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:159:1
   â”œâ”€ Detector: transaction-ordering-dependence
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Use commit-reveal scheme or Chainlink VRF for fair distribution:

// Commit phase
function commit(bytes32 hash) external {
commits[msg.sender] = hash;
commitBlock[msg.sender] = block.number;
}

// Reveal phase (after N blocks)
function reveal(uint256 secret) external {
require(block.number > commitBlock[msg.sender] + MIN_BLOCKS);
require(commits[msg.sender] == keccak256(abi.encode(secret)));
// Fair distribution logic
}

âš ï¸  HIGH: Function 'execute' in contract 'VulnerableToken' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:126:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

ğŸ”¥ CRITICAL: Contract 'VulnerableToken' allows instant liquidity add/remove without time lock. Attackers can perform JIT liquidity attacks by adding liquidity just before large swaps and removing immediately after to capture fees.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:69:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add time lock for liquidity operations:

mapping(address => uint256) public depositTime;
uint256 public constant MIN_LOCK_TIME = 1 hours;

function addLiquidity(uint256 amount) external {
depositTime[msg.sender] = block.timestamp;
// ... add liquidity
}

function removeLiquidity(uint256 shares) external {
require(
block.timestamp >= depositTime[msg.sender] + MIN_LOCK_TIME,
"Liquidity locked"
);
// ... remove liquidity
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableToken' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:76:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

ğŸ”¥ CRITICAL: Function 'execute' in contract 'VulnerableToken' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:126:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

âš ï¸  HIGH: Constructor in contract 'VulnerableToken' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:24:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'execute' in contract 'VulnerableToken' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:126:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

âš ï¸  HIGH: Function 'batchTransfer' in contract 'VulnerableToken' performs batch operations that sequencers could exploit through partial execution ordering.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:43:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Improve batch operation safety:

1. Make batch operations atomic (all-or-nothing)
2. Add revert on partial failure
3. Implement batch ordering guarantees
4. Consider splitting into individual transactions

âš ï¸  HIGH: Function 'batchDeposit' in contract 'VulnerableToken' performs batch operations that sequencers could exploit through partial execution ordering.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:83:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Improve batch operation safety:

1. Make batch operations atomic (all-or-nothing)
2. Add revert on partial failure
3. Implement batch ordering guarantees
4. Consider splitting into individual transactions

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableToken' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:76:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableToken' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:76:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimTokens' in contract 'VulnerableToken' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:154:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimTokens' in contract 'VulnerableToken' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:154:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

âš ï¸  HIGH: Contract 'VulnerableToken' has unbounded storage array 'owners'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:112:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Function 'batchDeposit' in contract 'VulnerableToken' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:88:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

ğŸ”¥ CRITICAL: Function 'transferBetweenUsers' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:94:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'transferBetweenUsers'

âš ï¸  HIGH: Address parameter '_token' in function 'deposit' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:69:30
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_token != address(0), "Zero address not allowed");

âš ï¸  HIGH: Address parameter '_token' in function 'withdraw' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:76:31
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_token != address(0), "Zero address not allowed");

âš ï¸  HIGH: Address parameter '_token' in function 'transferBetweenUsers' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:95:17
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_token != address(0), "Zero address not allowed");

âš ï¸  HIGH: Address parameter '_from' in function 'transferBetweenUsers' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:96:17
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_from != address(0), "Zero address not allowed");

âš ï¸  HIGH: Address parameter '_to' in function 'transferBetweenUsers' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:97:17
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_to != address(0), "Zero address not allowed");

âš ï¸  HIGH: Function 'batchDeposit' has multiple array parameters but no apparent length validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:83:14
   â”œâ”€ Detector: array-bounds-check
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Add length validation: require(array1.length == array2.length, "Array length mismatch");

ğŸ“ LOW: Parameter '_token' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:69:30
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_token != address(0), "Invalid address");

ğŸ“ LOW: Parameter '_token' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:76:31
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_token != address(0), "Invalid address");

âš¡ MEDIUM: Function 'batchDeposit' has multiple array parameters (_tokens, _amounts) but no length consistency validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:83:14
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Add validation: require(_tokens.length == _amounts.length, "Array length mismatch");

âš¡ MEDIUM: Function 'batchDeposit' has related array parameters '_tokens' and '_amounts' that should be validated for equal length
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:83:14
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Add validation: require(_tokens.length == _amounts.length, "Related arrays must have equal length");

âš¡ MEDIUM: Parameter '_tokens' of type 'array' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:84:26
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_tokens.length > 0, "Array cannot be empty");

âš¡ MEDIUM: Parameter '_amounts' of type 'array' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:85:26
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_amounts.length > 0, "Array cannot be empty");

âš ï¸  HIGH: Parameter '_token' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:95:17
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_token != address(0), "Invalid address");

âš ï¸  HIGH: Parameter '_from' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:96:17
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_from != address(0), "Invalid address");

âš ï¸  HIGH: Parameter '_to' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:97:17
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_to != address(0), "Invalid address");

âš¡ MEDIUM: Function 'batchDeposit' accepts multiple arrays but doesn't validate they have equal lengths. This can cause out-of-bounds access if one array is shorter, leading to reverts, incorrect data processing, or exploitable behavior.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:83:14
   â”œâ”€ Detector: array-length-mismatch
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Add array length validation to 'batchDeposit'. At function start, add: require(array1.length == array2.length, "Array length mismatch"); For multiple arrays: require(arr1.length == arr2.length && arr2.length == arr3.length, "Length mismatch"); This prevents out-of-bounds access and ensures consistent data processing.

âš¡ MEDIUM: Function 'transferBetweenUsers' may be vulnerable to short address attack. Accepts address and value parameters but doesn't validate msg.data.length. An attacker can provide a truncated address causing the EVM to pad it, potentially shifting the value parameter and allowing larger transfers than intended.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:94:14
   â”œâ”€ Detector: short-address-attack
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Add msg.data.length validation to 'transferBetweenUsers'. Add at function start: require(msg.data.length >= 68, "Invalid input length"); For functions with address+uint256: 4 bytes (selector) + 32 bytes (address) + 32 bytes (uint256) = 68 bytes minimum. Adjust the required length based on your function's parameters.

ğŸ”¥ CRITICAL: Function 'deposit' has batch transfer overflow vulnerability. Multiplication of array length with value (count * value) can overflow in Solidity <0.8.0 or in unchecked blocks, bypassing balance checks and allowing unlimited token minting. This was exploited in the BeautyChain (BEC) token hack causing $1B in damage.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:69:14
   â”œâ”€ Detector: batch-transfer-overflow
   â”œâ”€ CWE: CWE-190
   â””â”€ Fix: Fix batch transfer overflow in 'deposit'. Options: (1) Use Solidity 0.8.0+ with checked arithmetic, (2) Use SafeMath library for multiplication, (3) Check each transfer individually: for each receiver require(balance >= value), (4) Validate count * value >= count && count * value >= value before use.

ğŸ”¥ CRITICAL: Function 'withdraw' has batch transfer overflow vulnerability. Multiplication of array length with value (count * value) can overflow in Solidity <0.8.0 or in unchecked blocks, bypassing balance checks and allowing unlimited token minting. This was exploited in the BeautyChain (BEC) token hack causing $1B in damage.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:76:14
   â”œâ”€ Detector: batch-transfer-overflow
   â”œâ”€ CWE: CWE-190
   â””â”€ Fix: Fix batch transfer overflow in 'withdraw'. Options: (1) Use Solidity 0.8.0+ with checked arithmetic, (2) Use SafeMath library for multiplication, (3) Check each transfer individually: for each receiver require(balance >= value), (4) Validate count * value >= count && count * value >= value before use.

ğŸ”¥ CRITICAL: Function 'batchDeposit' has batch transfer overflow vulnerability. Multiplication of array length with value (count * value) can overflow in Solidity <0.8.0 or in unchecked blocks, bypassing balance checks and allowing unlimited token minting. This was exploited in the BeautyChain (BEC) token hack causing $1B in damage.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:83:14
   â”œâ”€ Detector: batch-transfer-overflow
   â”œâ”€ CWE: CWE-190
   â””â”€ Fix: Fix batch transfer overflow in 'batchDeposit'. Options: (1) Use Solidity 0.8.0+ with checked arithmetic, (2) Use SafeMath library for multiplication, (3) Check each transfer individually: for each receiver require(balance >= value), (4) Validate count * value >= count && count * value >= value before use.

ğŸ”¥ CRITICAL: Function 'transferBetweenUsers' has batch transfer overflow vulnerability. Multiplication of array length with value (count * value) can overflow in Solidity <0.8.0 or in unchecked blocks, bypassing balance checks and allowing unlimited token minting. This was exploited in the BeautyChain (BEC) token hack causing $1B in damage.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:94:14
   â”œâ”€ Detector: batch-transfer-overflow
   â”œâ”€ CWE: CWE-190
   â””â”€ Fix: Fix batch transfer overflow in 'transferBetweenUsers'. Options: (1) Use Solidity 0.8.0+ with checked arithmetic, (2) Use SafeMath library for multiplication, (3) Check each transfer individually: for each receiver require(balance >= value), (4) Validate count * value >= count && count * value >= value before use.

âš ï¸  HIGH: Function 'withdraw' may be vulnerable to withdrawal DOS attack. No withdrawal cap or limit detected. Large withdrawals can drain liquidity and DOS subsequent withdrawers Attacker can block withdrawals, causing funds to be locked indefinitely.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:76:14
   â”œâ”€ Detector: vault-withdrawal-dos
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Protect 'withdraw' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.

âš ï¸  HIGH: Function 'batchDeposit' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:83:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'batchDeposit'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš¡ MEDIUM: Function 'deposit' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:69:14
   â”œâ”€ Detector: gas-griefing
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Mitigate gas griefing in 'deposit'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.

âš¡ MEDIUM: Function 'batchDeposit' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:83:14
   â”œâ”€ Detector: gas-griefing
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Mitigate gas griefing in 'batchDeposit'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.

âš ï¸  HIGH: Function 'batchDeposit' has DOS vulnerability via unbounded operation. Loop over unbounded array without iteration limit, large arrays cause out-of-gas Can cause out-of-gas errors blocking contract functionality.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:83:14
   â”œâ”€ Detector: dos-unbounded-operation
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Fix unbounded operation in 'batchDeposit'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.

ğŸ“ LOW: Function 'batchDeposit' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:83:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'batchDeposit'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

âš¡ MEDIUM: Function 'batchDeposit' missing input validation. Function with array parameter lacks length validation Missing validation can lead to unexpected behavior, zero address transfers, or invalid state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:83:14
   â”œâ”€ Detector: missing-input-validation
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Add input validation to 'batchDeposit'. Implement: (1) Zero address checks for address parameters, (2) Bounds validation for numeric inputs, (3) Array length validation, (4) require() statements at function start, (5) OpenZeppelin Address library for address validation.

âš¡ MEDIUM: Function 'withdraw' is missing transaction deadline. Missing transaction deadline. Withdrawal operation 'withdraw' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:76:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'withdraw'. Implement: (1) Add 'deadline' parameter: function withdraw(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

ğŸ”¥ CRITICAL: Missing authorization in batch executor 'batchDeposit' - anyone can execute arbitrary calls
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:83:0
   â”œâ”€ Detector: erc7821-batch-authorization
   â””â”€ Fix: Add authorization check:

address public owner;

function executeBatch(
address[] calldata targets,
bytes[] calldata datas
) external {
require(msg.sender == owner, "Not authorized");

for (uint i = 0; i < targets.length; i++) {
(bool success,) = targets[i].call(datas[i]);
require(success);
}
}

ğŸ”¥ CRITICAL: Function 'withdraw' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:76:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'withdraw'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

âš¡ MEDIUM: Function 'claimTokens' in contract 'VulnerableExchange' has first-come-first-served logic that depends on transaction ordering. Attackers can front-run legitimate users to claim rewards, spots, or limited supply.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:159:1
   â”œâ”€ Detector: transaction-ordering-dependence
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Use commit-reveal scheme or Chainlink VRF for fair distribution:

// Commit phase
function commit(bytes32 hash) external {
commits[msg.sender] = hash;
commitBlock[msg.sender] = block.number;
}

// Reveal phase (after N blocks)
function reveal(uint256 secret) external {
require(block.number > commitBlock[msg.sender] + MIN_BLOCKS);
require(commits[msg.sender] == keccak256(abi.encode(secret)));
// Fair distribution logic
}

âš ï¸  HIGH: Function 'execute' in contract 'VulnerableExchange' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:126:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

ğŸ”¥ CRITICAL: Contract 'VulnerableExchange' allows instant liquidity add/remove without time lock. Attackers can perform JIT liquidity attacks by adding liquidity just before large swaps and removing immediately after to capture fees.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:69:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add time lock for liquidity operations:

mapping(address => uint256) public depositTime;
uint256 public constant MIN_LOCK_TIME = 1 hours;

function addLiquidity(uint256 amount) external {
depositTime[msg.sender] = block.timestamp;
// ... add liquidity
}

function removeLiquidity(uint256 shares) external {
require(
block.timestamp >= depositTime[msg.sender] + MIN_LOCK_TIME,
"Liquidity locked"
);
// ... remove liquidity
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableExchange' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:76:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

ğŸ”¥ CRITICAL: Function 'execute' in contract 'VulnerableExchange' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:126:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

âš ï¸  HIGH: Constructor in contract 'VulnerableExchange' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:24:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'execute' in contract 'VulnerableExchange' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:126:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

âš ï¸  HIGH: Function 'batchTransfer' in contract 'VulnerableExchange' performs batch operations that sequencers could exploit through partial execution ordering.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:43:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Improve batch operation safety:

1. Make batch operations atomic (all-or-nothing)
2. Add revert on partial failure
3. Implement batch ordering guarantees
4. Consider splitting into individual transactions

âš ï¸  HIGH: Function 'batchDeposit' in contract 'VulnerableExchange' performs batch operations that sequencers could exploit through partial execution ordering.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:83:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Improve batch operation safety:

1. Make batch operations atomic (all-or-nothing)
2. Add revert on partial failure
3. Implement batch ordering guarantees
4. Consider splitting into individual transactions

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableExchange' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:76:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableExchange' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:76:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimTokens' in contract 'VulnerableExchange' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:154:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimTokens' in contract 'VulnerableExchange' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:154:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

âš ï¸  HIGH: Contract 'VulnerableExchange' has unbounded storage array 'owners'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:112:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Function 'batchDeposit' in contract 'VulnerableExchange' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:88:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš¡ MEDIUM: Address parameter '_target' in function 'execute' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:122:17
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_target != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter '_target' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:122:17
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_target != address(0), "Invalid address");

âš¡ MEDIUM: Function 'execute' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:121:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš ï¸  HIGH: Function 'execute' verifies signatures without replay protection. Attackers can reuse valid signatures to perform unauthorized actions. This is particularly dangerous in governance systems for vote manipulation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:121:0
   â”œâ”€ Detector: signature-replay
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Implement a nonce system to prevent signature replay attacks. Include a unique nonce in the signed message and track used nonces.

ğŸ”¥ CRITICAL: Function 'execute' generates hash/signature without chain ID protection. This allows the same signature to be replayed on different chains, potentially draining funds on all supported chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:121:14
   â”œâ”€ Detector: cross-chain-replay
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include 'block.chainid' in the hash calculation for function 'execute'. Example: keccak256(abi.encodePacked(..., block.chainid))

ğŸ”¥ CRITICAL: Function '' has batch transfer overflow vulnerability. Multiplication of array length with value (count * value) can overflow in Solidity <0.8.0 or in unchecked blocks, bypassing balance checks and allowing unlimited token minting. This was exploited in the BeautyChain (BEC) token hack causing $1B in damage.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:115:5
   â”œâ”€ Detector: batch-transfer-overflow
   â”œâ”€ CWE: CWE-190
   â””â”€ Fix: Fix batch transfer overflow in ''. Options: (1) Use Solidity 0.8.0+ with checked arithmetic, (2) Use SafeMath library for multiplication, (3) Check each transfer individually: for each receiver require(balance >= value), (4) Validate count * value >= count && count * value >= value before use.

ğŸ”¥ CRITICAL: Function 'execute' has batch transfer overflow vulnerability. Multiplication of array length with value (count * value) can overflow in Solidity <0.8.0 or in unchecked blocks, bypassing balance checks and allowing unlimited token minting. This was exploited in the BeautyChain (BEC) token hack causing $1B in damage.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:121:14
   â”œâ”€ Detector: batch-transfer-overflow
   â”œâ”€ CWE: CWE-190
   â””â”€ Fix: Fix batch transfer overflow in 'execute'. Options: (1) Use Solidity 0.8.0+ with checked arithmetic, (2) Use SafeMath library for multiplication, (3) Check each transfer individually: for each receiver require(balance >= value), (4) Validate count * value >= count && count * value >= value before use.

âš ï¸  HIGH: Function 'execute' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:121:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'execute'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš¡ MEDIUM: Function 'execute' is missing transaction deadline. Missing transaction deadline. Order execution operation 'execute' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:121:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'execute'. Implement: (1) Add 'deadline' parameter: function execute(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

ğŸ”¥ CRITICAL: Missing access control in 'execute' - allows arbitrary execution
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:121:0
   â”œâ”€ Detector: eip7702-delegate-access-control
   â””â”€ Fix: Fix: Add owner/authorization check:

address public owner;

function execute(address target, bytes calldata data) external payable {
require(msg.sender == owner, "Not authorized");
(bool success, ) = target.call{value: msg.value}(data);
require(success, "Call failed");
}

âš¡ MEDIUM: Function 'claimTokens' in contract 'VulnerableMultisig' has first-come-first-served logic that depends on transaction ordering. Attackers can front-run legitimate users to claim rewards, spots, or limited supply.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:159:1
   â”œâ”€ Detector: transaction-ordering-dependence
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Use commit-reveal scheme or Chainlink VRF for fair distribution:

// Commit phase
function commit(bytes32 hash) external {
commits[msg.sender] = hash;
commitBlock[msg.sender] = block.number;
}

// Reveal phase (after N blocks)
function reveal(uint256 secret) external {
require(block.number > commitBlock[msg.sender] + MIN_BLOCKS);
require(commits[msg.sender] == keccak256(abi.encode(secret)));
// Fair distribution logic
}

âš ï¸  HIGH: Function 'execute' in contract 'VulnerableMultisig' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:126:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

ğŸ”¥ CRITICAL: Contract 'VulnerableMultisig' allows instant liquidity add/remove without time lock. Attackers can perform JIT liquidity attacks by adding liquidity just before large swaps and removing immediately after to capture fees.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:69:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add time lock for liquidity operations:

mapping(address => uint256) public depositTime;
uint256 public constant MIN_LOCK_TIME = 1 hours;

function addLiquidity(uint256 amount) external {
depositTime[msg.sender] = block.timestamp;
// ... add liquidity
}

function removeLiquidity(uint256 shares) external {
require(
block.timestamp >= depositTime[msg.sender] + MIN_LOCK_TIME,
"Liquidity locked"
);
// ... remove liquidity
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableMultisig' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:76:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

ğŸ”¥ CRITICAL: Function 'execute' in contract 'VulnerableMultisig' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:126:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

âš ï¸  HIGH: Constructor in contract 'VulnerableMultisig' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:24:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'execute' in contract 'VulnerableMultisig' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:126:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

âš ï¸  HIGH: Function 'batchTransfer' in contract 'VulnerableMultisig' performs batch operations that sequencers could exploit through partial execution ordering.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:43:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Improve batch operation safety:

1. Make batch operations atomic (all-or-nothing)
2. Add revert on partial failure
3. Implement batch ordering guarantees
4. Consider splitting into individual transactions

âš ï¸  HIGH: Function 'batchDeposit' in contract 'VulnerableMultisig' performs batch operations that sequencers could exploit through partial execution ordering.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:83:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Improve batch operation safety:

1. Make batch operations atomic (all-or-nothing)
2. Add revert on partial failure
3. Implement batch ordering guarantees
4. Consider splitting into individual transactions

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableMultisig' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:76:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableMultisig' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:76:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimTokens' in contract 'VulnerableMultisig' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:154:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimTokens' in contract 'VulnerableMultisig' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:154:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

âš ï¸  HIGH: Contract 'VulnerableMultisig' has unbounded storage array 'owners'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:112:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Function 'batchDeposit' in contract 'VulnerableMultisig' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:88:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

ğŸ”¥ CRITICAL: Function 'claimTokens' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:154:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'claimTokens'

âš ï¸  HIGH: Address parameter '_recipient' in function 'claimTokens' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:154:34
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_recipient != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter '_recipient' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:154:34
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_recipient != address(0), "Invalid address");

ğŸ“ LOW: Parameter '_amount' of type 'uint' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:154:54
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_amount > 0, "Amount must be positive");

ğŸ”¥ CRITICAL: Function '' has batch transfer overflow vulnerability. Multiplication of array length with value (count * value) can overflow in Solidity <0.8.0 or in unchecked blocks, bypassing balance checks and allowing unlimited token minting. This was exploited in the BeautyChain (BEC) token hack causing $1B in damage.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:149:5
   â”œâ”€ Detector: batch-transfer-overflow
   â”œâ”€ CWE: CWE-190
   â””â”€ Fix: Fix batch transfer overflow in ''. Options: (1) Use Solidity 0.8.0+ with checked arithmetic, (2) Use SafeMath library for multiplication, (3) Check each transfer individually: for each receiver require(balance >= value), (4) Validate count * value >= count && count * value >= value before use.

ğŸ”¥ CRITICAL: Function 'claimTokens' has batch transfer overflow vulnerability. Multiplication of array length with value (count * value) can overflow in Solidity <0.8.0 or in unchecked blocks, bypassing balance checks and allowing unlimited token minting. This was exploited in the BeautyChain (BEC) token hack causing $1B in damage.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:154:14
   â”œâ”€ Detector: batch-transfer-overflow
   â”œâ”€ CWE: CWE-190
   â””â”€ Fix: Fix batch transfer overflow in 'claimTokens'. Options: (1) Use Solidity 0.8.0+ with checked arithmetic, (2) Use SafeMath library for multiplication, (3) Check each transfer individually: for each receiver require(balance >= value), (4) Validate count * value >= count && count * value >= value before use.

âš ï¸  HIGH: Function 'claimTokens' may be vulnerable to withdrawal DOS attack. Withdrawal requires successful external call. Failing calls can permanently block withdrawals. Consider using pull-over-push pattern Attacker can block withdrawals, causing funds to be locked indefinitely.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:154:14
   â”œâ”€ Detector: vault-withdrawal-dos
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Protect 'claimTokens' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.

âš ï¸  HIGH: Function 'claimTokens' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:154:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'claimTokens'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function 'claimTokens' has validator front-running vulnerability. Price-sensitive operations without fair sequencing, validators can reorder transactions for MEV extraction Validators can observe pending transactions and extract value by front-running users.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:154:14
   â”œâ”€ Detector: validator-front-running
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate validator front-running in 'claimTokens'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.

âš ï¸  HIGH: Function 'claimTokens' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:154:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'claimTokens'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš¡ MEDIUM: Function 'claimTokens' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:154:14
   â”œâ”€ Detector: gas-griefing
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Mitigate gas griefing in 'claimTokens'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.

âš¡ MEDIUM: Function 'claimTokens' is missing transaction deadline. Missing transaction deadline. Claim operation 'claimTokens' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:154:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'claimTokens'. Implement: (1) Add 'deadline' parameter: function claimTokens(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

ğŸ”¥ CRITICAL: Function 'claimTokens' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:154:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'claimTokens'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

âš¡ MEDIUM: Function 'claimTokens' in contract 'VulnerableAirdrop' has first-come-first-served logic that depends on transaction ordering. Attackers can front-run legitimate users to claim rewards, spots, or limited supply.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:159:1
   â”œâ”€ Detector: transaction-ordering-dependence
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Use commit-reveal scheme or Chainlink VRF for fair distribution:

// Commit phase
function commit(bytes32 hash) external {
commits[msg.sender] = hash;
commitBlock[msg.sender] = block.number;
}

// Reveal phase (after N blocks)
function reveal(uint256 secret) external {
require(block.number > commitBlock[msg.sender] + MIN_BLOCKS);
require(commits[msg.sender] == keccak256(abi.encode(secret)));
// Fair distribution logic
}

âš ï¸  HIGH: Function 'execute' in contract 'VulnerableAirdrop' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:126:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

ğŸ”¥ CRITICAL: Contract 'VulnerableAirdrop' allows instant liquidity add/remove without time lock. Attackers can perform JIT liquidity attacks by adding liquidity just before large swaps and removing immediately after to capture fees.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:69:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add time lock for liquidity operations:

mapping(address => uint256) public depositTime;
uint256 public constant MIN_LOCK_TIME = 1 hours;

function addLiquidity(uint256 amount) external {
depositTime[msg.sender] = block.timestamp;
// ... add liquidity
}

function removeLiquidity(uint256 shares) external {
require(
block.timestamp >= depositTime[msg.sender] + MIN_LOCK_TIME,
"Liquidity locked"
);
// ... remove liquidity
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableAirdrop' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:76:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

ğŸ”¥ CRITICAL: Function 'execute' in contract 'VulnerableAirdrop' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:126:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

âš ï¸  HIGH: Constructor in contract 'VulnerableAirdrop' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:24:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'execute' in contract 'VulnerableAirdrop' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:126:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

âš ï¸  HIGH: Function 'batchTransfer' in contract 'VulnerableAirdrop' performs batch operations that sequencers could exploit through partial execution ordering.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:43:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Improve batch operation safety:

1. Make batch operations atomic (all-or-nothing)
2. Add revert on partial failure
3. Implement batch ordering guarantees
4. Consider splitting into individual transactions

âš ï¸  HIGH: Function 'batchDeposit' in contract 'VulnerableAirdrop' performs batch operations that sequencers could exploit through partial execution ordering.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:83:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Improve batch operation safety:

1. Make batch operations atomic (all-or-nothing)
2. Add revert on partial failure
3. Implement batch ordering guarantees
4. Consider splitting into individual transactions

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableAirdrop' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:76:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableAirdrop' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:76:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimTokens' in contract 'VulnerableAirdrop' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:154:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimTokens' in contract 'VulnerableAirdrop' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:154:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

âš ï¸  HIGH: Contract 'VulnerableAirdrop' has unbounded storage array 'owners'. Users can grow array indefinitely, causing gas issues.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:112:1
   â”œâ”€ Detector: dos-unbounded-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Bound storage array growth:

1. Add maximum size constant:
uint256 constant MAX_SIZE = 1000;

2. Check before push:
require(array.length < MAX_SIZE, "Max size reached");

3. Consider using mapping with index counter

âš ï¸  HIGH: Function 'batchDeposit' in contract 'VulnerableAirdrop' has gas limit risk: Unbounded loop over array. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/ShortAddress.sol:88:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

ğŸ”¥ CRITICAL: Function 'metaTransfer' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:19:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'metaTransfer'

âš ï¸  HIGH: Address parameter 'from' in function 'metaTransfer' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:20:17
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(from != address(0), "Zero address not allowed");

âš ï¸  HIGH: Address parameter 'to' in function 'metaTransfer' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:21:17
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(to != address(0), "Zero address not allowed");

âš ï¸  HIGH: Parameter 'to' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:21:17
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(to != address(0), "Invalid address");

âš¡ MEDIUM: Function 'metaTransfer' may be vulnerable to short address attack. Accepts address and value parameters but doesn't validate msg.data.length. An attacker can provide a truncated address causing the EVM to pad it, potentially shifting the value parameter and allowing larger transfers than intended.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:19:14
   â”œâ”€ Detector: short-address-attack
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Add msg.data.length validation to 'metaTransfer'. Add at function start: require(msg.data.length >= 68, "Invalid input length"); For functions with address+uint256: 4 bytes (selector) + 32 bytes (address) + 32 bytes (uint256) = 68 bytes minimum. Adjust the required length based on your function's parameters.

âš ï¸  HIGH: Function 'recoverSigner' verifies signatures without replay protection. Attackers can reuse valid signatures to perform unauthorized actions. This is particularly dangerous in governance systems for vote manipulation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:40:0
   â”œâ”€ Detector: signature-replay
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Implement a nonce system to prevent signature replay attacks. Include a unique nonce in the signed message and track used nonces.

ğŸ”¥ CRITICAL: Function 'metaTransfer' generates hash/signature without chain ID protection. This allows the same signature to be replayed on different chains, potentially draining funds on all supported chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:19:14
   â”œâ”€ Detector: cross-chain-replay
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include 'block.chainid' in the hash calculation for function 'metaTransfer'. Example: keccak256(abi.encodePacked(..., block.chainid))

âš ï¸  HIGH: Function 'recoverSigner' uses ECDSA signature verification without malleability protection. Uses ecrecover without checking 's' value against secp256k1 curve order ECDSA signatures have two valid forms (s and -s mod n). Without checking that s is in the lower half range, attackers can create alternate valid signatures for replay attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:40:14
   â”œâ”€ Detector: signature-malleability
   â”œâ”€ CWE: CWE-347
   â””â”€ Fix: Add signature malleability check in 'recoverSigner'. Use OpenZeppelin's ECDSA library or add: `require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "Invalid signature 's' value");` This ensures s is in the lower half of the curve order.

âš ï¸  HIGH: Function 'recoverSigner' Uses ecrecover() without proper EIP-712 domain separator. Signatures are vulnerable to replay attacks across contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:40:14
   â”œâ”€ Detector: missing-eip712-domain
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Implement proper EIP-712 domain separator:
1. Define DOMAIN_SEPARATOR with all required fields (name, version, chainId, verifyingContract)
2. Use structured data hashing with EIP-712
3. Include domain separator in signature hash: keccak256(abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR, structHash))
4. Or use OpenZeppelin's EIP712 implementation

ğŸ“ LOW: Function 'metaTransfer' contains excessive gas usage pattern. Multiple storage reads detected (7). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:19:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'metaTransfer'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Inefficient storage pattern detected. Small uint type as standalone storage variable. Use uint256 or pack with other variables Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:45:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Small uint type as standalone storage variable. Use uint256 or pack with other variables Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:93:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Small uint type as standalone storage variable. Use uint256 or pack with other variables Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:141:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Small uint type as standalone storage variable. Use uint256 or pack with other variables Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:186:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Function 'metaTransfer' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:19:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

âš¡ MEDIUM: Token transfer lacks return data size validation - vulnerable to return bomb DOS
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:1:1
   â”œâ”€ Detector: erc20-transfer-return-bomb
   â””â”€ Fix: Check returndatasize() and reject if excessive (>64 bytes): require(returndatasize() <= 64)

âš¡ MEDIUM: Low-level call to token without gas limit - return bomb can exhaust all gas
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:1:1
   â”œâ”€ Detector: erc20-transfer-return-bomb
   â””â”€ Fix: Specify gas limit for calls: token.call{gas: 100000}(abi.encodeWithSelector(...))

ğŸ”¥ CRITICAL: Cross-rollup operation lacks atomicity guarantee - partial execution possible
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:1:1
   â”œâ”€ Detector: cross-rollup-atomicity
   â””â”€ Fix: Implement two-phase commit or rollback mechanism

ğŸ“ LOW: Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:2:0
   â”œâ”€ Detector: floating-pragma
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.

âš ï¸  HIGH: Missing signature malleability protection (duplicate signature acceptance)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:0:0
   â”œâ”€ Detector: multisig-bypass
   â”œâ”€ CWE: CWE-347
   â””â”€ Fix: Check s-value: require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "Invalid s-value"); This prevents signature malleability.

âš¡ MEDIUM: Missing domain separator in signature hash (cross-contract/chain replay)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:0:0
   â”œâ”€ Detector: multisig-bypass
   â”œâ”€ CWE: CWE-347
   â””â”€ Fix: Include domain separator: bytes32 domainSeparator = keccak256(abi.encode(TYPEHASH, address(this), block.chainid)); bytes32 hash = keccak256(abi.encodePacked(domainSeparator, data));

âš¡ MEDIUM: Signatures without expiration/deadline (indefinite validity risk)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:0:0
   â”œâ”€ Detector: multisig-bypass
   â”œâ”€ CWE: CWE-347
   â””â”€ Fix: Add expiration: Include deadline in signature data; require(block.timestamp <= deadline, "Signature expired"); Prevents execution of stale signatures.

âš¡ MEDIUM: EIP-7702 delegate uses storage - verify no collision with EOA state
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:1:0
   â”œâ”€ Detector: eip7702-storage-collision
   â””â”€ Fix: Use EIP-7201 namespaced storage to avoid collisions:

bytes32 private constant STORAGE_LOCATION = 
keccak256("myprotocol.delegate.storage");

struct DelegateStorage {
address owner;
mapping(address => uint256) balances;
}

function _getStorage() private pure returns (DelegateStorage storage $) {
assembly { $.slot := STORAGE_LOCATION }
}

âš ï¸  HIGH: Potential division before multiplication - causes precision loss (OWASP 2025)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:1:0
   â”œâ”€ Detector: logic-error-patterns
   â””â”€ Fix: âŒ PRECISION LOSS ($63.8M in losses):
uint256 reward = (amount / totalSupply) * rewardRate;
// Result: 0 if amount < totalSupply!

âœ… CORRECT ORDER:
uint256 reward = (amount * rewardRate) / totalSupply;
// Maximizes precision, multiply before divide

âœ… BEST: Use fixed-point math:
uint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;

Real incidents:
- Cork Protocol: $11M (May 2025) - Division rounding
- SIR.trading: $355K (March 2025) - Reward calculation
- Multiple 2024 incidents: $63.8M total

âš¡ MEDIUM: Transfer function without zero-value check - validate non-zero amounts
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ MISSING ZERO-VALUE CHECK:
function transfer(address to, uint256 amount) external {
_transfer(msg.sender, to, amount);
// What if amount is 0? Wastes gas, may break accounting
}

âœ… VALIDATE NON-ZERO:
function transfer(address to, uint256 amount) external {
require(amount > 0, "Zero amount");
require(to != address(0), "Zero address");
_transfer(msg.sender, to, amount);
}

âœ… COMPLETE VALIDATION:
function deposit(uint256 amount) external payable {
// For ERC20 deposits
require(amount > 0, "Zero amount");
require(amount <= MAX_DEPOSIT, "Exceeds maximum");

// For native ETH deposits
if (msg.value > 0) {
require(msg.value == amount, "Value mismatch");
}

// Proceed with deposit
}

âš¡ MEDIUM: Address parameter without zero-address validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ MISSING ADDRESS VALIDATION:
function setOwner(address newOwner) external {
owner = newOwner;  // What if newOwner is address(0)?
}

âœ… VALIDATE ADDRESS:
function setOwner(address newOwner) external onlyOwner {
require(newOwner != address(0), "Zero address");
require(newOwner != owner, "Same address");
owner = newOwner;
}

âœ… VALIDATE MULTIPLE ADDRESSES:
function initialize(
address _token,
address _oracle,
address _treasury
) external {
require(_token != address(0), "Zero token");
require(_oracle != address(0), "Zero oracle");
require(_treasury != address(0), "Zero treasury");

// Check for duplicates if needed
require(_token != _oracle, "Token == oracle");
require(_token != _treasury, "Token == treasury");

token = _token;
oracle = _oracle;
treasury = _treasury;
}

âš ï¸  HIGH: Assembly arithmetic detected - no overflow protection! ($223M Cetus DEX)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:1:0
   â”œâ”€ Detector: post-080-overflow
   â””â”€ Fix: ğŸš¨ CRITICAL: Assembly has NO overflow protection!

Real incident: Cetus DEX - $223M loss (May 2025)
Cause: Assembly arithmetic overflow

âŒ VULNERABLE (Cetus-style vulnerability):
assembly {
let result := add(a, b)  // NO OVERFLOW CHECK!
let product := mul(x, y) // NO OVERFLOW CHECK!
mstore(0x00, result)
}

âœ… SOLUTION 1 - Add manual checks:
assembly {
let result := add(a, b)
// Manual overflow check
if lt(result, a) {
revert(0, 0)  // Overflow detected
}
}

âœ… SOLUTION 2 - Use Solidity instead:
// Let Solidity handle overflow checks
uint256 result = a + b;  // Automatic overflow check

âœ… SOLUTION 3 - SafeMath for assembly:
function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {
uint256 c;
assembly {
c := add(a, b)
}
require(c >= a, "Overflow");  // Check outside assembly
return c;
}

Assembly arithmetic operations with NO checks:
- add(a, b)     â†’ wraps on overflow
- sub(a, b)     â†’ wraps on underflow
- mul(a, b)     â†’ wraps on overflow
- div(a, b)     â†’ returns 0 if b is 0 (no revert!)

âš ï¸ Only use assembly arithmetic when absolutely necessary
and with manual overflow checks!

ğŸ“ LOW: Type casting to smaller uint - verify no overflow on downcast
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:1:0
   â”œâ”€ Detector: post-080-overflow
   â””â”€ Fix: Downcasting can silently overflow even in Solidity 0.8.0+!

âŒ UNSAFE DOWNCAST:
uint256 bigValue = 1000;
uint8 smallValue = uint8(bigValue);  // Wraps to 232! (1000 % 256)

âœ… SAFE DOWNCAST with validation:
uint256 bigValue = 1000;
require(bigValue <= type(uint8).max, "Value too large");
uint8 smallValue = uint8(bigValue);  // Safe now

âœ… USE SafeCast library (OpenZeppelin):
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

uint256 bigValue = 1000;
uint8 smallValue = SafeCast.toUint8(bigValue);  // Reverts if > 255

Type limits:
- uint8:   0 to 255
- uint16:  0 to 65,535
- uint32:  0 to 4,294,967,295
- uint64:  0 to 18,446,744,073,709,551,615
- uint256: 0 to 2^256-1

âš ï¸  HIGH: Liquidity becomes active immediately - may enable JIT sandwich attacks
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:1:1
   â”œâ”€ Detector: jit-liquidity-sandwich
   â””â”€ Fix: Consider delaying liquidity activation to the next epoch or block to mitigate JIT attacks

âš ï¸  HIGH: No minimum deposit requirement - small deposits may round down to zero shares
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:1:1
   â”œâ”€ Detector: pool-donation-enhanced
   â””â”€ Fix: Enforce minimum deposit amount or minimum shares minted to prevent rounding attacks

âš ï¸  HIGH: Pool initialization lacks protection - first depositor can manipulate initial share price
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:1:1
   â”œâ”€ Detector: pool-donation-enhanced
   â””â”€ Fix: Require minimum initial deposit, mint dead shares on initialization, or use time-delayed activation

âš ï¸  HIGH: abi.encodePacked() with multiple variable-length arguments at line 37. Multiple variable-length arguments detected: string literal, '_messageHash'. This can lead to hash collisions where different inputs produce the same hash.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:37:1
   â”œâ”€ Detector: swc133-hash-collision-varlen
   â”œâ”€ CWE: CWE-328
   â””â”€ Fix: Replace abi.encodePacked() with one of these safe alternatives:
1. Use abi.encode() - adds length prefixes, preventing collisions
2. Add a fixed separator between arguments:
keccak256(abi.encodePacked(a, "|", b))
3. Use fixed-length types (bytes32, uint256) instead of dynamic types
4. Hash each argument separately and combine:
keccak256(abi.encode(keccak256(a), keccak256(b)))

âš ï¸  HIGH: abi.encodePacked() with multiple variable-length arguments at line 85. Multiple variable-length arguments detected: string literal, '_messageHash'. This can lead to hash collisions where different inputs produce the same hash.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:85:1
   â”œâ”€ Detector: swc133-hash-collision-varlen
   â”œâ”€ CWE: CWE-328
   â””â”€ Fix: Replace abi.encodePacked() with one of these safe alternatives:
1. Use abi.encode() - adds length prefixes, preventing collisions
2. Add a fixed separator between arguments:
keccak256(abi.encodePacked(a, "|", b))
3. Use fixed-length types (bytes32, uint256) instead of dynamic types
4. Hash each argument separately and combine:
keccak256(abi.encode(keccak256(a), keccak256(b)))

âš ï¸  HIGH: abi.encodePacked() with multiple variable-length arguments at line 120. Multiple variable-length arguments detected: string literal, 'messageHash'. This can lead to hash collisions where different inputs produce the same hash.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:120:1
   â”œâ”€ Detector: swc133-hash-collision-varlen
   â”œâ”€ CWE: CWE-328
   â””â”€ Fix: Replace abi.encodePacked() with one of these safe alternatives:
1. Use abi.encode() - adds length prefixes, preventing collisions
2. Add a fixed separator between arguments:
keccak256(abi.encodePacked(a, "|", b))
3. Use fixed-length types (bytes32, uint256) instead of dynamic types
4. Hash each argument separately and combine:
keccak256(abi.encode(keccak256(a), keccak256(b)))

âš ï¸  HIGH: abi.encodePacked() with multiple variable-length arguments at line 170. Multiple variable-length arguments detected: string literal, 'messageHash'. This can lead to hash collisions where different inputs produce the same hash.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:170:1
   â”œâ”€ Detector: swc133-hash-collision-varlen
   â”œâ”€ CWE: CWE-328
   â””â”€ Fix: Replace abi.encodePacked() with one of these safe alternatives:
1. Use abi.encode() - adds length prefixes, preventing collisions
2. Add a fixed separator between arguments:
keccak256(abi.encodePacked(a, "|", b))
3. Use fixed-length types (bytes32, uint256) instead of dynamic types
4. Hash each argument separately and combine:
keccak256(abi.encode(keccak256(a), keccak256(b)))

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableMetaTransaction' verifies signatures without chain ID protection. Signatures can be replayed across different EVM chains (mainnet, Arbitrum, Optimism, Polygon, etc.) allowing unauthorized cross-chain actions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:42:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data with chain ID in domain separator:

bytes32 public DOMAIN_SEPARATOR;

constructor() {
DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));
}

function verify(bytes32 structHash, bytes calldata signature) internal view {
bytes32 digest = keccak256(abi.encodePacked(
"\x19\x01",
DOMAIN_SEPARATOR,
structHash
));
address signer = ECDSA.recover(digest, signature);
// verify signer
}

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableMetaTransaction' verifies signatures without chain ID protection. Signatures can be replayed across different EVM chains (mainnet, Arbitrum, Optimism, Polygon, etc.) allowing unauthorized cross-chain actions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:90:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data with chain ID in domain separator:

bytes32 public DOMAIN_SEPARATOR;

constructor() {
DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));
}

function verify(bytes32 structHash, bytes calldata signature) internal view {
bytes32 digest = keccak256(abi.encodePacked(
"\x19\x01",
DOMAIN_SEPARATOR,
structHash
));
address signer = ECDSA.recover(digest, signature);
// verify signer
}

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableMetaTransaction' verifies signatures without chain ID protection. Signatures can be replayed across different EVM chains (mainnet, Arbitrum, Optimism, Polygon, etc.) allowing unauthorized cross-chain actions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:138:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data with chain ID in domain separator:

bytes32 public DOMAIN_SEPARATOR;

constructor() {
DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));
}

function verify(bytes32 structHash, bytes calldata signature) internal view {
bytes32 digest = keccak256(abi.encodePacked(
"\x19\x01",
DOMAIN_SEPARATOR,
structHash
));
address signer = ECDSA.recover(digest, signature);
// verify signer
}

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableMetaTransaction' verifies signatures without chain ID protection. Signatures can be replayed across different EVM chains (mainnet, Arbitrum, Optimism, Polygon, etc.) allowing unauthorized cross-chain actions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:183:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data with chain ID in domain separator:

bytes32 public DOMAIN_SEPARATOR;

constructor() {
DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));
}

function verify(bytes32 structHash, bytes calldata signature) internal view {
bytes32 digest = keccak256(abi.encodePacked(
"\x19\x01",
DOMAIN_SEPARATOR,
structHash
));
address signer = ECDSA.recover(digest, signature);
// verify signer
}

âš ï¸  HIGH: Function 'metaTransfer' in contract 'VulnerableMetaTransaction' constructs hash for signing without chain ID. The resulting signature can be replayed on other chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:26:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in the signed data:

bytes32 hash = keccak256(abi.encode(
block.chainid,  // Chain ID
address(this),  // Contract address
nonce,          // Nonce for replay protection
data
));

âš ï¸  HIGH: Function 'getEthSignedMessageHash' in contract 'VulnerableMetaTransaction' constructs hash for signing without chain ID. The resulting signature can be replayed on other chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:37:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in the signed data:

bytes32 hash = keccak256(abi.encode(
block.chainid,  // Chain ID
address(this),  // Contract address
nonce,          // Nonce for replay protection
data
));

âš ï¸  HIGH: Function 'redeemVoucher' in contract 'VulnerableMetaTransaction' constructs hash for signing without chain ID. The resulting signature can be replayed on other chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:73:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in the signed data:

bytes32 hash = keccak256(abi.encode(
block.chainid,  // Chain ID
address(this),  // Contract address
nonce,          // Nonce for replay protection
data
));

âš ï¸  HIGH: Function 'getEthSignedMessageHash' in contract 'VulnerableMetaTransaction' constructs hash for signing without chain ID. The resulting signature can be replayed on other chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:85:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in the signed data:

bytes32 hash = keccak256(abi.encode(
block.chainid,  // Chain ID
address(this),  // Contract address
nonce,          // Nonce for replay protection
data
));

ğŸ”¥ CRITICAL: Function 'metaTransfer' in contract 'VulnerableMetaTransaction' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:26:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'metaTransfer' in contract 'VulnerableMetaTransaction' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:27:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableMetaTransaction' verifies signatures without chain ID. EIP-7702 delegations could be replayed on other chains where the same contract is deployed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:42:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in signature hash to prevent cross-chain replay:

bytes32 hash = keccak256(abi.encodePacked(
block.chainid,
address(this),
nonce,
data
));

Or use EIP-712 with proper domain separator.

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableMetaTransaction' verifies signatures without chain ID. EIP-7702 delegations could be replayed on other chains where the same contract is deployed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:90:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in signature hash to prevent cross-chain replay:

bytes32 hash = keccak256(abi.encodePacked(
block.chainid,
address(this),
nonce,
data
));

Or use EIP-712 with proper domain separator.

âš ï¸  HIGH: Function 'splitSignature' in contract 'VulnerableMetaTransaction' verifies signatures without chain ID. EIP-7702 delegations could be replayed on other chains where the same contract is deployed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:109:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in signature hash to prevent cross-chain replay:

bytes32 hash = keccak256(abi.encodePacked(
block.chainid,
address(this),
nonce,
data
));

Or use EIP-712 with proper domain separator.

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableMetaTransaction' verifies signatures without chain ID. EIP-7702 delegations could be replayed on other chains where the same contract is deployed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:138:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in signature hash to prevent cross-chain replay:

bytes32 hash = keccak256(abi.encodePacked(
block.chainid,
address(this),
nonce,
data
));

Or use EIP-712 with proper domain separator.

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableMetaTransaction' verifies signatures without chain ID. EIP-7702 delegations could be replayed on other chains where the same contract is deployed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:183:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in signature hash to prevent cross-chain replay:

bytes32 hash = keccak256(abi.encodePacked(
block.chainid,
address(this),
nonce,
data
));

Or use EIP-712 with proper domain separator.

âš ï¸  HIGH: Function 'metaTransfer' in contract 'VulnerableMetaTransaction' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:26:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'getEthSignedMessageHash' in contract 'VulnerableMetaTransaction' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:37:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'redeemVoucher' in contract 'VulnerableMetaTransaction' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:73:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'getEthSignedMessageHash' in contract 'VulnerableMetaTransaction' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:85:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'executeWithSignature' in contract 'VulnerableMetaTransaction' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:119:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'executeWithSignature' in contract 'VulnerableMetaTransaction' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:120:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'executeMetaTransaction' in contract 'VulnerableMetaTransaction' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:169:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'executeMetaTransaction' in contract 'VulnerableMetaTransaction' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:170:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

ğŸ”¥ CRITICAL: Contract 'VulnerableMetaTransaction' allows instant liquidity add/remove without time lock. Attackers can perform JIT liquidity attacks by adding liquidity just before large swaps and removing immediately after to capture fees.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:14:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add time lock for liquidity operations:

mapping(address => uint256) public depositTime;
uint256 public constant MIN_LOCK_TIME = 1 hours;

function addLiquidity(uint256 amount) external {
depositTime[msg.sender] = block.timestamp;
// ... add liquidity
}

function removeLiquidity(uint256 shares) external {
require(
block.timestamp >= depositTime[msg.sender] + MIN_LOCK_TIME,
"Liquidity locked"
);
// ... remove liquidity
}

ğŸ”¥ CRITICAL: Function 'metaTransfer' in contract 'VulnerableMetaTransaction' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:26:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

ğŸ”¥ CRITICAL: Function 'redeemVoucher' in contract 'VulnerableMetaTransaction' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:73:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

ğŸ”¥ CRITICAL: Function 'executeWithSignature' in contract 'VulnerableMetaTransaction' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:119:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

ğŸ”¥ CRITICAL: Function 'executeWithSignature' in contract 'VulnerableMetaTransaction' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:120:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

ğŸ”¥ CRITICAL: Function 'executeMetaTransaction' in contract 'VulnerableMetaTransaction' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:169:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

ğŸ”¥ CRITICAL: Function 'executeMetaTransaction' in contract 'VulnerableMetaTransaction' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:170:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

âš ï¸  HIGH: Constructor in contract 'VulnerableMetaTransaction' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:63:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'metaTransfer' in contract 'VulnerableMetaTransaction' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:26:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'getEthSignedMessageHash' in contract 'VulnerableMetaTransaction' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:37:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'redeemVoucher' in contract 'VulnerableMetaTransaction' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:73:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'getEthSignedMessageHash' in contract 'VulnerableMetaTransaction' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:85:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'executeWithSignature' in contract 'VulnerableMetaTransaction' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:119:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'executeWithSignature' in contract 'VulnerableMetaTransaction' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:120:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'executeMetaTransaction' in contract 'VulnerableMetaTransaction' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:169:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'executeMetaTransaction' in contract 'VulnerableMetaTransaction' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:170:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

âš ï¸  HIGH: Function 'redeemVoucher' in contract 'VulnerableMetaTransaction' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:81:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'executeWithSignature' in contract 'VulnerableMetaTransaction' forwards unlimited gas to external call. Recipient can consume all gas causing out-of-gas revert.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:132:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit gas for external calls:

// Limit gas to prevent griefing
(bool success, ) = recipient.call{value: amount, gas: 10000}("");

// Or use transfer() which limits gas to 2300

âš ï¸  HIGH: Function 'executeMetaTransaction' in contract 'VulnerableMetaTransaction' forwards unlimited gas to external call. Recipient can consume all gas causing out-of-gas revert.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:177:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit gas for external calls:

// Limit gas to prevent griefing
(bool success, ) = recipient.call{value: amount, gas: 10000}("");

// Or use transfer() which limits gas to 2300

ğŸ”¥ CRITICAL: State variables modified after external call - potential reentrancy affecting state machine
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:81:9
   â”œâ”€ Detector: invalid-state-transition
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Use checks-effects-interactions pattern or reentrancy guards

ğŸ“ LOW: Parameter 'amount' of type 'uint' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:69:17
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(amount > 0, "Amount must be positive");

âš¡ MEDIUM: External call in function 'redeemVoucher' does not check return value
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:68:14
   â”œâ”€ Detector: unchecked-external-call
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check the return value of external calls in function 'redeemVoucher'

âš ï¸  HIGH: Function 'recoverSigner' verifies signatures without replay protection. Attackers can reuse valid signatures to perform unauthorized actions. This is particularly dangerous in governance systems for vote manipulation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:88:0
   â”œâ”€ Detector: signature-replay
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Implement a nonce system to prevent signature replay attacks. Include a unique nonce in the signed message and track used nonces.

ğŸ”¥ CRITICAL: Function 'redeemVoucher' generates hash/signature without chain ID protection. This allows the same signature to be replayed on different chains, potentially draining funds on all supported chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:68:14
   â”œâ”€ Detector: cross-chain-replay
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include 'block.chainid' in the hash calculation for function 'redeemVoucher'. Example: keccak256(abi.encodePacked(..., block.chainid))

âš ï¸  HIGH: Function 'recoverSigner' uses ECDSA signature verification without malleability protection. Uses ecrecover without checking 's' value against secp256k1 curve order ECDSA signatures have two valid forms (s and -s mod n). Without checking that s is in the lower half range, attackers can create alternate valid signatures for replay attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:88:14
   â”œâ”€ Detector: signature-malleability
   â”œâ”€ CWE: CWE-347
   â””â”€ Fix: Add signature malleability check in 'recoverSigner'. Use OpenZeppelin's ECDSA library or add: `require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "Invalid signature 's' value");` This ensures s is in the lower half of the curve order.

âš ï¸  HIGH: Function 'recoverSigner' Uses ecrecover() without proper EIP-712 domain separator. Signatures are vulnerable to replay attacks across contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:88:14
   â”œâ”€ Detector: missing-eip712-domain
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Implement proper EIP-712 domain separator:
1. Define DOMAIN_SEPARATOR with all required fields (name, version, chainId, verifyingContract)
2. Use structured data hashing with EIP-712
3. Include domain separator in signature hash: keccak256(abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR, structHash))
4. Or use OpenZeppelin's EIP712 implementation

âš ï¸  HIGH: Function 'redeemVoucher' may be vulnerable to withdrawal DOS attack. Withdrawal requires successful external call. Failing calls can permanently block withdrawals. Consider using pull-over-push pattern Attacker can block withdrawals, causing funds to be locked indefinitely.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:68:14
   â”œâ”€ Detector: vault-withdrawal-dos
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Protect 'redeemVoucher' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.

âš ï¸  HIGH: Function 'redeemVoucher' may be vulnerable to hook reentrancy attack. Uses raw transfer() instead of SafeERC20. No protection against malicious token implementations with callback hooks ERC-777/ERC-1363 token callbacks can re-enter and manipulate vault state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:68:14
   â”œâ”€ Detector: vault-hook-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Protect 'redeemVoucher' from hook reentrancy. Solutions: (1) Add nonReentrant modifier from OpenZeppelin ReentrancyGuard, (2) Follow checks-effects-interactions (CEI) pattern strictly, (3) Update state BEFORE external calls with callbacks, (4) Validate token doesn't implement hooks (ERC-777/ERC-1363/callbacks), (5) Use reentrancy guard on all vault entry points, (6) Consider EIP-1153 transient storage for gas-efficient protection (Solidity 0.8.24+), (7) Use SafeERC20 wrapper library for token operations.

âš ï¸  HIGH: Function 'redeemVoucher' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:68:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'redeemVoucher'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš¡ MEDIUM: Function 'redeemVoucher' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:68:14
   â”œâ”€ Detector: gas-griefing
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Mitigate gas griefing in 'redeemVoucher'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.

âš ï¸  HIGH: Function 'redeemVoucher' uses weak randomness source. Uses user address in randomness without commitment scheme. Users can predict outcomes and selectively participate Predictable randomness enables attackers to manipulate outcomes in lotteries, games, or selection processes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:68:14
   â”œâ”€ Detector: insufficient-randomness
   â”œâ”€ CWE: CWE-338
   â””â”€ Fix: Use secure randomness in 'redeemVoucher'. Implement: (1) Chainlink VRF for verifiable randomness, (2) Commit-reveal scheme with multi-block delay, (3) External oracle for random number generation, (4) Avoid block.timestamp, blockhash, or block.number, (5) Use Randao for Ethereum 2.0.

âš¡ MEDIUM: Function 'redeemVoucher' is missing transaction deadline. Missing transaction deadline. Redemption operation 'redeemVoucher' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:68:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'redeemVoucher'. Implement: (1) Add 'deadline' parameter: function redeemVoucher(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

ğŸ”¥ CRITICAL: Function 'redeemVoucher' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:68:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'redeemVoucher'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableVoucherSystem' verifies signatures without chain ID protection. Signatures can be replayed across different EVM chains (mainnet, Arbitrum, Optimism, Polygon, etc.) allowing unauthorized cross-chain actions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:42:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data with chain ID in domain separator:

bytes32 public DOMAIN_SEPARATOR;

constructor() {
DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));
}

function verify(bytes32 structHash, bytes calldata signature) internal view {
bytes32 digest = keccak256(abi.encodePacked(
"\x19\x01",
DOMAIN_SEPARATOR,
structHash
));
address signer = ECDSA.recover(digest, signature);
// verify signer
}

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableVoucherSystem' verifies signatures without chain ID protection. Signatures can be replayed across different EVM chains (mainnet, Arbitrum, Optimism, Polygon, etc.) allowing unauthorized cross-chain actions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:90:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data with chain ID in domain separator:

bytes32 public DOMAIN_SEPARATOR;

constructor() {
DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));
}

function verify(bytes32 structHash, bytes calldata signature) internal view {
bytes32 digest = keccak256(abi.encodePacked(
"\x19\x01",
DOMAIN_SEPARATOR,
structHash
));
address signer = ECDSA.recover(digest, signature);
// verify signer
}

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableVoucherSystem' verifies signatures without chain ID protection. Signatures can be replayed across different EVM chains (mainnet, Arbitrum, Optimism, Polygon, etc.) allowing unauthorized cross-chain actions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:138:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data with chain ID in domain separator:

bytes32 public DOMAIN_SEPARATOR;

constructor() {
DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));
}

function verify(bytes32 structHash, bytes calldata signature) internal view {
bytes32 digest = keccak256(abi.encodePacked(
"\x19\x01",
DOMAIN_SEPARATOR,
structHash
));
address signer = ECDSA.recover(digest, signature);
// verify signer
}

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableVoucherSystem' verifies signatures without chain ID protection. Signatures can be replayed across different EVM chains (mainnet, Arbitrum, Optimism, Polygon, etc.) allowing unauthorized cross-chain actions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:183:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data with chain ID in domain separator:

bytes32 public DOMAIN_SEPARATOR;

constructor() {
DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));
}

function verify(bytes32 structHash, bytes calldata signature) internal view {
bytes32 digest = keccak256(abi.encodePacked(
"\x19\x01",
DOMAIN_SEPARATOR,
structHash
));
address signer = ECDSA.recover(digest, signature);
// verify signer
}

âš ï¸  HIGH: Function 'metaTransfer' in contract 'VulnerableVoucherSystem' constructs hash for signing without chain ID. The resulting signature can be replayed on other chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:26:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in the signed data:

bytes32 hash = keccak256(abi.encode(
block.chainid,  // Chain ID
address(this),  // Contract address
nonce,          // Nonce for replay protection
data
));

âš ï¸  HIGH: Function 'getEthSignedMessageHash' in contract 'VulnerableVoucherSystem' constructs hash for signing without chain ID. The resulting signature can be replayed on other chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:37:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in the signed data:

bytes32 hash = keccak256(abi.encode(
block.chainid,  // Chain ID
address(this),  // Contract address
nonce,          // Nonce for replay protection
data
));

âš ï¸  HIGH: Function 'redeemVoucher' in contract 'VulnerableVoucherSystem' constructs hash for signing without chain ID. The resulting signature can be replayed on other chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:73:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in the signed data:

bytes32 hash = keccak256(abi.encode(
block.chainid,  // Chain ID
address(this),  // Contract address
nonce,          // Nonce for replay protection
data
));

âš ï¸  HIGH: Function 'getEthSignedMessageHash' in contract 'VulnerableVoucherSystem' constructs hash for signing without chain ID. The resulting signature can be replayed on other chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:85:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in the signed data:

bytes32 hash = keccak256(abi.encode(
block.chainid,  // Chain ID
address(this),  // Contract address
nonce,          // Nonce for replay protection
data
));

ğŸ”¥ CRITICAL: Function 'metaTransfer' in contract 'VulnerableVoucherSystem' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:26:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'metaTransfer' in contract 'VulnerableVoucherSystem' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:27:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableVoucherSystem' verifies signatures without chain ID. EIP-7702 delegations could be replayed on other chains where the same contract is deployed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:42:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in signature hash to prevent cross-chain replay:

bytes32 hash = keccak256(abi.encodePacked(
block.chainid,
address(this),
nonce,
data
));

Or use EIP-712 with proper domain separator.

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableVoucherSystem' verifies signatures without chain ID. EIP-7702 delegations could be replayed on other chains where the same contract is deployed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:90:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in signature hash to prevent cross-chain replay:

bytes32 hash = keccak256(abi.encodePacked(
block.chainid,
address(this),
nonce,
data
));

Or use EIP-712 with proper domain separator.

âš ï¸  HIGH: Function 'splitSignature' in contract 'VulnerableVoucherSystem' verifies signatures without chain ID. EIP-7702 delegations could be replayed on other chains where the same contract is deployed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:109:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in signature hash to prevent cross-chain replay:

bytes32 hash = keccak256(abi.encodePacked(
block.chainid,
address(this),
nonce,
data
));

Or use EIP-712 with proper domain separator.

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableVoucherSystem' verifies signatures without chain ID. EIP-7702 delegations could be replayed on other chains where the same contract is deployed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:138:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in signature hash to prevent cross-chain replay:

bytes32 hash = keccak256(abi.encodePacked(
block.chainid,
address(this),
nonce,
data
));

Or use EIP-712 with proper domain separator.

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableVoucherSystem' verifies signatures without chain ID. EIP-7702 delegations could be replayed on other chains where the same contract is deployed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:183:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in signature hash to prevent cross-chain replay:

bytes32 hash = keccak256(abi.encodePacked(
block.chainid,
address(this),
nonce,
data
));

Or use EIP-712 with proper domain separator.

âš ï¸  HIGH: Function 'metaTransfer' in contract 'VulnerableVoucherSystem' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:26:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'getEthSignedMessageHash' in contract 'VulnerableVoucherSystem' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:37:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'redeemVoucher' in contract 'VulnerableVoucherSystem' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:73:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'getEthSignedMessageHash' in contract 'VulnerableVoucherSystem' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:85:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'executeWithSignature' in contract 'VulnerableVoucherSystem' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:119:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'executeWithSignature' in contract 'VulnerableVoucherSystem' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:120:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'executeMetaTransaction' in contract 'VulnerableVoucherSystem' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:169:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'executeMetaTransaction' in contract 'VulnerableVoucherSystem' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:170:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

ğŸ”¥ CRITICAL: Contract 'VulnerableVoucherSystem' allows instant liquidity add/remove without time lock. Attackers can perform JIT liquidity attacks by adding liquidity just before large swaps and removing immediately after to capture fees.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:14:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add time lock for liquidity operations:

mapping(address => uint256) public depositTime;
uint256 public constant MIN_LOCK_TIME = 1 hours;

function addLiquidity(uint256 amount) external {
depositTime[msg.sender] = block.timestamp;
// ... add liquidity
}

function removeLiquidity(uint256 shares) external {
require(
block.timestamp >= depositTime[msg.sender] + MIN_LOCK_TIME,
"Liquidity locked"
);
// ... remove liquidity
}

ğŸ”¥ CRITICAL: Function 'metaTransfer' in contract 'VulnerableVoucherSystem' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:26:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

ğŸ”¥ CRITICAL: Function 'redeemVoucher' in contract 'VulnerableVoucherSystem' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:73:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

ğŸ”¥ CRITICAL: Function 'executeWithSignature' in contract 'VulnerableVoucherSystem' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:119:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

ğŸ”¥ CRITICAL: Function 'executeWithSignature' in contract 'VulnerableVoucherSystem' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:120:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

ğŸ”¥ CRITICAL: Function 'executeMetaTransaction' in contract 'VulnerableVoucherSystem' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:169:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

ğŸ”¥ CRITICAL: Function 'executeMetaTransaction' in contract 'VulnerableVoucherSystem' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:170:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

âš ï¸  HIGH: Constructor in contract 'VulnerableVoucherSystem' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:63:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'metaTransfer' in contract 'VulnerableVoucherSystem' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:26:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'getEthSignedMessageHash' in contract 'VulnerableVoucherSystem' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:37:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'redeemVoucher' in contract 'VulnerableVoucherSystem' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:73:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'getEthSignedMessageHash' in contract 'VulnerableVoucherSystem' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:85:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'executeWithSignature' in contract 'VulnerableVoucherSystem' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:119:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'executeWithSignature' in contract 'VulnerableVoucherSystem' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:120:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'executeMetaTransaction' in contract 'VulnerableVoucherSystem' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:169:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'executeMetaTransaction' in contract 'VulnerableVoucherSystem' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:170:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

âš ï¸  HIGH: Function 'redeemVoucher' in contract 'VulnerableVoucherSystem' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:81:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'executeWithSignature' in contract 'VulnerableVoucherSystem' forwards unlimited gas to external call. Recipient can consume all gas causing out-of-gas revert.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:132:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit gas for external calls:

// Limit gas to prevent griefing
(bool success, ) = recipient.call{value: amount, gas: 10000}("");

// Or use transfer() which limits gas to 2300

âš ï¸  HIGH: Function 'executeMetaTransaction' in contract 'VulnerableVoucherSystem' forwards unlimited gas to external call. Recipient can consume all gas causing out-of-gas revert.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:177:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit gas for external calls:

// Limit gas to prevent griefing
(bool success, ) = recipient.call{value: amount, gas: 10000}("");

// Or use transfer() which limits gas to 2300

âš ï¸  HIGH: Address parameter 'target' in function 'executeWithSignature' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:114:17
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(target != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter 'value' of type 'uint' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:115:17
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Add appropriate range validation for value

âš¡ MEDIUM: Function 'executeWithSignature' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:113:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš ï¸  HIGH: Function 'recoverSigner' verifies signatures without replay protection. Attackers can reuse valid signatures to perform unauthorized actions. This is particularly dangerous in governance systems for vote manipulation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:136:0
   â”œâ”€ Detector: signature-replay
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Implement a nonce system to prevent signature replay attacks. Include a unique nonce in the signed message and track used nonces.

ğŸ”¥ CRITICAL: Function 'executeWithSignature' generates hash/signature without chain ID protection. This allows the same signature to be replayed on different chains, potentially draining funds on all supported chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:113:14
   â”œâ”€ Detector: cross-chain-replay
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include 'block.chainid' in the hash calculation for function 'executeWithSignature'. Example: keccak256(abi.encodePacked(..., block.chainid))

âš ï¸  HIGH: Function 'recoverSigner' uses ECDSA signature verification without malleability protection. Uses ecrecover without checking 's' value against secp256k1 curve order ECDSA signatures have two valid forms (s and -s mod n). Without checking that s is in the lower half range, attackers can create alternate valid signatures for replay attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:136:14
   â”œâ”€ Detector: signature-malleability
   â”œâ”€ CWE: CWE-347
   â””â”€ Fix: Add signature malleability check in 'recoverSigner'. Use OpenZeppelin's ECDSA library or add: `require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "Invalid signature 's' value");` This ensures s is in the lower half of the curve order.

âš ï¸  HIGH: Function 'recoverSigner' Uses ecrecover() without proper EIP-712 domain separator. Signatures are vulnerable to replay attacks across contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:136:14
   â”œâ”€ Detector: missing-eip712-domain
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Implement proper EIP-712 domain separator:
1. Define DOMAIN_SEPARATOR with all required fields (name, version, chainId, verifyingContract)
2. Use structured data hashing with EIP-712
3. Include domain separator in signature hash: keccak256(abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR, structHash))
4. Or use OpenZeppelin's EIP712 implementation

âš ï¸  HIGH: Function 'executeWithSignature' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:113:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'executeWithSignature'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function 'executeWithSignature' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:113:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'executeWithSignature'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš¡ MEDIUM: Function 'executeWithSignature' is missing transaction deadline. Missing transaction deadline. Order execution operation 'executeWithSignature' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:113:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'executeWithSignature'. Implement: (1) Add 'deadline' parameter: function executeWithSignature(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

ğŸ”¥ CRITICAL: Missing access control in 'executeWithSignature' - allows arbitrary execution
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:113:0
   â”œâ”€ Detector: eip7702-delegate-access-control
   â””â”€ Fix: Fix: Add owner/authorization check:

address public owner;

function execute(address target, bytes calldata data) external payable {
require(msg.sender == owner, "Not authorized");
(bool success, ) = target.call{value: msg.value}(data);
require(success, "Call failed");
}

ğŸ”¥ CRITICAL: Function 'executeWithSignature' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:113:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'executeWithSignature'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableSignatureChecker' verifies signatures without chain ID protection. Signatures can be replayed across different EVM chains (mainnet, Arbitrum, Optimism, Polygon, etc.) allowing unauthorized cross-chain actions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:42:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data with chain ID in domain separator:

bytes32 public DOMAIN_SEPARATOR;

constructor() {
DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));
}

function verify(bytes32 structHash, bytes calldata signature) internal view {
bytes32 digest = keccak256(abi.encodePacked(
"\x19\x01",
DOMAIN_SEPARATOR,
structHash
));
address signer = ECDSA.recover(digest, signature);
// verify signer
}

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableSignatureChecker' verifies signatures without chain ID protection. Signatures can be replayed across different EVM chains (mainnet, Arbitrum, Optimism, Polygon, etc.) allowing unauthorized cross-chain actions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:90:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data with chain ID in domain separator:

bytes32 public DOMAIN_SEPARATOR;

constructor() {
DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));
}

function verify(bytes32 structHash, bytes calldata signature) internal view {
bytes32 digest = keccak256(abi.encodePacked(
"\x19\x01",
DOMAIN_SEPARATOR,
structHash
));
address signer = ECDSA.recover(digest, signature);
// verify signer
}

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableSignatureChecker' verifies signatures without chain ID protection. Signatures can be replayed across different EVM chains (mainnet, Arbitrum, Optimism, Polygon, etc.) allowing unauthorized cross-chain actions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:138:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data with chain ID in domain separator:

bytes32 public DOMAIN_SEPARATOR;

constructor() {
DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));
}

function verify(bytes32 structHash, bytes calldata signature) internal view {
bytes32 digest = keccak256(abi.encodePacked(
"\x19\x01",
DOMAIN_SEPARATOR,
structHash
));
address signer = ECDSA.recover(digest, signature);
// verify signer
}

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableSignatureChecker' verifies signatures without chain ID protection. Signatures can be replayed across different EVM chains (mainnet, Arbitrum, Optimism, Polygon, etc.) allowing unauthorized cross-chain actions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:183:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data with chain ID in domain separator:

bytes32 public DOMAIN_SEPARATOR;

constructor() {
DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));
}

function verify(bytes32 structHash, bytes calldata signature) internal view {
bytes32 digest = keccak256(abi.encodePacked(
"\x19\x01",
DOMAIN_SEPARATOR,
structHash
));
address signer = ECDSA.recover(digest, signature);
// verify signer
}

âš ï¸  HIGH: Function 'metaTransfer' in contract 'VulnerableSignatureChecker' constructs hash for signing without chain ID. The resulting signature can be replayed on other chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:26:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in the signed data:

bytes32 hash = keccak256(abi.encode(
block.chainid,  // Chain ID
address(this),  // Contract address
nonce,          // Nonce for replay protection
data
));

âš ï¸  HIGH: Function 'getEthSignedMessageHash' in contract 'VulnerableSignatureChecker' constructs hash for signing without chain ID. The resulting signature can be replayed on other chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:37:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in the signed data:

bytes32 hash = keccak256(abi.encode(
block.chainid,  // Chain ID
address(this),  // Contract address
nonce,          // Nonce for replay protection
data
));

âš ï¸  HIGH: Function 'redeemVoucher' in contract 'VulnerableSignatureChecker' constructs hash for signing without chain ID. The resulting signature can be replayed on other chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:73:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in the signed data:

bytes32 hash = keccak256(abi.encode(
block.chainid,  // Chain ID
address(this),  // Contract address
nonce,          // Nonce for replay protection
data
));

âš ï¸  HIGH: Function 'getEthSignedMessageHash' in contract 'VulnerableSignatureChecker' constructs hash for signing without chain ID. The resulting signature can be replayed on other chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:85:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in the signed data:

bytes32 hash = keccak256(abi.encode(
block.chainid,  // Chain ID
address(this),  // Contract address
nonce,          // Nonce for replay protection
data
));

ğŸ”¥ CRITICAL: Function 'metaTransfer' in contract 'VulnerableSignatureChecker' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:26:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'metaTransfer' in contract 'VulnerableSignatureChecker' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:27:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableSignatureChecker' verifies signatures without chain ID. EIP-7702 delegations could be replayed on other chains where the same contract is deployed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:42:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in signature hash to prevent cross-chain replay:

bytes32 hash = keccak256(abi.encodePacked(
block.chainid,
address(this),
nonce,
data
));

Or use EIP-712 with proper domain separator.

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableSignatureChecker' verifies signatures without chain ID. EIP-7702 delegations could be replayed on other chains where the same contract is deployed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:90:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in signature hash to prevent cross-chain replay:

bytes32 hash = keccak256(abi.encodePacked(
block.chainid,
address(this),
nonce,
data
));

Or use EIP-712 with proper domain separator.

âš ï¸  HIGH: Function 'splitSignature' in contract 'VulnerableSignatureChecker' verifies signatures without chain ID. EIP-7702 delegations could be replayed on other chains where the same contract is deployed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:109:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in signature hash to prevent cross-chain replay:

bytes32 hash = keccak256(abi.encodePacked(
block.chainid,
address(this),
nonce,
data
));

Or use EIP-712 with proper domain separator.

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableSignatureChecker' verifies signatures without chain ID. EIP-7702 delegations could be replayed on other chains where the same contract is deployed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:138:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in signature hash to prevent cross-chain replay:

bytes32 hash = keccak256(abi.encodePacked(
block.chainid,
address(this),
nonce,
data
));

Or use EIP-712 with proper domain separator.

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableSignatureChecker' verifies signatures without chain ID. EIP-7702 delegations could be replayed on other chains where the same contract is deployed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:183:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in signature hash to prevent cross-chain replay:

bytes32 hash = keccak256(abi.encodePacked(
block.chainid,
address(this),
nonce,
data
));

Or use EIP-712 with proper domain separator.

âš ï¸  HIGH: Function 'metaTransfer' in contract 'VulnerableSignatureChecker' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:26:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'getEthSignedMessageHash' in contract 'VulnerableSignatureChecker' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:37:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'redeemVoucher' in contract 'VulnerableSignatureChecker' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:73:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'getEthSignedMessageHash' in contract 'VulnerableSignatureChecker' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:85:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'executeWithSignature' in contract 'VulnerableSignatureChecker' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:119:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'executeWithSignature' in contract 'VulnerableSignatureChecker' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:120:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'executeMetaTransaction' in contract 'VulnerableSignatureChecker' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:169:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'executeMetaTransaction' in contract 'VulnerableSignatureChecker' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:170:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

ğŸ”¥ CRITICAL: Contract 'VulnerableSignatureChecker' allows instant liquidity add/remove without time lock. Attackers can perform JIT liquidity attacks by adding liquidity just before large swaps and removing immediately after to capture fees.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:14:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add time lock for liquidity operations:

mapping(address => uint256) public depositTime;
uint256 public constant MIN_LOCK_TIME = 1 hours;

function addLiquidity(uint256 amount) external {
depositTime[msg.sender] = block.timestamp;
// ... add liquidity
}

function removeLiquidity(uint256 shares) external {
require(
block.timestamp >= depositTime[msg.sender] + MIN_LOCK_TIME,
"Liquidity locked"
);
// ... remove liquidity
}

ğŸ”¥ CRITICAL: Function 'metaTransfer' in contract 'VulnerableSignatureChecker' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:26:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

ğŸ”¥ CRITICAL: Function 'redeemVoucher' in contract 'VulnerableSignatureChecker' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:73:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

ğŸ”¥ CRITICAL: Function 'executeWithSignature' in contract 'VulnerableSignatureChecker' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:119:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

ğŸ”¥ CRITICAL: Function 'executeWithSignature' in contract 'VulnerableSignatureChecker' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:120:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

ğŸ”¥ CRITICAL: Function 'executeMetaTransaction' in contract 'VulnerableSignatureChecker' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:169:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

ğŸ”¥ CRITICAL: Function 'executeMetaTransaction' in contract 'VulnerableSignatureChecker' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:170:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

âš ï¸  HIGH: Constructor in contract 'VulnerableSignatureChecker' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:63:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'metaTransfer' in contract 'VulnerableSignatureChecker' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:26:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'getEthSignedMessageHash' in contract 'VulnerableSignatureChecker' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:37:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'redeemVoucher' in contract 'VulnerableSignatureChecker' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:73:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'getEthSignedMessageHash' in contract 'VulnerableSignatureChecker' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:85:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'executeWithSignature' in contract 'VulnerableSignatureChecker' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:119:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'executeWithSignature' in contract 'VulnerableSignatureChecker' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:120:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'executeMetaTransaction' in contract 'VulnerableSignatureChecker' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:169:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'executeMetaTransaction' in contract 'VulnerableSignatureChecker' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:170:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

âš ï¸  HIGH: Function 'redeemVoucher' in contract 'VulnerableSignatureChecker' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:81:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'executeWithSignature' in contract 'VulnerableSignatureChecker' forwards unlimited gas to external call. Recipient can consume all gas causing out-of-gas revert.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:132:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit gas for external calls:

// Limit gas to prevent griefing
(bool success, ) = recipient.call{value: amount, gas: 10000}("");

// Or use transfer() which limits gas to 2300

âš ï¸  HIGH: Function 'executeMetaTransaction' in contract 'VulnerableSignatureChecker' forwards unlimited gas to external call. Recipient can consume all gas causing out-of-gas revert.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:177:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit gas for external calls:

// Limit gas to prevent griefing
(bool success, ) = recipient.call{value: amount, gas: 10000}("");

// Or use transfer() which limits gas to 2300

âš¡ MEDIUM: Address parameter 'user' in function 'executeMetaTransaction' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:162:17
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(user != address(0), "Zero address not allowed");

âš ï¸  HIGH: Address parameter 'target' in function 'executeMetaTransaction' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:163:17
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(target != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter 'target' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:163:17
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(target != address(0), "Invalid address");

ğŸ“ LOW: Parameter 'value' of type 'uint' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:164:17
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Add appropriate range validation for value

âš¡ MEDIUM: Function 'executeMetaTransaction' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:161:0
   â”œâ”€ Detector: test-governance
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Implement time-delayed voting rights requiring minimum holding periods.

âš ï¸  HIGH: Function 'recoverSigner' verifies signatures without replay protection. Attackers can reuse valid signatures to perform unauthorized actions. This is particularly dangerous in governance systems for vote manipulation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:181:0
   â”œâ”€ Detector: signature-replay
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Implement a nonce system to prevent signature replay attacks. Include a unique nonce in the signed message and track used nonces.

ğŸ”¥ CRITICAL: Function 'executeMetaTransaction' generates hash/signature without chain ID protection. This allows the same signature to be replayed on different chains, potentially draining funds on all supported chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:161:14
   â”œâ”€ Detector: cross-chain-replay
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include 'block.chainid' in the hash calculation for function 'executeMetaTransaction'. Example: keccak256(abi.encodePacked(..., block.chainid))

âš ï¸  HIGH: Function 'recoverSigner' uses ECDSA signature verification without malleability protection. Uses ecrecover without checking 's' value against secp256k1 curve order ECDSA signatures have two valid forms (s and -s mod n). Without checking that s is in the lower half range, attackers can create alternate valid signatures for replay attacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:181:14
   â”œâ”€ Detector: signature-malleability
   â”œâ”€ CWE: CWE-347
   â””â”€ Fix: Add signature malleability check in 'recoverSigner'. Use OpenZeppelin's ECDSA library or add: `require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "Invalid signature 's' value");` This ensures s is in the lower half of the curve order.

âš ï¸  HIGH: Function 'recoverSigner' Uses ecrecover() without proper EIP-712 domain separator. Signatures are vulnerable to replay attacks across contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:181:14
   â”œâ”€ Detector: missing-eip712-domain
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Implement proper EIP-712 domain separator:
1. Define DOMAIN_SEPARATOR with all required fields (name, version, chainId, verifyingContract)
2. Use structured data hashing with EIP-712
3. Include domain separator in signature hash: keccak256(abi.encodePacked("\x19\x01", DOMAIN_SEPARATOR, structHash))
4. Or use OpenZeppelin's EIP712 implementation

âš ï¸  HIGH: Function 'executeMetaTransaction' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:161:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'executeMetaTransaction'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš¡ MEDIUM: Function 'executeMetaTransaction' has nonce management vulnerability. Uses global nonce instead of per-user mapping, forces sequential execution and limits parallelization Improper nonce handling enables replay attacks or transaction reordering exploits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:161:14
   â”œâ”€ Detector: nonce-reuse
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Fix nonce management in 'executeMetaTransaction'. Increment nonce after validation, use mapping(address => uint256) for per-user nonces, validate nonce before execution, include nonce in signature hash, and implement nonce cancellation mechanism.

âš ï¸  HIGH: Function 'executeMetaTransaction' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:161:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'executeMetaTransaction'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš¡ MEDIUM: Function 'executeMetaTransaction' is missing transaction deadline. Missing transaction deadline. Order execution operation 'executeMetaTransaction' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:161:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'executeMetaTransaction'. Implement: (1) Add 'deadline' parameter: function executeMetaTransaction(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

ğŸ”¥ CRITICAL: Missing access control in 'executeMetaTransaction' - allows arbitrary execution
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:161:0
   â”œâ”€ Detector: eip7702-delegate-access-control
   â””â”€ Fix: Fix: Add owner/authorization check:

address public owner;

function execute(address target, bytes calldata data) external payable {
require(msg.sender == owner, "Not authorized");
(bool success, ) = target.call{value: msg.value}(data);
require(success, "Call failed");
}

ğŸ”¥ CRITICAL: Function 'executeMetaTransaction' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:161:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'executeMetaTransaction'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableCrossChain' verifies signatures without chain ID protection. Signatures can be replayed across different EVM chains (mainnet, Arbitrum, Optimism, Polygon, etc.) allowing unauthorized cross-chain actions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:42:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data with chain ID in domain separator:

bytes32 public DOMAIN_SEPARATOR;

constructor() {
DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));
}

function verify(bytes32 structHash, bytes calldata signature) internal view {
bytes32 digest = keccak256(abi.encodePacked(
"\x19\x01",
DOMAIN_SEPARATOR,
structHash
));
address signer = ECDSA.recover(digest, signature);
// verify signer
}

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableCrossChain' verifies signatures without chain ID protection. Signatures can be replayed across different EVM chains (mainnet, Arbitrum, Optimism, Polygon, etc.) allowing unauthorized cross-chain actions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:90:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data with chain ID in domain separator:

bytes32 public DOMAIN_SEPARATOR;

constructor() {
DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));
}

function verify(bytes32 structHash, bytes calldata signature) internal view {
bytes32 digest = keccak256(abi.encodePacked(
"\x19\x01",
DOMAIN_SEPARATOR,
structHash
));
address signer = ECDSA.recover(digest, signature);
// verify signer
}

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableCrossChain' verifies signatures without chain ID protection. Signatures can be replayed across different EVM chains (mainnet, Arbitrum, Optimism, Polygon, etc.) allowing unauthorized cross-chain actions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:138:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data with chain ID in domain separator:

bytes32 public DOMAIN_SEPARATOR;

constructor() {
DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));
}

function verify(bytes32 structHash, bytes calldata signature) internal view {
bytes32 digest = keccak256(abi.encodePacked(
"\x19\x01",
DOMAIN_SEPARATOR,
structHash
));
address signer = ECDSA.recover(digest, signature);
// verify signer
}

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableCrossChain' verifies signatures without chain ID protection. Signatures can be replayed across different EVM chains (mainnet, Arbitrum, Optimism, Polygon, etc.) allowing unauthorized cross-chain actions.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:183:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data with chain ID in domain separator:

bytes32 public DOMAIN_SEPARATOR;

constructor() {
DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));
}

function verify(bytes32 structHash, bytes calldata signature) internal view {
bytes32 digest = keccak256(abi.encodePacked(
"\x19\x01",
DOMAIN_SEPARATOR,
structHash
));
address signer = ECDSA.recover(digest, signature);
// verify signer
}

âš ï¸  HIGH: Function 'metaTransfer' in contract 'VulnerableCrossChain' constructs hash for signing without chain ID. The resulting signature can be replayed on other chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:26:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in the signed data:

bytes32 hash = keccak256(abi.encode(
block.chainid,  // Chain ID
address(this),  // Contract address
nonce,          // Nonce for replay protection
data
));

âš ï¸  HIGH: Function 'getEthSignedMessageHash' in contract 'VulnerableCrossChain' constructs hash for signing without chain ID. The resulting signature can be replayed on other chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:37:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in the signed data:

bytes32 hash = keccak256(abi.encode(
block.chainid,  // Chain ID
address(this),  // Contract address
nonce,          // Nonce for replay protection
data
));

âš ï¸  HIGH: Function 'redeemVoucher' in contract 'VulnerableCrossChain' constructs hash for signing without chain ID. The resulting signature can be replayed on other chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:73:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in the signed data:

bytes32 hash = keccak256(abi.encode(
block.chainid,  // Chain ID
address(this),  // Contract address
nonce,          // Nonce for replay protection
data
));

âš ï¸  HIGH: Function 'getEthSignedMessageHash' in contract 'VulnerableCrossChain' constructs hash for signing without chain ID. The resulting signature can be replayed on other chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:85:1
   â”œâ”€ Detector: cross-chain-replay-protection
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in the signed data:

bytes32 hash = keccak256(abi.encode(
block.chainid,  // Chain ID
address(this),  // Contract address
nonce,          // Nonce for replay protection
data
));

ğŸ”¥ CRITICAL: Function 'metaTransfer' in contract 'VulnerableCrossChain' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:26:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'metaTransfer' in contract 'VulnerableCrossChain' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:27:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableCrossChain' verifies signatures without chain ID. EIP-7702 delegations could be replayed on other chains where the same contract is deployed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:42:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in signature hash to prevent cross-chain replay:

bytes32 hash = keccak256(abi.encodePacked(
block.chainid,
address(this),
nonce,
data
));

Or use EIP-712 with proper domain separator.

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableCrossChain' verifies signatures without chain ID. EIP-7702 delegations could be replayed on other chains where the same contract is deployed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:90:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in signature hash to prevent cross-chain replay:

bytes32 hash = keccak256(abi.encodePacked(
block.chainid,
address(this),
nonce,
data
));

Or use EIP-712 with proper domain separator.

âš ï¸  HIGH: Function 'splitSignature' in contract 'VulnerableCrossChain' verifies signatures without chain ID. EIP-7702 delegations could be replayed on other chains where the same contract is deployed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:109:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in signature hash to prevent cross-chain replay:

bytes32 hash = keccak256(abi.encodePacked(
block.chainid,
address(this),
nonce,
data
));

Or use EIP-712 with proper domain separator.

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableCrossChain' verifies signatures without chain ID. EIP-7702 delegations could be replayed on other chains where the same contract is deployed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:138:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in signature hash to prevent cross-chain replay:

bytes32 hash = keccak256(abi.encodePacked(
block.chainid,
address(this),
nonce,
data
));

Or use EIP-712 with proper domain separator.

âš ï¸  HIGH: Function 'recoverSigner' in contract 'VulnerableCrossChain' verifies signatures without chain ID. EIP-7702 delegations could be replayed on other chains where the same contract is deployed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:183:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Include chain ID in signature hash to prevent cross-chain replay:

bytes32 hash = keccak256(abi.encodePacked(
block.chainid,
address(this),
nonce,
data
));

Or use EIP-712 with proper domain separator.

âš ï¸  HIGH: Function 'metaTransfer' in contract 'VulnerableCrossChain' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:26:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'getEthSignedMessageHash' in contract 'VulnerableCrossChain' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:37:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'redeemVoucher' in contract 'VulnerableCrossChain' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:73:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'getEthSignedMessageHash' in contract 'VulnerableCrossChain' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:85:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'executeWithSignature' in contract 'VulnerableCrossChain' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:119:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'executeWithSignature' in contract 'VulnerableCrossChain' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:120:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'executeMetaTransaction' in contract 'VulnerableCrossChain' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:169:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

âš ï¸  HIGH: Function 'executeMetaTransaction' in contract 'VulnerableCrossChain' builds signature hashes without EIP-712 domain separator. This makes signatures vulnerable to replay across different contracts and chains.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:170:1
   â”œâ”€ Detector: eip7702-replay-vulnerability
   â”œâ”€ CWE: CWE-294
   â””â”€ Fix: Use EIP-712 typed data signing with domain separator:

bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
keccak256(bytes(name)),
keccak256(bytes(version)),
block.chainid,
address(this)
));

ğŸ”¥ CRITICAL: Contract 'VulnerableCrossChain' allows instant liquidity add/remove without time lock. Attackers can perform JIT liquidity attacks by adding liquidity just before large swaps and removing immediately after to capture fees.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:14:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add time lock for liquidity operations:

mapping(address => uint256) public depositTime;
uint256 public constant MIN_LOCK_TIME = 1 hours;

function addLiquidity(uint256 amount) external {
depositTime[msg.sender] = block.timestamp;
// ... add liquidity
}

function removeLiquidity(uint256 shares) external {
require(
block.timestamp >= depositTime[msg.sender] + MIN_LOCK_TIME,
"Liquidity locked"
);
// ... remove liquidity
}

ğŸ”¥ CRITICAL: Function 'metaTransfer' in contract 'VulnerableCrossChain' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:26:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

ğŸ”¥ CRITICAL: Function 'redeemVoucher' in contract 'VulnerableCrossChain' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:73:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

ğŸ”¥ CRITICAL: Function 'executeWithSignature' in contract 'VulnerableCrossChain' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:119:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

ğŸ”¥ CRITICAL: Function 'executeWithSignature' in contract 'VulnerableCrossChain' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:120:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

ğŸ”¥ CRITICAL: Function 'executeMetaTransaction' in contract 'VulnerableCrossChain' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:169:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

ğŸ”¥ CRITICAL: Function 'executeMetaTransaction' in contract 'VulnerableCrossChain' stores mutable bytecode. Different code can be deployed at predictable addresses.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:170:1
   â”œâ”€ Detector: contract-recreation-attack
   â”œâ”€ CWE: CWE-913
   â””â”€ Fix: Use immutable bytecode:

bytes public constant BYTECODE = hex"...";

Or track bytecode hashes:
bytes32 public immutable EXPECTED_CODEHASH;

âš ï¸  HIGH: Constructor in contract 'VulnerableCrossChain' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:63:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'metaTransfer' in contract 'VulnerableCrossChain' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:26:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'getEthSignedMessageHash' in contract 'VulnerableCrossChain' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:37:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'redeemVoucher' in contract 'VulnerableCrossChain' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:73:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'getEthSignedMessageHash' in contract 'VulnerableCrossChain' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:85:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'executeWithSignature' in contract 'VulnerableCrossChain' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:119:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'executeWithSignature' in contract 'VulnerableCrossChain' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:120:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'executeMetaTransaction' in contract 'VulnerableCrossChain' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:169:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'executeMetaTransaction' in contract 'VulnerableCrossChain' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:170:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

âš ï¸  HIGH: Function 'redeemVoucher' in contract 'VulnerableCrossChain' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:81:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'executeWithSignature' in contract 'VulnerableCrossChain' forwards unlimited gas to external call. Recipient can consume all gas causing out-of-gas revert.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:132:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit gas for external calls:

// Limit gas to prevent griefing
(bool success, ) = recipient.call{value: amount, gas: 10000}("");

// Or use transfer() which limits gas to 2300

âš ï¸  HIGH: Function 'executeMetaTransaction' in contract 'VulnerableCrossChain' forwards unlimited gas to external call. Recipient can consume all gas causing out-of-gas revert.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/SignatureReplay.sol:177:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit gas for external calls:

// Limit gas to prevent griefing
(bool success, ) = recipient.call{value: amount, gas: 10000}("");

// Or use transfer() which limits gas to 2300

âš ï¸  HIGH: Function 'drawWinner' may be vulnerable to reentrancy attacks due to state changes after external calls
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:29:14
   â”œâ”€ Detector: classic-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Apply checks-effects-interactions pattern or use a reentrancy guard in function 'drawWinner'

ğŸ”¥ CRITICAL: State variables modified after external call - potential reentrancy affecting state machine
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:37:9
   â”œâ”€ Detector: invalid-state-transition
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Use checks-effects-interactions pattern or reentrancy guards

âš ï¸  HIGH: Array access to 'players' may be out of bounds - index not validated
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:35:26
   â”œâ”€ Detector: array-bounds-check
   â”œâ”€ CWE: CWE-125
   â””â”€ Fix: Add bounds check: require(index < players.length, "Index out of bounds");

âš ï¸  HIGH: Function 'buyTicket' relies on a single oracle source, creating centralization risk
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:22:14
   â”œâ”€ Detector: single-oracle-source
   â”œâ”€ CWE: CWE-693
   â””â”€ Fix: Use multiple oracle sources and implement price aggregation in function 'buyTicket'

âš¡ MEDIUM: External call in function 'buyTicket' does not check return value
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:22:14
   â”œâ”€ Detector: unchecked-external-call
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check the return value of external calls in function 'buyTicket'

âš¡ MEDIUM: External call in function 'drawWinner' does not check return value
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:29:14
   â”œâ”€ Detector: unchecked-external-call
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check the return value of external calls in function 'drawWinner'

âš ï¸  HIGH: Function '' has dangerous timestamp dependency. Uses block.timestamp for randomness or lottery selection, allowing miners to manipulate outcomes by choosing favorable timestamps Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:17:5
   â”œâ”€ Detector: timestamp-manipulation
   â”œâ”€ CWE: CWE-367
   â””â”€ Fix: Reduce timestamp dependency in ''. Use block.number for time intervals, add tolerance ranges (Â±15 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.

âš ï¸  HIGH: Function 'buyTicket' has dangerous timestamp dependency. Uses block.timestamp for randomness or lottery selection, allowing miners to manipulate outcomes by choosing favorable timestamps Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:22:14
   â”œâ”€ Detector: timestamp-manipulation
   â”œâ”€ CWE: CWE-367
   â””â”€ Fix: Reduce timestamp dependency in 'buyTicket'. Use block.number for time intervals, add tolerance ranges (Â±15 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.

âš ï¸  HIGH: Function 'drawWinner' has dangerous timestamp dependency. Uses keccak256 with block variables (timestamp/difficulty/number/prevrandao) for randomness. These values are predictable/manipulable by miners and validators, enabling attacks on randomness-dependent logic. Use Chainlink VRF or commit-reveal schemes instead Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:29:14
   â”œâ”€ Detector: timestamp-manipulation
   â”œâ”€ CWE: CWE-367
   â””â”€ Fix: Reduce timestamp dependency in 'drawWinner'. Use block.number for time intervals, add tolerance ranges (Â±15 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.

âš ï¸  HIGH: Function 'drawWinner' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:29:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'drawWinner'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš¡ MEDIUM: Function 'drawWinner' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:29:14
   â”œâ”€ Detector: gas-griefing
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Mitigate gas griefing in 'drawWinner'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.

âš ï¸  HIGH: Function 'drawWinner' has DOS vulnerability via unbounded operation. Deleting array or mapping without size limit, can exceed gas limit Can cause out-of-gas errors blocking contract functionality.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:29:14
   â”œâ”€ Detector: dos-unbounded-operation
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Fix unbounded operation in 'drawWinner'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.

âš ï¸  HIGH: Function 'drawWinner' uses push pattern for transfers which can cause DoS if recipient reverts. A malicious or buggy recipient contract can block this function by rejecting payments. Use the pull pattern (withdrawal pattern) instead where users withdraw their own funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:29:14
   â”œâ”€ Detector: dos-failed-transfer
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Refactor 'drawWinner' to use pull pattern instead of push. Store pending withdrawals in a mapping and let users withdraw their own funds. Example: balances[user] = amount; then separate withdraw() function. Use OpenZeppelin's PullPayment contract for reference.

ğŸ“ LOW: Inefficient storage pattern detected. Function 'withdraw' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

âš ï¸  HIGH: Function 'buyTicket' lacks front-running protection. Trading function 'buyTicket' missing slippage protection (minAmountOut). Vulnerable to sandwich attacks Front-runners can extract MEV by observing mempool and inserting their transactions before yours.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:22:14
   â”œâ”€ Detector: front-running-mitigation
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add front-running protection to 'buyTicket'. Implement: (1) Commit-reveal scheme with time delay, (2) Deadline parameter for transaction validity, (3) Minimum output amount (slippage protection), (4) Batch auctions or frequent batch auctions (FBA), (5) Private mempool (Flashbots Protect), (6) Time-weighted average pricing (TWAP).

âš ï¸  HIGH: Contract has centralization risk. Contract uses single owner without multi-signature protection. Single private key compromise leads to total contract control Single point of failure can lead to fund loss, governance attacks, or complete system compromise.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:1:0
   â”œâ”€ Detector: centralization-risk
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.

âš ï¸  HIGH: Function '' uses weak randomness source. Uses block.timestamp for randomness generation. Miners can manipulate timestamp within ~15 second range to influence outcome Predictable randomness enables attackers to manipulate outcomes in lotteries, games, or selection processes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:17:5
   â”œâ”€ Detector: insufficient-randomness
   â”œâ”€ CWE: CWE-338
   â””â”€ Fix: Use secure randomness in ''. Implement: (1) Chainlink VRF for verifiable randomness, (2) Commit-reveal scheme with multi-block delay, (3) External oracle for random number generation, (4) Avoid block.timestamp, blockhash, or block.number, (5) Use Randao for Ethereum 2.0.

âš ï¸  HIGH: Function 'buyTicket' uses weak randomness source. Uses block.timestamp for randomness generation. Miners can manipulate timestamp within ~15 second range to influence outcome Predictable randomness enables attackers to manipulate outcomes in lotteries, games, or selection processes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:22:14
   â”œâ”€ Detector: insufficient-randomness
   â”œâ”€ CWE: CWE-338
   â””â”€ Fix: Use secure randomness in 'buyTicket'. Implement: (1) Chainlink VRF for verifiable randomness, (2) Commit-reveal scheme with multi-block delay, (3) External oracle for random number generation, (4) Avoid block.timestamp, blockhash, or block.number, (5) Use Randao for Ethereum 2.0.

âš ï¸  HIGH: Function 'drawWinner' uses weak randomness source. Uses block.timestamp for randomness generation. Miners can manipulate timestamp within ~15 second range to influence outcome Predictable randomness enables attackers to manipulate outcomes in lotteries, games, or selection processes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:29:14
   â”œâ”€ Detector: insufficient-randomness
   â”œâ”€ CWE: CWE-338
   â””â”€ Fix: Use secure randomness in 'drawWinner'. Implement: (1) Chainlink VRF for verifiable randomness, (2) Commit-reveal scheme with multi-block delay, (3) External oracle for random number generation, (4) Avoid block.timestamp, blockhash, or block.number, (5) Use Randao for Ethereum 2.0.

âš¡ MEDIUM: Function 'buyTicket' contains variable shadowing. Parameter 'lotteryEndTime' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:22:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'buyTicket'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Function 'buyTicket' contains variable shadowing. Parameter 'ticketPrice' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:22:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'buyTicket'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Function 'drawWinner' contains variable shadowing. Parameter 'lotteryEndTime' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:29:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'drawWinner'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Function 'drawWinner' contains variable shadowing. Local variable 'winner' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:29:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'drawWinner'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

ğŸ“ LOW: Deprecated function or pattern detected: 'block.difficulty'. block.difficulty deprecated post-merge. Use block.prevrandao instead
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:1:0
   â”œâ”€ Detector: deprecated-functions
   â”œâ”€ CWE: CWE-477
   â””â”€ Fix: Replace deprecated 'block.difficulty'. block.difficulty deprecated post-merge. Use block.prevrandao instead

âš¡ MEDIUM: Function 'drawWinner' contains unsafe type casting. int to uint conversion without sign check. Negative values will wrap to large positive Unsafe type conversions can lead to data loss, value truncation, or unexpected behavior.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:33:0
   â”œâ”€ Detector: unsafe-type-casting
   â”œâ”€ CWE: CWE-704
   â””â”€ Fix: Add safe type casting in 'drawWinner'. Implement: (1) Validate value ranges before casting, (2) Use require() to check bounds, (3) Use SafeCast library from OpenZeppelin, (4) Avoid downcasting without validation, (5) Check for sign preservation in int/uint conversions.

âš¡ MEDIUM: Function 'drawWinner' contains unsafe type casting. uint to int conversion without overflow check. Large values may become negative Unsafe type conversions can lead to data loss, value truncation, or unexpected behavior.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:33:0
   â”œâ”€ Detector: unsafe-type-casting
   â”œâ”€ CWE: CWE-704
   â””â”€ Fix: Add safe type casting in 'drawWinner'. Implement: (1) Validate value ranges before casting, (2) Use require() to check bounds, (3) Use SafeCast library from OpenZeppelin, (4) Avoid downcasting without validation, (5) Check for sign preservation in int/uint conversions.

ğŸ”¥ CRITICAL: Timelock implementation incomplete - missing queue/schedule or execute functions
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:1:1
   â”œâ”€ Detector: time-locked-admin-bypass
   â””â”€ Fix: Implement complete timelock flow: proposeâ†’queueâ†’wait(delay)â†’execute

ğŸ”¥ CRITICAL: Emergency functions bypass timelock without multisig protection
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:1:1
   â”œâ”€ Detector: time-locked-admin-bypass
   â””â”€ Fix: Require multisig approval for emergency functions that bypass timelock

âš¡ MEDIUM: Guardian role lacks explicit revocation mechanism - may be irremovable if compromised
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:1:1
   â”œâ”€ Detector: guardian-role-centralization
   â””â”€ Fix: Implement guardian revocation function callable by DAO/owner for emergency scenarios

âš¡ MEDIUM: Token transfer lacks return data size validation - vulnerable to return bomb DOS
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:1:1
   â”œâ”€ Detector: erc20-transfer-return-bomb
   â””â”€ Fix: Check returndatasize() and reject if excessive (>64 bytes): require(returndatasize() <= 64)

âš¡ MEDIUM: Function 'buyTicket' is missing transaction deadline. Missing transaction deadline. Purchase/Sale operation 'buyTicket' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:22:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'buyTicket'. Implement: (1) Add 'deadline' parameter: function buyTicket(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

ğŸ“ LOW: Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:2:0
   â”œâ”€ Detector: floating-pragma
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.

ğŸ”¥ CRITICAL: Vulnerable to transient storage reentrancy in 'drawWinner' - transfer()/send() no longer safe with EIP-1153
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:29:0
   â”œâ”€ Detector: transient-storage-reentrancy
   â””â”€ Fix: EIP-1153 breaks transfer()/send() safety assumption:

CRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within
the 2300 gas stipend of transfer() and send().

Fix 1: Use checks-effects-interactions pattern
function withdraw() public {
uint256 amount = balances[msg.sender];
require(amount > 0);

// âœ… Update state BEFORE external call
balances[msg.sender] = 0;

payable(msg.sender).transfer(amount);
}

Fix 2: Use ReentrancyGuard
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

function withdraw() public nonReentrant {
uint256 amount = balances[msg.sender];
require(amount > 0);

balances[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

Reference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)

ğŸ”¥ CRITICAL: Classic reentrancy pattern with transient storage risk in 'drawWinner'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:29:0
   â”œâ”€ Detector: transient-storage-reentrancy
   â””â”€ Fix: State update after external call is vulnerable to reentrancy:

Current pattern (VULNERABLE):
1. Read balance
2. Call transfer() â† attacker can reenter here with transient storage!
3. Update balance to 0

Secure pattern:
1. Read balance
2. Update balance to 0 â† do this FIRST
3. Call transfer()

With EIP-1153, even 2300 gas is enough to modify transient state and re-enter.

âš ï¸  HIGH: Potential division before multiplication - causes precision loss (OWASP 2025)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:1:0
   â”œâ”€ Detector: logic-error-patterns
   â””â”€ Fix: âŒ PRECISION LOSS ($63.8M in losses):
uint256 reward = (amount / totalSupply) * rewardRate;
// Result: 0 if amount < totalSupply!

âœ… CORRECT ORDER:
uint256 reward = (amount * rewardRate) / totalSupply;
// Maximizes precision, multiply before divide

âœ… BEST: Use fixed-point math:
uint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;

Real incidents:
- Cork Protocol: $11M (May 2025) - Division rounding
- SIR.trading: $355K (March 2025) - Reward calculation
- Multiple 2024 incidents: $63.8M total

âš¡ MEDIUM: Percentage calculation - verify order of operations for precision
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:1:0
   â”œâ”€ Detector: logic-error-patterns
   â””â”€ Fix: Percentage calculations require careful ordering:

âŒ WRONG (precision loss):
uint256 fee = (amount / 10000) * feePercent;

âœ… CORRECT:
uint256 fee = (amount * feePercent) / 10000;

âœ… BEST (with basis points):
uint256 constant BASIS_POINTS = 10000;
uint256 fee = (amount * feeBasisPoints) / BASIS_POINTS;

Example: 250 basis points = 2.5%
amount = 1000, feeBasisPoints = 250
fee = (1000 * 250) / 10000 = 25 âœ…

WRONG order:
fee = (1000 / 10000) * 250 = 0 * 250 = 0 âŒ

âš¡ MEDIUM: Oracle price usage without time-weighted average - consider TWAP
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:1:0
   â”œâ”€ Detector: oracle-time-window-attack
   â””â”€ Fix: Single-block price oracles are manipulable:

âŒ Vulnerable patterns:
- Using spot price from DEX
- Single block price snapshot
- No time-weighting
- No price deviation checks

âœ… Recommended solutions:

1. Use Uniswap V3 TWAP (30+ minute window)
2. Use Chainlink Price Feeds (aggregated off-chain)
3. Combine multiple oracle sources
4. Implement price deviation bounds:
require(abs(newPrice - lastPrice) < maxDelta);
5. Use time-weighted moving average:
priceSum += currentPrice;
priceCount++;
avgPrice = priceSum / priceCount;

Minimum TWAP window: 30 minutes (longer is better)
Maximum price deviation: 2-5% from last update

âš¡ MEDIUM: Transfer function without zero-value check - validate non-zero amounts
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ MISSING ZERO-VALUE CHECK:
function transfer(address to, uint256 amount) external {
_transfer(msg.sender, to, amount);
// What if amount is 0? Wastes gas, may break accounting
}

âœ… VALIDATE NON-ZERO:
function transfer(address to, uint256 amount) external {
require(amount > 0, "Zero amount");
require(to != address(0), "Zero address");
_transfer(msg.sender, to, amount);
}

âœ… COMPLETE VALIDATION:
function deposit(uint256 amount) external payable {
// For ERC20 deposits
require(amount > 0, "Zero amount");
require(amount <= MAX_DEPOSIT, "Exceeds maximum");

// For native ETH deposits
if (msg.value > 0) {
require(msg.value == amount, "Value mismatch");
}

// Proceed with deposit
}

âš¡ MEDIUM: Address parameter without zero-address validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ MISSING ADDRESS VALIDATION:
function setOwner(address newOwner) external {
owner = newOwner;  // What if newOwner is address(0)?
}

âœ… VALIDATE ADDRESS:
function setOwner(address newOwner) external onlyOwner {
require(newOwner != address(0), "Zero address");
require(newOwner != owner, "Same address");
owner = newOwner;
}

âœ… VALIDATE MULTIPLE ADDRESSES:
function initialize(
address _token,
address _oracle,
address _treasury
) external {
require(_token != address(0), "Zero token");
require(_oracle != address(0), "Zero oracle");
require(_treasury != address(0), "Zero treasury");

// Check for duplicates if needed
require(_token != _oracle, "Token == oracle");
require(_token != _treasury, "Token == treasury");

token = _token;
oracle = _oracle;
treasury = _treasury;
}

âš ï¸  HIGH: Liquidity becomes active immediately - may enable JIT sandwich attacks
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:1:1
   â”œâ”€ Detector: jit-liquidity-sandwich
   â””â”€ Fix: Consider delaying liquidity activation to the next epoch or block to mitigate JIT attacks

âš ï¸  HIGH: No minimum deposit requirement - small deposits may round down to zero shares
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:1:1
   â”œâ”€ Detector: pool-donation-enhanced
   â””â”€ Fix: Enforce minimum deposit amount or minimum shares minted to prevent rounding attacks

âš ï¸  HIGH: Pool initialization lacks protection - first depositor can manipulate initial share price
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:1:1
   â”œâ”€ Detector: pool-donation-enhanced
   â””â”€ Fix: Require minimum initial deposit, mint dead shares on initialization, or use time-delayed activation

ğŸ”¥ CRITICAL: Function 'drawWinner' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:29:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'drawWinner'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

âš¡ MEDIUM: Function 'buyTicket' in contract 'VulnerableLottery' has deadline-based logic without protection against front-running. Attackers can time transactions to maximize their advantage at the deadline.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:24:1
   â”œâ”€ Detector: transaction-ordering-dependence
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add commit-reveal for deadline-sensitive operations:

// Or use time-weighted average to reduce timing advantage

âš¡ MEDIUM: Function 'drawWinner' in contract 'VulnerableLottery' has deadline-based logic without protection against front-running. Attackers can time transactions to maximize their advantage at the deadline.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:30:1
   â”œâ”€ Detector: transaction-ordering-dependence
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add commit-reveal for deadline-sensitive operations:

// Or use time-weighted average to reduce timing advantage

âš¡ MEDIUM: Function 'withdraw' in contract 'VulnerableLottery' has deadline-based logic without protection against front-running. Attackers can time transactions to maximize their advantage at the deadline.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:61:1
   â”œâ”€ Detector: transaction-ordering-dependence
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add commit-reveal for deadline-sensitive operations:

// Or use time-weighted average to reduce timing advantage

ğŸ”¥ CRITICAL: Function 'drawWinner' in contract 'VulnerableLottery' contains transfer patterns that could drain an account's balance. If used as an EIP-7702 delegation target, this could allow attackers to steal all user funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:37:1
   â”œâ”€ Detector: eip7702-delegation-phishing
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Review transfer logic to ensure it cannot be abused:

1. Add explicit amount limits
2. Require user confirmation for large transfers
3. Implement withdrawal patterns instead of push patterns
4. Add rate limiting for transfers

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'VulnerableLottery' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:12:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'lotteryEndTime' (uint) in contract 'VulnerableLottery' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:13:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'players' (address) in contract 'VulnerableLottery' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:14:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'drawWinner' in contract 'VulnerableLottery' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:39:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'deposit' in contract 'VulnerableLottery' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:54:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableLottery' has sweeper-like naming and contains asset transfers. If used as an EIP-7702 delegation target, this could allow draining all assets from the delegating EOA.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: If this is a legitimate rescue function:

1. Add strict access control (onlyOwner, multi-sig)
2. Add timelock delays for large withdrawals
3. Emit events for all asset movements
4. Consider withdrawal limits
5. Document the function's intended use

NEVER use as EIP-7702 delegation target without safeguards.

ğŸ”¥ CRITICAL: Function 'emergencyWithdraw' in contract 'VulnerableLottery' has sweeper-like naming and contains asset transfers. If used as an EIP-7702 delegation target, this could allow draining all assets from the delegating EOA.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: If this is a legitimate rescue function:

1. Add strict access control (onlyOwner, multi-sig)
2. Add timelock delays for large withdrawals
3. Emit events for all asset movements
4. Consider withdrawal limits
5. Document the function's intended use

NEVER use as EIP-7702 delegation target without safeguards.

ğŸ”¥ CRITICAL: Function 'drawWinner' in contract 'VulnerableLottery' transfers the entire ETH balance. This pattern could be exploited in EIP-7702 delegation to drain all ETH from a user's account.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:37:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: Avoid transferring full balance:

1. Use specific amounts instead of address(this).balance
2. Add withdrawal limits and rate limiting
3. Require multi-sig approval for large transfers

ğŸ”¥ CRITICAL: Function 'emergencyWithdraw' in contract 'VulnerableLottery' transfers the entire ETH balance. This pattern could be exploited in EIP-7702 delegation to drain all ETH from a user's account.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:72:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: Avoid transferring full balance:

1. Use specific amounts instead of address(this).balance
2. Add withdrawal limits and rate limiting
3. Require multi-sig approval for large transfers

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableLottery' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

âš ï¸  HIGH: Constructor in contract 'VulnerableLottery' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:17:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'drawWinner' in contract 'VulnerableLottery' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:34:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'generateRandomNumber' in contract 'VulnerableLottery' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:87:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

âš ï¸  HIGH: Function 'withdraw' in contract 'VulnerableLottery' has withdrawal race vulnerability. State changes during withdrawal period can be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:1
   â”œâ”€ Detector: cross-l2-frontrunning
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add withdrawal protection:

1. Use pending/confirmed state pattern
2. Lock funds during withdrawal period
3. Add delay before withdrawal completion
4. Implement challenge mechanism

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableLottery' uses patterns vulnerable to priority gas auctions. Sequencers can exploit ordering for first-mover advantage.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:35:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Avoid PGA-vulnerable patterns:

1. Use batch auctions instead of first-come-first-served
2. Implement commit-reveal for competitive operations
3. Avoid gas price dependencies
4. Consider time-weighted allocation

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableLottery' uses patterns vulnerable to priority gas auctions. Sequencers can exploit ordering for first-mover advantage.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:37:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Avoid PGA-vulnerable patterns:

1. Use batch auctions instead of first-come-first-served
2. Implement commit-reveal for competitive operations
3. Avoid gas price dependencies
4. Consider time-weighted allocation

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableLottery' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableLottery' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableLottery' allows instant withdrawals without queuing. This bypasses the challenge/dispute mechanism.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:1
   â”œâ”€ Detector: challenge-period-bypass
   â”œâ”€ CWE: CWE-367
   â””â”€ Fix: Implement withdrawal queue:

1. Separate withdrawal request from finalization
2. Queue withdrawals with timestamp
3. Require challenge period before claiming
4. Track pending withdrawals per user

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableLottery' uses weak randomness: block.prevrandao/difficulty used as randomness source. Miners/validators can manipulate block variables to influence outcomes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:34:1
   â”œâ”€ Detector: blockhash-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Use secure randomness sources:

1. Chainlink VRF for verifiable randomness
2. Commit-reveal schemes with economic incentives
3. External oracle services
4. RANDAO with proper delay (post-merge)

Example with Chainlink VRF:
uint256 requestId = COORDINATOR.requestRandomWords(...);
// Handle in fulfillRandomWords callback

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableLottery' uses weak randomness: keccak256 hash of block variables for randomness. Miners/validators can manipulate block variables to influence outcomes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:34:1
   â”œâ”€ Detector: blockhash-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Use secure randomness sources:

1. Chainlink VRF for verifiable randomness
2. Commit-reveal schemes with economic incentives
3. External oracle services
4. RANDAO with proper delay (post-merge)

Example with Chainlink VRF:
uint256 requestId = COORDINATOR.requestRandomWords(...);
// Handle in fulfillRandomWords callback

âš ï¸  HIGH: Function 'generateRandomNumber' in contract 'VulnerableLottery' uses weak randomness: block.prevrandao/difficulty used as randomness source. Miners/validators can manipulate block variables to influence outcomes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:89:1
   â”œâ”€ Detector: blockhash-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Use secure randomness sources:

1. Chainlink VRF for verifiable randomness
2. Commit-reveal schemes with economic incentives
3. External oracle services
4. RANDAO with proper delay (post-merge)

Example with Chainlink VRF:
uint256 requestId = COORDINATOR.requestRandomWords(...);
// Handle in fulfillRandomWords callback

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableLottery' appears to be a lottery/game function using on-chain randomness. This is exploitable by miners/validators.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:29:1
   â”œâ”€ Detector: blockhash-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Critical randomness functions require secure sources:

1. Integrate Chainlink VRF v2/v2.5
2. Use commit-reveal with bonded participants
3. Consider hybrid approaches (VRF + commit-reveal)
4. Add delays between action and resolution

âš ï¸  HIGH: Function 'withdraw' in contract 'VulnerableLottery' appears to be a lottery/game function using on-chain randomness. This is exploitable by miners/validators.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:1
   â”œâ”€ Detector: blockhash-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Critical randomness functions require secure sources:

1. Integrate Chainlink VRF v2/v2.5
2. Use commit-reveal with bonded participants
3. Consider hybrid approaches (VRF + commit-reveal)
4. Add delays between action and resolution

âš ï¸  HIGH: Function 'emergencyWithdraw' in contract 'VulnerableLottery' appears to be a lottery/game function using on-chain randomness. This is exploitable by miners/validators.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:1
   â”œâ”€ Detector: blockhash-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Critical randomness functions require secure sources:

1. Integrate Chainlink VRF v2/v2.5
2. Use commit-reveal with bonded participants
3. Consider hybrid approaches (VRF + commit-reveal)
4. Add delays between action and resolution

âš ï¸  HIGH: Function 'generateRandomNumber' in contract 'VulnerableLottery' appears to be a lottery/game function using on-chain randomness. This is exploitable by miners/validators.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:85:1
   â”œâ”€ Detector: blockhash-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Critical randomness functions require secure sources:

1. Integrate Chainlink VRF v2/v2.5
2. Use commit-reveal with bonded participants
3. Consider hybrid approaches (VRF + commit-reveal)
4. Add delays between action and resolution

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableLottery' combines 2 block variables for randomness. Combining predictable values does not create unpredictability - all block variables are known to miners/validators before block finalization.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:34:1
   â”œâ”€ Detector: multi-block-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Combining block variables does NOT improve randomness:

- All block variables are known before finalization
- Miners can try different combinations
- Hash of predictable values is still predictable

Use proper randomness sources:
1. Chainlink VRF for cryptographic randomness
2. Commit-reveal with economic bonds
3. External randomness beacons

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableLottery' uses abi.encode with block variables for randomness. Encoding predictable values produces predictable output.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:34:1
   â”œâ”€ Detector: multi-block-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: abi.encodePacked(block.timestamp, block.number, ...) is NOT random:

All inputs are predictable, so the output is predictable.
Use Chainlink VRF or commit-reveal schemes instead.

âš ï¸  HIGH: Function 'deposit' in contract 'VulnerableLottery' XORs/adds block variables together. Mathematical operations on predictable values remain predictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:54:1
   â”œâ”€ Detector: multi-block-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: XOR/addition of block variables is not secure:

block.timestamp ^ block.number is still predictable.
Use external randomness sources.

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableLottery' uses weak randomness: block.timestamp % N pattern. Miners can manipulate block variables to control modulo outcomes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:34:1
   â”œâ”€ Detector: modulo-block-variable
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: block.timestamp % N is predictable:

- Miners control timestamp within ~15 second range
- For small N, they can easily hit desired values
- block.number increments predictably

Use Chainlink VRF:
uint256 randomIndex = randomWord % arrayLength;

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableLottery' uses weak randomness: block.prevrandao % N pattern. Miners can manipulate block variables to control modulo outcomes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:34:1
   â”œâ”€ Detector: modulo-block-variable
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: block.timestamp % N is predictable:

- Miners control timestamp within ~15 second range
- For small N, they can easily hit desired values
- block.number increments predictably

Use Chainlink VRF:
uint256 randomIndex = randomWord % arrayLength;

âš ï¸  HIGH: Function 'emergencyWithdraw' in contract 'VulnerableLottery' uses weak randomness: block.timestamp % N pattern. Miners can manipulate block variables to control modulo outcomes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:71:1
   â”œâ”€ Detector: modulo-block-variable
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: block.timestamp % N is predictable:

- Miners control timestamp within ~15 second range
- For small N, they can easily hit desired values
- block.number increments predictably

Use Chainlink VRF:
uint256 randomIndex = randomWord % arrayLength;

âš ï¸  HIGH: Function 'buyTicket' in contract 'VulnerableLottery' has DoS vulnerability: Unbounded push to array 'players'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:25:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableLottery' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:37:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'withdraw' in contract 'VulnerableLottery' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:65:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'emergencyWithdraw' in contract 'VulnerableLottery' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:72:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'playGame' in contract 'VulnerableLottery' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:105:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableLottery' depends on external callback behavior. Malicious contracts can force reverts during callbacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:29:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use try-catch for external calls:

try externalContract.callback() {
// success path
} catch {
// failure path - handle gracefully
emit CallbackFailed(target);
}

âš ï¸  HIGH: Function 'emergencyWithdraw' in contract 'VulnerableLottery' depends on external callback behavior. Malicious contracts can force reverts during callbacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use try-catch for external calls:

try externalContract.callback() {
// success path
} catch {
// failure path - handle gracefully
emit CallbackFailed(target);
}

âš ï¸  HIGH: Function 'emergencyWithdraw' may be vulnerable to reentrancy attacks due to state changes after external calls
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:14
   â”œâ”€ Detector: classic-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Apply checks-effects-interactions pattern or use a reentrancy guard in function 'emergencyWithdraw'

ğŸ”¥ CRITICAL: State variables modified after external call - potential reentrancy affecting state machine
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:65:9
   â”œâ”€ Detector: invalid-state-transition
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Use checks-effects-interactions pattern or reentrancy guards

ğŸ”¥ CRITICAL: State variables modified after external call - potential reentrancy affecting state machine
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:72:9
   â”œâ”€ Detector: invalid-state-transition
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Use checks-effects-interactions pattern or reentrancy guards

âš¡ MEDIUM: External call in function 'withdraw' does not check return value
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:14
   â”œâ”€ Detector: unchecked-external-call
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check the return value of external calls in function 'withdraw'

âš¡ MEDIUM: External call in function 'emergencyWithdraw' does not check return value
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:14
   â”œâ”€ Detector: unchecked-external-call
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check the return value of external calls in function 'emergencyWithdraw'

âš ï¸  HIGH: Function 'withdraw' may be vulnerable to withdrawal DOS attack. Withdrawal requires successful external call. Failing calls can permanently block withdrawals. Consider using pull-over-push pattern Attacker can block withdrawals, causing funds to be locked indefinitely.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:14
   â”œâ”€ Detector: vault-withdrawal-dos
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Protect 'withdraw' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.

âš ï¸  HIGH: Function 'emergencyWithdraw' may be vulnerable to withdrawal DOS attack. Withdrawal requires successful external call. Failing calls can permanently block withdrawals. Consider using pull-over-push pattern Attacker can block withdrawals, causing funds to be locked indefinitely.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:14
   â”œâ”€ Detector: vault-withdrawal-dos
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Protect 'emergencyWithdraw' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.

âš ï¸  HIGH: Function 'withdraw' may be vulnerable to hook reentrancy attack. Uses raw transfer() instead of SafeERC20. No protection against malicious token implementations with callback hooks ERC-777/ERC-1363 token callbacks can re-enter and manipulate vault state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:14
   â”œâ”€ Detector: vault-hook-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Protect 'withdraw' from hook reentrancy. Solutions: (1) Add nonReentrant modifier from OpenZeppelin ReentrancyGuard, (2) Follow checks-effects-interactions (CEI) pattern strictly, (3) Update state BEFORE external calls with callbacks, (4) Validate token doesn't implement hooks (ERC-777/ERC-1363/callbacks), (5) Use reentrancy guard on all vault entry points, (6) Consider EIP-1153 transient storage for gas-efficient protection (Solidity 0.8.24+), (7) Use SafeERC20 wrapper library for token operations.

âš ï¸  HIGH: Function 'emergencyWithdraw' may be vulnerable to hook reentrancy attack. State changes after token transfer without reentrancy guard. ERC-777/ERC-1363 callbacks can re-enter before state updates complete ERC-777/ERC-1363 token callbacks can re-enter and manipulate vault state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:14
   â”œâ”€ Detector: vault-hook-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Protect 'emergencyWithdraw' from hook reentrancy. Solutions: (1) Add nonReentrant modifier from OpenZeppelin ReentrancyGuard, (2) Follow checks-effects-interactions (CEI) pattern strictly, (3) Update state BEFORE external calls with callbacks, (4) Validate token doesn't implement hooks (ERC-777/ERC-1363/callbacks), (5) Use reentrancy guard on all vault entry points, (6) Consider EIP-1153 transient storage for gas-efficient protection (Solidity 0.8.24+), (7) Use SafeERC20 wrapper library for token operations.

âš ï¸  HIGH: Function 'deposit' has dangerous timestamp dependency. Performs arithmetic on block.timestamp without overflow protection, potentially manipulable by miners within bounds Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:51:14
   â”œâ”€ Detector: timestamp-manipulation
   â”œâ”€ CWE: CWE-367
   â””â”€ Fix: Reduce timestamp dependency in 'deposit'. Use block.number for time intervals, add tolerance ranges (Â±15 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.

âš ï¸  HIGH: Function 'withdraw' has dangerous timestamp dependency. Critical operations (transfer/mint/burn/withdraw) controlled by timestamp, enabling miners to manipulate timing for advantage Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:14
   â”œâ”€ Detector: timestamp-manipulation
   â”œâ”€ CWE: CWE-367
   â””â”€ Fix: Reduce timestamp dependency in 'withdraw'. Use block.number for time intervals, add tolerance ranges (Â±15 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.

âš ï¸  HIGH: Function 'emergencyWithdraw' has dangerous timestamp dependency. Uses modulo operator on block variables for randomness or decision-making. Block variables are predictable and can be manipulated by miners, leading to biased or exploitable outcomes Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:14
   â”œâ”€ Detector: timestamp-manipulation
   â”œâ”€ CWE: CWE-367
   â””â”€ Fix: Reduce timestamp dependency in 'emergencyWithdraw'. Use block.number for time intervals, add tolerance ranges (Â±15 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.

âš ï¸  HIGH: Function 'withdraw' has withdrawal delay vulnerability. Withdrawal delay has no maximum cap, admin can set arbitrarily long delays locking funds indefinitely Improper withdrawal mechanisms can lock user funds indefinitely or enable denial of service.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:14
   â”œâ”€ Detector: withdrawal-delay
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Fix withdrawal mechanism in 'withdraw'. Implement maximum withdrawal delay caps, add emergency withdrawal options with penalties, prevent admin from extending delays arbitrarily, implement fair queue systems, add partial withdrawal capabilities, and document clear withdrawal timelines.

âš ï¸  HIGH: Function 'emergencyWithdraw' has withdrawal delay vulnerability. Withdrawal delay has no maximum cap, admin can set arbitrarily long delays locking funds indefinitely Improper withdrawal mechanisms can lock user funds indefinitely or enable denial of service.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:14
   â”œâ”€ Detector: withdrawal-delay
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Fix withdrawal mechanism in 'emergencyWithdraw'. Implement maximum withdrawal delay caps, add emergency withdrawal options with penalties, prevent admin from extending delays arbitrarily, implement fair queue systems, add partial withdrawal capabilities, and document clear withdrawal timelines.

âš¡ MEDIUM: Function 'deposit' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:51:14
   â”œâ”€ Detector: gas-griefing
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Mitigate gas griefing in 'deposit'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.

âš¡ MEDIUM: Function 'withdraw' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:14
   â”œâ”€ Detector: gas-griefing
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Mitigate gas griefing in 'withdraw'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.

âš¡ MEDIUM: Function 'emergencyWithdraw' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:14
   â”œâ”€ Detector: gas-griefing
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Mitigate gas griefing in 'emergencyWithdraw'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.

âš ï¸  HIGH: Function 'emergencyWithdraw' uses push pattern for transfers which can cause DoS if recipient reverts. A malicious or buggy recipient contract can block this function by rejecting payments. Use the pull pattern (withdrawal pattern) instead where users withdraw their own funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:14
   â”œâ”€ Detector: dos-failed-transfer
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Refactor 'emergencyWithdraw' to use pull pattern instead of push. Store pending withdrawals in a mapping and let users withdraw their own funds. Example: balances[user] = amount; then separate withdraw() function. Use OpenZeppelin's PullPayment contract for reference.

ğŸ“ LOW: Function 'withdraw' contains excessive gas usage pattern. Multiple storage reads detected (7). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'withdraw'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Function 'emergencyWithdraw' contains excessive gas usage pattern. Multiple storage reads detected (4). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'emergencyWithdraw'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

âš ï¸  HIGH: Function 'emergencyWithdraw' has centralization risk. Emergency function 'emergencyWithdraw' lacks multi-party approval. Can be abused by single compromised key Critical function controlled by single address creates attack vector.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:14
   â”œâ”€ Detector: centralization-risk
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Add decentralization to 'emergencyWithdraw'. Implement multi-signature requirements, timelock delays, or DAO governance for this critical function.

âš¡ MEDIUM: Function 'withdraw' contains variable shadowing. Local variable 'amount' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'withdraw'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Function 'withdraw' is missing transaction deadline. Missing transaction deadline. Withdrawal operation 'withdraw' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'withdraw'. Implement: (1) Add 'deadline' parameter: function withdraw(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

âš¡ MEDIUM: Function 'emergencyWithdraw' is missing transaction deadline. Missing transaction deadline. Withdrawal operation 'emergencyWithdraw' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'emergencyWithdraw'. Implement: (1) Add 'deadline' parameter: function emergencyWithdraw(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

ğŸ”¥ CRITICAL: Vulnerable to transient storage reentrancy in 'withdraw' - transfer()/send() no longer safe with EIP-1153
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:0
   â”œâ”€ Detector: transient-storage-reentrancy
   â””â”€ Fix: EIP-1153 breaks transfer()/send() safety assumption:

CRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within
the 2300 gas stipend of transfer() and send().

Fix 1: Use checks-effects-interactions pattern
function withdraw() public {
uint256 amount = balances[msg.sender];
require(amount > 0);

// âœ… Update state BEFORE external call
balances[msg.sender] = 0;

payable(msg.sender).transfer(amount);
}

Fix 2: Use ReentrancyGuard
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

function withdraw() public nonReentrant {
uint256 amount = balances[msg.sender];
require(amount > 0);

balances[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

Reference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)

ğŸ”¥ CRITICAL: Vulnerable to transient storage reentrancy in 'emergencyWithdraw' - transfer()/send() no longer safe with EIP-1153
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:0
   â”œâ”€ Detector: transient-storage-reentrancy
   â””â”€ Fix: EIP-1153 breaks transfer()/send() safety assumption:

CRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within
the 2300 gas stipend of transfer() and send().

Fix 1: Use checks-effects-interactions pattern
function withdraw() public {
uint256 amount = balances[msg.sender];
require(amount > 0);

// âœ… Update state BEFORE external call
balances[msg.sender] = 0;

payable(msg.sender).transfer(amount);
}

Fix 2: Use ReentrancyGuard
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

function withdraw() public nonReentrant {
uint256 amount = balances[msg.sender];
require(amount > 0);

balances[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

Reference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)

ğŸ”¥ CRITICAL: Classic reentrancy pattern with transient storage risk in 'emergencyWithdraw'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:0
   â”œâ”€ Detector: transient-storage-reentrancy
   â””â”€ Fix: State update after external call is vulnerable to reentrancy:

Current pattern (VULNERABLE):
1. Read balance
2. Call transfer() â† attacker can reenter here with transient storage!
3. Update balance to 0

Secure pattern:
1. Read balance
2. Update balance to 0 â† do this FIRST
3. Call transfer()

With EIP-1153, even 2300 gas is enough to modify transient state and re-enter.

ğŸ”¥ CRITICAL: Function 'withdraw' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'withdraw'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

ğŸ”¥ CRITICAL: Function 'emergencyWithdraw' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'emergencyWithdraw'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

âš¡ MEDIUM: Function 'buyTicket' in contract 'VulnerableTimelock' has deadline-based logic without protection against front-running. Attackers can time transactions to maximize their advantage at the deadline.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:24:1
   â”œâ”€ Detector: transaction-ordering-dependence
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add commit-reveal for deadline-sensitive operations:

// Or use time-weighted average to reduce timing advantage

âš¡ MEDIUM: Function 'drawWinner' in contract 'VulnerableTimelock' has deadline-based logic without protection against front-running. Attackers can time transactions to maximize their advantage at the deadline.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:30:1
   â”œâ”€ Detector: transaction-ordering-dependence
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add commit-reveal for deadline-sensitive operations:

// Or use time-weighted average to reduce timing advantage

âš¡ MEDIUM: Function 'withdraw' in contract 'VulnerableTimelock' has deadline-based logic without protection against front-running. Attackers can time transactions to maximize their advantage at the deadline.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:61:1
   â”œâ”€ Detector: transaction-ordering-dependence
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add commit-reveal for deadline-sensitive operations:

// Or use time-weighted average to reduce timing advantage

ğŸ”¥ CRITICAL: Function 'drawWinner' in contract 'VulnerableTimelock' contains transfer patterns that could drain an account's balance. If used as an EIP-7702 delegation target, this could allow attackers to steal all user funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:37:1
   â”œâ”€ Detector: eip7702-delegation-phishing
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Review transfer logic to ensure it cannot be abused:

1. Add explicit amount limits
2. Require user confirmation for large transfers
3. Implement withdrawal patterns instead of push patterns
4. Add rate limiting for transfers

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'VulnerableTimelock' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:12:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'lotteryEndTime' (uint) in contract 'VulnerableTimelock' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:13:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'players' (address) in contract 'VulnerableTimelock' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:14:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'drawWinner' in contract 'VulnerableTimelock' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:39:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'deposit' in contract 'VulnerableTimelock' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:54:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableTimelock' has sweeper-like naming and contains asset transfers. If used as an EIP-7702 delegation target, this could allow draining all assets from the delegating EOA.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: If this is a legitimate rescue function:

1. Add strict access control (onlyOwner, multi-sig)
2. Add timelock delays for large withdrawals
3. Emit events for all asset movements
4. Consider withdrawal limits
5. Document the function's intended use

NEVER use as EIP-7702 delegation target without safeguards.

ğŸ”¥ CRITICAL: Function 'emergencyWithdraw' in contract 'VulnerableTimelock' has sweeper-like naming and contains asset transfers. If used as an EIP-7702 delegation target, this could allow draining all assets from the delegating EOA.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: If this is a legitimate rescue function:

1. Add strict access control (onlyOwner, multi-sig)
2. Add timelock delays for large withdrawals
3. Emit events for all asset movements
4. Consider withdrawal limits
5. Document the function's intended use

NEVER use as EIP-7702 delegation target without safeguards.

ğŸ”¥ CRITICAL: Function 'drawWinner' in contract 'VulnerableTimelock' transfers the entire ETH balance. This pattern could be exploited in EIP-7702 delegation to drain all ETH from a user's account.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:37:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: Avoid transferring full balance:

1. Use specific amounts instead of address(this).balance
2. Add withdrawal limits and rate limiting
3. Require multi-sig approval for large transfers

ğŸ”¥ CRITICAL: Function 'emergencyWithdraw' in contract 'VulnerableTimelock' transfers the entire ETH balance. This pattern could be exploited in EIP-7702 delegation to drain all ETH from a user's account.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:72:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: Avoid transferring full balance:

1. Use specific amounts instead of address(this).balance
2. Add withdrawal limits and rate limiting
3. Require multi-sig approval for large transfers

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableTimelock' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

âš ï¸  HIGH: Constructor in contract 'VulnerableTimelock' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:17:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'drawWinner' in contract 'VulnerableTimelock' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:34:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'generateRandomNumber' in contract 'VulnerableTimelock' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:87:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

âš ï¸  HIGH: Function 'withdraw' in contract 'VulnerableTimelock' has withdrawal race vulnerability. State changes during withdrawal period can be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:1
   â”œâ”€ Detector: cross-l2-frontrunning
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add withdrawal protection:

1. Use pending/confirmed state pattern
2. Lock funds during withdrawal period
3. Add delay before withdrawal completion
4. Implement challenge mechanism

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableTimelock' uses patterns vulnerable to priority gas auctions. Sequencers can exploit ordering for first-mover advantage.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:35:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Avoid PGA-vulnerable patterns:

1. Use batch auctions instead of first-come-first-served
2. Implement commit-reveal for competitive operations
3. Avoid gas price dependencies
4. Consider time-weighted allocation

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableTimelock' uses patterns vulnerable to priority gas auctions. Sequencers can exploit ordering for first-mover advantage.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:37:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Avoid PGA-vulnerable patterns:

1. Use batch auctions instead of first-come-first-served
2. Implement commit-reveal for competitive operations
3. Avoid gas price dependencies
4. Consider time-weighted allocation

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableTimelock' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableTimelock' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableTimelock' allows instant withdrawals without queuing. This bypasses the challenge/dispute mechanism.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:1
   â”œâ”€ Detector: challenge-period-bypass
   â”œâ”€ CWE: CWE-367
   â””â”€ Fix: Implement withdrawal queue:

1. Separate withdrawal request from finalization
2. Queue withdrawals with timestamp
3. Require challenge period before claiming
4. Track pending withdrawals per user

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableTimelock' uses weak randomness: block.prevrandao/difficulty used as randomness source. Miners/validators can manipulate block variables to influence outcomes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:34:1
   â”œâ”€ Detector: blockhash-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Use secure randomness sources:

1. Chainlink VRF for verifiable randomness
2. Commit-reveal schemes with economic incentives
3. External oracle services
4. RANDAO with proper delay (post-merge)

Example with Chainlink VRF:
uint256 requestId = COORDINATOR.requestRandomWords(...);
// Handle in fulfillRandomWords callback

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableTimelock' uses weak randomness: keccak256 hash of block variables for randomness. Miners/validators can manipulate block variables to influence outcomes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:34:1
   â”œâ”€ Detector: blockhash-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Use secure randomness sources:

1. Chainlink VRF for verifiable randomness
2. Commit-reveal schemes with economic incentives
3. External oracle services
4. RANDAO with proper delay (post-merge)

Example with Chainlink VRF:
uint256 requestId = COORDINATOR.requestRandomWords(...);
// Handle in fulfillRandomWords callback

âš ï¸  HIGH: Function 'generateRandomNumber' in contract 'VulnerableTimelock' uses weak randomness: block.prevrandao/difficulty used as randomness source. Miners/validators can manipulate block variables to influence outcomes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:89:1
   â”œâ”€ Detector: blockhash-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Use secure randomness sources:

1. Chainlink VRF for verifiable randomness
2. Commit-reveal schemes with economic incentives
3. External oracle services
4. RANDAO with proper delay (post-merge)

Example with Chainlink VRF:
uint256 requestId = COORDINATOR.requestRandomWords(...);
// Handle in fulfillRandomWords callback

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableTimelock' appears to be a lottery/game function using on-chain randomness. This is exploitable by miners/validators.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:29:1
   â”œâ”€ Detector: blockhash-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Critical randomness functions require secure sources:

1. Integrate Chainlink VRF v2/v2.5
2. Use commit-reveal with bonded participants
3. Consider hybrid approaches (VRF + commit-reveal)
4. Add delays between action and resolution

âš ï¸  HIGH: Function 'withdraw' in contract 'VulnerableTimelock' appears to be a lottery/game function using on-chain randomness. This is exploitable by miners/validators.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:1
   â”œâ”€ Detector: blockhash-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Critical randomness functions require secure sources:

1. Integrate Chainlink VRF v2/v2.5
2. Use commit-reveal with bonded participants
3. Consider hybrid approaches (VRF + commit-reveal)
4. Add delays between action and resolution

âš ï¸  HIGH: Function 'emergencyWithdraw' in contract 'VulnerableTimelock' appears to be a lottery/game function using on-chain randomness. This is exploitable by miners/validators.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:1
   â”œâ”€ Detector: blockhash-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Critical randomness functions require secure sources:

1. Integrate Chainlink VRF v2/v2.5
2. Use commit-reveal with bonded participants
3. Consider hybrid approaches (VRF + commit-reveal)
4. Add delays between action and resolution

âš ï¸  HIGH: Function 'generateRandomNumber' in contract 'VulnerableTimelock' appears to be a lottery/game function using on-chain randomness. This is exploitable by miners/validators.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:85:1
   â”œâ”€ Detector: blockhash-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Critical randomness functions require secure sources:

1. Integrate Chainlink VRF v2/v2.5
2. Use commit-reveal with bonded participants
3. Consider hybrid approaches (VRF + commit-reveal)
4. Add delays between action and resolution

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableTimelock' combines 2 block variables for randomness. Combining predictable values does not create unpredictability - all block variables are known to miners/validators before block finalization.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:34:1
   â”œâ”€ Detector: multi-block-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Combining block variables does NOT improve randomness:

- All block variables are known before finalization
- Miners can try different combinations
- Hash of predictable values is still predictable

Use proper randomness sources:
1. Chainlink VRF for cryptographic randomness
2. Commit-reveal with economic bonds
3. External randomness beacons

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableTimelock' uses abi.encode with block variables for randomness. Encoding predictable values produces predictable output.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:34:1
   â”œâ”€ Detector: multi-block-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: abi.encodePacked(block.timestamp, block.number, ...) is NOT random:

All inputs are predictable, so the output is predictable.
Use Chainlink VRF or commit-reveal schemes instead.

âš ï¸  HIGH: Function 'deposit' in contract 'VulnerableTimelock' XORs/adds block variables together. Mathematical operations on predictable values remain predictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:54:1
   â”œâ”€ Detector: multi-block-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: XOR/addition of block variables is not secure:

block.timestamp ^ block.number is still predictable.
Use external randomness sources.

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableTimelock' uses weak randomness: block.timestamp % N pattern. Miners can manipulate block variables to control modulo outcomes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:34:1
   â”œâ”€ Detector: modulo-block-variable
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: block.timestamp % N is predictable:

- Miners control timestamp within ~15 second range
- For small N, they can easily hit desired values
- block.number increments predictably

Use Chainlink VRF:
uint256 randomIndex = randomWord % arrayLength;

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableTimelock' uses weak randomness: block.prevrandao % N pattern. Miners can manipulate block variables to control modulo outcomes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:34:1
   â”œâ”€ Detector: modulo-block-variable
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: block.timestamp % N is predictable:

- Miners control timestamp within ~15 second range
- For small N, they can easily hit desired values
- block.number increments predictably

Use Chainlink VRF:
uint256 randomIndex = randomWord % arrayLength;

âš ï¸  HIGH: Function 'emergencyWithdraw' in contract 'VulnerableTimelock' uses weak randomness: block.timestamp % N pattern. Miners can manipulate block variables to control modulo outcomes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:71:1
   â”œâ”€ Detector: modulo-block-variable
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: block.timestamp % N is predictable:

- Miners control timestamp within ~15 second range
- For small N, they can easily hit desired values
- block.number increments predictably

Use Chainlink VRF:
uint256 randomIndex = randomWord % arrayLength;

âš ï¸  HIGH: Function 'buyTicket' in contract 'VulnerableTimelock' has DoS vulnerability: Unbounded push to array 'players'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:25:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableTimelock' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:37:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'withdraw' in contract 'VulnerableTimelock' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:65:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'emergencyWithdraw' in contract 'VulnerableTimelock' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:72:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'playGame' in contract 'VulnerableTimelock' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:105:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableTimelock' depends on external callback behavior. Malicious contracts can force reverts during callbacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:29:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use try-catch for external calls:

try externalContract.callback() {
// success path
} catch {
// failure path - handle gracefully
emit CallbackFailed(target);
}

âš ï¸  HIGH: Function 'emergencyWithdraw' in contract 'VulnerableTimelock' depends on external callback behavior. Malicious contracts can force reverts during callbacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use try-catch for external calls:

try externalContract.callback() {
// success path
} catch {
// failure path - handle gracefully
emit CallbackFailed(target);
}

âš ï¸  HIGH: Function 'generateRandomNumber' has dangerous timestamp dependency. Uses keccak256 with block variables (timestamp/difficulty/number/prevrandao) for randomness. These values are predictable/manipulable by miners and validators, enabling attacks on randomness-dependent logic. Use Chainlink VRF or commit-reveal schemes instead Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:85:14
   â”œâ”€ Detector: timestamp-manipulation
   â”œâ”€ CWE: CWE-367
   â””â”€ Fix: Reduce timestamp dependency in 'generateRandomNumber'. Use block.number for time intervals, add tolerance ranges (Â±15 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.

âš ï¸  HIGH: Function 'generateRandomNumber' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:85:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'generateRandomNumber'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function 'playGame' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:98:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'playGame'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš¡ MEDIUM: Function 'playGame' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:98:14
   â”œâ”€ Detector: gas-griefing
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Mitigate gas griefing in 'playGame'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.

âš ï¸  HIGH: Function 'generateRandomNumber' uses weak randomness source. Uses block.timestamp for randomness generation. Miners can manipulate timestamp within ~15 second range to influence outcome Predictable randomness enables attackers to manipulate outcomes in lotteries, games, or selection processes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:85:14
   â”œâ”€ Detector: insufficient-randomness
   â”œâ”€ CWE: CWE-338
   â””â”€ Fix: Use secure randomness in 'generateRandomNumber'. Implement: (1) Chainlink VRF for verifiable randomness, (2) Commit-reveal scheme with multi-block delay, (3) External oracle for random number generation, (4) Avoid block.timestamp, blockhash, or block.number, (5) Use Randao for Ethereum 2.0.

âš¡ MEDIUM: Function 'generateRandomNumber' contains unsafe type casting. int to uint conversion without sign check. Negative values will wrap to large positive Unsafe type conversions can lead to data loss, value truncation, or unexpected behavior.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:86:0
   â”œâ”€ Detector: unsafe-type-casting
   â”œâ”€ CWE: CWE-704
   â””â”€ Fix: Add safe type casting in 'generateRandomNumber'. Implement: (1) Validate value ranges before casting, (2) Use require() to check bounds, (3) Use SafeCast library from OpenZeppelin, (4) Avoid downcasting without validation, (5) Check for sign preservation in int/uint conversions.

âš¡ MEDIUM: Function 'generateRandomNumber' contains unsafe type casting. uint to int conversion without overflow check. Large values may become negative Unsafe type conversions can lead to data loss, value truncation, or unexpected behavior.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:86:0
   â”œâ”€ Detector: unsafe-type-casting
   â”œâ”€ CWE: CWE-704
   â””â”€ Fix: Add safe type casting in 'generateRandomNumber'. Implement: (1) Validate value ranges before casting, (2) Use require() to check bounds, (3) Use SafeCast library from OpenZeppelin, (4) Avoid downcasting without validation, (5) Check for sign preservation in int/uint conversions.

ğŸ”¥ CRITICAL: Vulnerable to transient storage reentrancy in 'playGame' - transfer()/send() no longer safe with EIP-1153
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:98:0
   â”œâ”€ Detector: transient-storage-reentrancy
   â””â”€ Fix: EIP-1153 breaks transfer()/send() safety assumption:

CRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within
the 2300 gas stipend of transfer() and send().

Fix 1: Use checks-effects-interactions pattern
function withdraw() public {
uint256 amount = balances[msg.sender];
require(amount > 0);

// âœ… Update state BEFORE external call
balances[msg.sender] = 0;

payable(msg.sender).transfer(amount);
}

Fix 2: Use ReentrancyGuard
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

function withdraw() public nonReentrant {
uint256 amount = balances[msg.sender];
require(amount > 0);

balances[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

Reference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)

ğŸ”¥ CRITICAL: Function 'playGame' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:98:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'playGame'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

âš¡ MEDIUM: Function 'buyTicket' in contract 'VulnerableRandomness' has deadline-based logic without protection against front-running. Attackers can time transactions to maximize their advantage at the deadline.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:24:1
   â”œâ”€ Detector: transaction-ordering-dependence
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add commit-reveal for deadline-sensitive operations:

// Or use time-weighted average to reduce timing advantage

âš¡ MEDIUM: Function 'drawWinner' in contract 'VulnerableRandomness' has deadline-based logic without protection against front-running. Attackers can time transactions to maximize their advantage at the deadline.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:30:1
   â”œâ”€ Detector: transaction-ordering-dependence
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add commit-reveal for deadline-sensitive operations:

// Or use time-weighted average to reduce timing advantage

âš¡ MEDIUM: Function 'withdraw' in contract 'VulnerableRandomness' has deadline-based logic without protection against front-running. Attackers can time transactions to maximize their advantage at the deadline.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:61:1
   â”œâ”€ Detector: transaction-ordering-dependence
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add commit-reveal for deadline-sensitive operations:

// Or use time-weighted average to reduce timing advantage

ğŸ”¥ CRITICAL: Function 'drawWinner' in contract 'VulnerableRandomness' contains transfer patterns that could drain an account's balance. If used as an EIP-7702 delegation target, this could allow attackers to steal all user funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:37:1
   â”œâ”€ Detector: eip7702-delegation-phishing
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Review transfer logic to ensure it cannot be abused:

1. Add explicit amount limits
2. Require user confirmation for large transfers
3. Implement withdrawal patterns instead of push patterns
4. Add rate limiting for transfers

ğŸ”¥ CRITICAL: State variable 'owner' (address) in contract 'VulnerableRandomness' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:12:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'lotteryEndTime' (uint) in contract 'VulnerableRandomness' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:13:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: State variable 'players' (address) in contract 'VulnerableRandomness' uses standard storage slots. If this contract is used as an EIP-7702 delegation target, the storage could collide with the EOA's existing state, causing data corruption.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:14:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: For EIP-7702 safe storage:

1. Use EIP-1967 storage slots for critical state:
bytes32 constant SLOT = keccak256("namespace.variable") - 1;

2. Use namespaced storage pattern:
struct Storage { address owner; uint256 balance; }
bytes32 constant STORAGE_SLOT = keccak256("MyContract.storage");

3. Avoid using slot 0 and consecutive slots
4. Document storage layout for delegation safety

ğŸ”¥ CRITICAL: Function 'drawWinner' in contract 'VulnerableRandomness' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:39:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'deposit' in contract 'VulnerableRandomness' writes to storage without using EIP-1967 safe storage patterns. In EIP-7702 delegation context, this could corrupt the delegating account's state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:54:1
   â”œâ”€ Detector: eip7702-storage-corruption
   â”œâ”€ CWE: CWE-119
   â””â”€ Fix: Use assembly with specific storage slots:

bytes32 constant MY_SLOT = keccak256("myapp.myvar");

function _store(uint256 value) internal {
assembly {
sstore(MY_SLOT, value)
}
}

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableRandomness' has sweeper-like naming and contains asset transfers. If used as an EIP-7702 delegation target, this could allow draining all assets from the delegating EOA.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: If this is a legitimate rescue function:

1. Add strict access control (onlyOwner, multi-sig)
2. Add timelock delays for large withdrawals
3. Emit events for all asset movements
4. Consider withdrawal limits
5. Document the function's intended use

NEVER use as EIP-7702 delegation target without safeguards.

ğŸ”¥ CRITICAL: Function 'emergencyWithdraw' in contract 'VulnerableRandomness' has sweeper-like naming and contains asset transfers. If used as an EIP-7702 delegation target, this could allow draining all assets from the delegating EOA.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: If this is a legitimate rescue function:

1. Add strict access control (onlyOwner, multi-sig)
2. Add timelock delays for large withdrawals
3. Emit events for all asset movements
4. Consider withdrawal limits
5. Document the function's intended use

NEVER use as EIP-7702 delegation target without safeguards.

ğŸ”¥ CRITICAL: Function 'drawWinner' in contract 'VulnerableRandomness' transfers the entire ETH balance. This pattern could be exploited in EIP-7702 delegation to drain all ETH from a user's account.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:37:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: Avoid transferring full balance:

1. Use specific amounts instead of address(this).balance
2. Add withdrawal limits and rate limiting
3. Require multi-sig approval for large transfers

ğŸ”¥ CRITICAL: Function 'emergencyWithdraw' in contract 'VulnerableRandomness' transfers the entire ETH balance. This pattern could be exploited in EIP-7702 delegation to drain all ETH from a user's account.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:72:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: Avoid transferring full balance:

1. Use specific amounts instead of address(this).balance
2. Add withdrawal limits and rate limiting
3. Require multi-sig approval for large transfers

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableRandomness' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

âš ï¸  HIGH: Constructor in contract 'VulnerableRandomness' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:17:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Function 'drawWinner' in contract 'VulnerableRandomness' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:34:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

ğŸ”¥ CRITICAL: Function 'generateRandomNumber' in contract 'VulnerableRandomness' constructs bytecode dynamically. Ensure all components are trusted and validated.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:87:1
   â”œâ”€ Detector: initcode-injection
   â”œâ”€ CWE: CWE-94
   â””â”€ Fix: Validate dynamic bytecode components:

1. Use constant/immutable bytecode templates
2. Validate constructor arguments separately
3. Verify final bytecode hash before deployment

âš ï¸  HIGH: Function 'withdraw' in contract 'VulnerableRandomness' has withdrawal race vulnerability. State changes during withdrawal period can be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:1
   â”œâ”€ Detector: cross-l2-frontrunning
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add withdrawal protection:

1. Use pending/confirmed state pattern
2. Lock funds during withdrawal period
3. Add delay before withdrawal completion
4. Implement challenge mechanism

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableRandomness' uses patterns vulnerable to priority gas auctions. Sequencers can exploit ordering for first-mover advantage.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:35:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Avoid PGA-vulnerable patterns:

1. Use batch auctions instead of first-come-first-served
2. Implement commit-reveal for competitive operations
3. Avoid gas price dependencies
4. Consider time-weighted allocation

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableRandomness' uses patterns vulnerable to priority gas auctions. Sequencers can exploit ordering for first-mover advantage.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:37:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Avoid PGA-vulnerable patterns:

1. Use batch auctions instead of first-come-first-served
2. Implement commit-reveal for competitive operations
3. Avoid gas price dependencies
4. Consider time-weighted allocation

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableRandomness' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableRandomness' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdraw' in contract 'VulnerableRandomness' allows instant withdrawals without queuing. This bypasses the challenge/dispute mechanism.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:1
   â”œâ”€ Detector: challenge-period-bypass
   â”œâ”€ CWE: CWE-367
   â””â”€ Fix: Implement withdrawal queue:

1. Separate withdrawal request from finalization
2. Queue withdrawals with timestamp
3. Require challenge period before claiming
4. Track pending withdrawals per user

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableRandomness' uses weak randomness: block.prevrandao/difficulty used as randomness source. Miners/validators can manipulate block variables to influence outcomes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:34:1
   â”œâ”€ Detector: blockhash-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Use secure randomness sources:

1. Chainlink VRF for verifiable randomness
2. Commit-reveal schemes with economic incentives
3. External oracle services
4. RANDAO with proper delay (post-merge)

Example with Chainlink VRF:
uint256 requestId = COORDINATOR.requestRandomWords(...);
// Handle in fulfillRandomWords callback

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableRandomness' uses weak randomness: keccak256 hash of block variables for randomness. Miners/validators can manipulate block variables to influence outcomes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:34:1
   â”œâ”€ Detector: blockhash-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Use secure randomness sources:

1. Chainlink VRF for verifiable randomness
2. Commit-reveal schemes with economic incentives
3. External oracle services
4. RANDAO with proper delay (post-merge)

Example with Chainlink VRF:
uint256 requestId = COORDINATOR.requestRandomWords(...);
// Handle in fulfillRandomWords callback

âš ï¸  HIGH: Function 'generateRandomNumber' in contract 'VulnerableRandomness' uses weak randomness: block.prevrandao/difficulty used as randomness source. Miners/validators can manipulate block variables to influence outcomes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:89:1
   â”œâ”€ Detector: blockhash-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Use secure randomness sources:

1. Chainlink VRF for verifiable randomness
2. Commit-reveal schemes with economic incentives
3. External oracle services
4. RANDAO with proper delay (post-merge)

Example with Chainlink VRF:
uint256 requestId = COORDINATOR.requestRandomWords(...);
// Handle in fulfillRandomWords callback

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableRandomness' appears to be a lottery/game function using on-chain randomness. This is exploitable by miners/validators.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:29:1
   â”œâ”€ Detector: blockhash-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Critical randomness functions require secure sources:

1. Integrate Chainlink VRF v2/v2.5
2. Use commit-reveal with bonded participants
3. Consider hybrid approaches (VRF + commit-reveal)
4. Add delays between action and resolution

âš ï¸  HIGH: Function 'withdraw' in contract 'VulnerableRandomness' appears to be a lottery/game function using on-chain randomness. This is exploitable by miners/validators.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:58:1
   â”œâ”€ Detector: blockhash-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Critical randomness functions require secure sources:

1. Integrate Chainlink VRF v2/v2.5
2. Use commit-reveal with bonded participants
3. Consider hybrid approaches (VRF + commit-reveal)
4. Add delays between action and resolution

âš ï¸  HIGH: Function 'emergencyWithdraw' in contract 'VulnerableRandomness' appears to be a lottery/game function using on-chain randomness. This is exploitable by miners/validators.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:1
   â”œâ”€ Detector: blockhash-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Critical randomness functions require secure sources:

1. Integrate Chainlink VRF v2/v2.5
2. Use commit-reveal with bonded participants
3. Consider hybrid approaches (VRF + commit-reveal)
4. Add delays between action and resolution

âš ï¸  HIGH: Function 'generateRandomNumber' in contract 'VulnerableRandomness' appears to be a lottery/game function using on-chain randomness. This is exploitable by miners/validators.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:85:1
   â”œâ”€ Detector: blockhash-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Critical randomness functions require secure sources:

1. Integrate Chainlink VRF v2/v2.5
2. Use commit-reveal with bonded participants
3. Consider hybrid approaches (VRF + commit-reveal)
4. Add delays between action and resolution

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableRandomness' combines 2 block variables for randomness. Combining predictable values does not create unpredictability - all block variables are known to miners/validators before block finalization.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:34:1
   â”œâ”€ Detector: multi-block-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: Combining block variables does NOT improve randomness:

- All block variables are known before finalization
- Miners can try different combinations
- Hash of predictable values is still predictable

Use proper randomness sources:
1. Chainlink VRF for cryptographic randomness
2. Commit-reveal with economic bonds
3. External randomness beacons

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableRandomness' uses abi.encode with block variables for randomness. Encoding predictable values produces predictable output.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:34:1
   â”œâ”€ Detector: multi-block-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: abi.encodePacked(block.timestamp, block.number, ...) is NOT random:

All inputs are predictable, so the output is predictable.
Use Chainlink VRF or commit-reveal schemes instead.

âš ï¸  HIGH: Function 'deposit' in contract 'VulnerableRandomness' XORs/adds block variables together. Mathematical operations on predictable values remain predictable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:54:1
   â”œâ”€ Detector: multi-block-randomness
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: XOR/addition of block variables is not secure:

block.timestamp ^ block.number is still predictable.
Use external randomness sources.

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableRandomness' uses weak randomness: block.timestamp % N pattern. Miners can manipulate block variables to control modulo outcomes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:34:1
   â”œâ”€ Detector: modulo-block-variable
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: block.timestamp % N is predictable:

- Miners control timestamp within ~15 second range
- For small N, they can easily hit desired values
- block.number increments predictably

Use Chainlink VRF:
uint256 randomIndex = randomWord % arrayLength;

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableRandomness' uses weak randomness: block.prevrandao % N pattern. Miners can manipulate block variables to control modulo outcomes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:34:1
   â”œâ”€ Detector: modulo-block-variable
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: block.timestamp % N is predictable:

- Miners control timestamp within ~15 second range
- For small N, they can easily hit desired values
- block.number increments predictably

Use Chainlink VRF:
uint256 randomIndex = randomWord % arrayLength;

âš ï¸  HIGH: Function 'emergencyWithdraw' in contract 'VulnerableRandomness' uses weak randomness: block.timestamp % N pattern. Miners can manipulate block variables to control modulo outcomes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:71:1
   â”œâ”€ Detector: modulo-block-variable
   â”œâ”€ CWE: CWE-330
   â””â”€ Fix: block.timestamp % N is predictable:

- Miners control timestamp within ~15 second range
- For small N, they can easily hit desired values
- block.number increments predictably

Use Chainlink VRF:
uint256 randomIndex = randomWord % arrayLength;

âš ï¸  HIGH: Function 'buyTicket' in contract 'VulnerableRandomness' has DoS vulnerability: Unbounded push to array 'players'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:25:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableRandomness' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:37:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'withdraw' in contract 'VulnerableRandomness' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:65:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'emergencyWithdraw' in contract 'VulnerableRandomness' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:72:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'playGame' in contract 'VulnerableRandomness' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:105:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'drawWinner' in contract 'VulnerableRandomness' depends on external callback behavior. Malicious contracts can force reverts during callbacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:29:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use try-catch for external calls:

try externalContract.callback() {
// success path
} catch {
// failure path - handle gracefully
emit CallbackFailed(target);
}

âš ï¸  HIGH: Function 'emergencyWithdraw' in contract 'VulnerableRandomness' depends on external callback behavior. Malicious contracts can force reverts during callbacks.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/TimestampDependence.sol:69:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use try-catch for external calls:

try externalContract.callback() {
// success path
} catch {
// failure path - handle gracefully
emit CallbackFailed(target);
}

ğŸ”¥ CRITICAL: State variables modified after external call - potential reentrancy affecting state machine
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:33:9
   â”œâ”€ Detector: invalid-state-transition
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Use checks-effects-interactions pattern or reentrancy guards

âš ï¸  HIGH: Function 'batchPayout' has multiple array parameters but no apparent length validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:14
   â”œâ”€ Detector: array-bounds-check
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Add length validation: require(array1.length == array2.length, "Array length mismatch");

âš¡ MEDIUM: Function 'batchPayout' has related array parameters '_recipients' and '_amounts' that should be validated for equal length
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:14
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Add validation: require(_recipients.length == _amounts.length, "Related arrays must have equal length");

âš ï¸  HIGH: Function 'withdrawWithSend' relies on a single oracle source, creating centralization risk
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:14
   â”œâ”€ Detector: single-oracle-source
   â”œâ”€ CWE: CWE-693
   â””â”€ Fix: Use multiple oracle sources and implement price aggregation in function 'withdrawWithSend'

âš¡ MEDIUM: External call in function 'withdrawWithSend' does not check return value
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:14
   â”œâ”€ Detector: unchecked-external-call
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check the return value of external calls in function 'withdrawWithSend'

âš ï¸  HIGH: Function 'batchPayout' contains external calls within loops. This can lead to DoS attacks if any external call fails or consumes excessive gas, and can be exploited in governance systems to block proposal execution.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:0
   â”œâ”€ Detector: external-calls-loop
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Avoid external calls in loops. Consider using a withdrawal pattern, batch processing, or fail-safe mechanisms for critical operations.

âš ï¸  HIGH: Function 'withdrawUnchecked' may be vulnerable to withdrawal DOS attack. Withdrawal requires successful external call. Failing calls can permanently block withdrawals. Consider using pull-over-push pattern Attacker can block withdrawals, causing funds to be locked indefinitely.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:14
   â”œâ”€ Detector: vault-withdrawal-dos
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Protect 'withdrawUnchecked' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.

âš ï¸  HIGH: Function 'withdrawWithSend' may be vulnerable to withdrawal DOS attack. No withdrawal cap or limit detected. Large withdrawals can drain liquidity and DOS subsequent withdrawers Attacker can block withdrawals, causing funds to be locked indefinitely.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:14
   â”œâ”€ Detector: vault-withdrawal-dos
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Protect 'withdrawWithSend' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.

âš ï¸  HIGH: Function 'batchPayout' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'batchPayout'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function 'batchPayout' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:14
   â”œâ”€ Detector: circular-dependency
   â”œâ”€ CWE: CWE-674
   â””â”€ Fix: Break circular dependency in 'batchPayout'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.

âš¡ MEDIUM: Function 'batchPayout' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:14
   â”œâ”€ Detector: gas-griefing
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Mitigate gas griefing in 'batchPayout'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.

âš ï¸  HIGH: Function 'batchPayout' uses push pattern for transfers which can cause DoS if recipient reverts. A malicious or buggy recipient contract can block this function by rejecting payments. Use the pull pattern (withdrawal pattern) instead where users withdraw their own funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:14
   â”œâ”€ Detector: dos-failed-transfer
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Refactor 'batchPayout' to use pull pattern instead of push. Store pending withdrawals in a mapping and let users withdraw their own funds. Example: balances[user] = amount; then separate withdraw() function. Use OpenZeppelin's PullPayment contract for reference.

ğŸ“ LOW: Function 'withdrawUnchecked' contains excessive gas usage pattern. Multiple storage reads detected (6). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'withdrawUnchecked'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Function 'withdrawWithSend' contains excessive gas usage pattern. Multiple storage reads detected (5). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'withdrawWithSend'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Function 'batchPayout' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'batchPayout'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Inefficient storage pattern detected. Function 'withdrawUnchecked' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Function 'withdrawWithSend' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

âš ï¸  HIGH: Contract has centralization risk. Critical operations (withdraw/pause/upgrade) lack timelock delays. Malicious owner can drain funds or brick contract instantly Single point of failure can lead to fund loss, governance attacks, or complete system compromise.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:1:0
   â”œâ”€ Detector: centralization-risk
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.

ğŸ“ LOW: Deprecated function or pattern detected: '.send'. Use .call{value: amount}("") instead of .send() for better error handling
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:1:0
   â”œâ”€ Detector: deprecated-functions
   â”œâ”€ CWE: CWE-477
   â””â”€ Fix: Replace deprecated '.send'. Use .call{value: amount}("") instead of .send() for better error handling

âš¡ MEDIUM: Token transfer lacks return data size validation - vulnerable to return bomb DOS
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:1:1
   â”œâ”€ Detector: erc20-transfer-return-bomb
   â””â”€ Fix: Check returndatasize() and reject if excessive (>64 bytes): require(returndatasize() <= 64)

âš¡ MEDIUM: Low-level call to token without gas limit - return bomb can exhaust all gas
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:1:1
   â”œâ”€ Detector: erc20-transfer-return-bomb
   â””â”€ Fix: Specify gas limit for calls: token.call{gas: 100000}(abi.encodeWithSelector(...))

ğŸ”¥ CRITICAL: No first depositor protection (inflation attack on vault initialization) in 'deposit'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:13:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Lock initial shares: if (totalSupply() == 0) { _mint(address(0), INITIAL_SHARES); }

ğŸ“ LOW: No deposit cap (unlimited exposure risk) in 'deposit'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:13:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add cap: require(totalAssets() + amount <= depositCap, "Cap exceeded");

âš¡ MEDIUM: No withdrawal fee accounting (fee bypass risk) in 'withdrawUnchecked'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Calculate fee: uint256 fee = (amount * withdrawalFee) / FEE_DENOMINATOR; uint256 amountAfterFee = amount - fee;

âš ï¸  HIGH: Asset calculation missing totalSupply/totalAssets in 'withdrawUnchecked'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Calculate assets: assets = (shares * totalAssets()) / totalSupply();

âš¡ MEDIUM: No withdrawal fee accounting (fee bypass risk) in 'withdrawWithSend'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Calculate fee: uint256 fee = (amount * withdrawalFee) / FEE_DENOMINATOR; uint256 amountAfterFee = amount - fee;

âš ï¸  HIGH: Asset calculation missing totalSupply/totalAssets in 'withdrawWithSend'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Calculate assets: assets = (shares * totalAssets()) / totalSupply();

âš¡ MEDIUM: Function 'withdrawUnchecked' is missing transaction deadline. Missing transaction deadline. Withdrawal operation 'withdrawUnchecked' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'withdrawUnchecked'. Implement: (1) Add 'deadline' parameter: function withdrawUnchecked(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

âš¡ MEDIUM: Function 'withdrawWithSend' is missing transaction deadline. Missing transaction deadline. Withdrawal operation 'withdrawWithSend' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'withdrawWithSend'. Implement: (1) Add 'deadline' parameter: function withdrawWithSend(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

âš ï¸  HIGH: Function 'withdrawWithSend' is vulnerable to ERC-777 hook reentrancy. Interacts with ERC-777 tokens without reentrancy guard Historical losses: $18.8M+ (Cream Finance), $25M (LendfMe), $300k (Uniswap V1).
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:14
   â”œâ”€ Detector: erc777-reentrancy-hooks
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Protect 'withdrawWithSend' from ERC-777 reentrancy. Solutions: (1) Add nonReentrant modifier, (2) Follow checks-effects-interactions pattern, (3) Update state before token transfers, (4) Use pull-over-push pattern

ğŸ“ LOW: Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:2:0
   â”œâ”€ Detector: floating-pragma
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.

ğŸ”¥ CRITICAL: Vulnerable to transient storage reentrancy in 'batchPayout' - transfer()/send() no longer safe with EIP-1153
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:0
   â”œâ”€ Detector: transient-storage-reentrancy
   â””â”€ Fix: EIP-1153 breaks transfer()/send() safety assumption:

CRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within
the 2300 gas stipend of transfer() and send().

Fix 1: Use checks-effects-interactions pattern
function withdraw() public {
uint256 amount = balances[msg.sender];
require(amount > 0);

// âœ… Update state BEFORE external call
balances[msg.sender] = 0;

payable(msg.sender).transfer(amount);
}

Fix 2: Use ReentrancyGuard
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

function withdraw() public nonReentrant {
uint256 amount = balances[msg.sender];
require(amount > 0);

balances[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

Reference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)

ğŸ”¥ CRITICAL: Missing access control in 'batchPayout' - allows arbitrary execution
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:0
   â”œâ”€ Detector: eip7702-delegate-access-control
   â””â”€ Fix: Fix: Add owner/authorization check:

address public owner;

function execute(address target, bytes calldata data) external payable {
require(msg.sender == owner, "Not authorized");
(bool success, ) = target.call{value: msg.value}(data);
require(success, "Call failed");
}

âš¡ MEDIUM: EIP-7702 delegate uses storage - verify no collision with EOA state
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:1:0
   â”œâ”€ Detector: eip7702-storage-collision
   â””â”€ Fix: Use EIP-7201 namespaced storage to avoid collisions:

bytes32 private constant STORAGE_LOCATION = 
keccak256("myprotocol.delegate.storage");

struct DelegateStorage {
address owner;
mapping(address => uint256) balances;
}

function _getStorage() private pure returns (DelegateStorage storage $) {
assembly { $.slot := STORAGE_LOCATION }
}

âš ï¸  HIGH: Unprotected batch execution in 'batchPayout' - phishing risk
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:0
   â”œâ”€ Detector: eip7702-batch-phishing
   â””â”€ Fix: Batch functions without authorization enable phishing:

Attack pattern:
1. Phishing site prompts EIP-7702 delegation
2. Malicious batch function executes multiple calls
3. Drains ETH, all ERC-20s, all NFTs in single transaction
4. User sees only one transaction signature

Fix: Add proper authorization:
function batchExecute(Call[] calldata calls) external {
require(msg.sender == owner, "Not authorized");

for (uint i = 0; i < calls.length; i++) {
(bool success,) = calls[i].target.call(calls[i].data);
require(success, "Call failed");
}
}

ğŸ”¥ CRITICAL: Missing authorization in batch executor 'batchPayout' - anyone can execute arbitrary calls
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:0
   â”œâ”€ Detector: erc7821-batch-authorization
   â””â”€ Fix: Add authorization check:

address public owner;

function executeBatch(
address[] calldata targets,
bytes[] calldata datas
) external {
require(msg.sender == owner, "Not authorized");

for (uint i = 0; i < targets.length; i++) {
(bool success,) = targets[i].call(datas[i]);
require(success);
}
}

âš ï¸  HIGH: ERC-7821 executor missing replay protection - orders can be executed multiple times
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:1:0
   â”œâ”€ Detector: erc7821-replay-protection
   â””â”€ Fix: Add nonce-based replay protection:

mapping(address => uint256) public nonces;

function executeBatch(
uint256 nonce,
bytes calldata signature
) external {
require(nonce == nonces[msg.sender], "Invalid nonce");
nonces[msg.sender]++;

// Execute batch...
}

âš ï¸  HIGH: Potential division before multiplication - causes precision loss (OWASP 2025)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:1:0
   â”œâ”€ Detector: logic-error-patterns
   â””â”€ Fix: âŒ PRECISION LOSS ($63.8M in losses):
uint256 reward = (amount / totalSupply) * rewardRate;
// Result: 0 if amount < totalSupply!

âœ… CORRECT ORDER:
uint256 reward = (amount * rewardRate) / totalSupply;
// Maximizes precision, multiply before divide

âœ… BEST: Use fixed-point math:
uint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;

Real incidents:
- Cork Protocol: $11M (May 2025) - Division rounding
- SIR.trading: $355K (March 2025) - Reward calculation
- Multiple 2024 incidents: $63.8M total

âš¡ MEDIUM: Reward distribution logic detected - verify precision and rounding
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:1:0
   â”œâ”€ Detector: logic-error-patterns
   â””â”€ Fix: Common reward distribution errors:

1. Integer division truncation:
âŒ reward = balance / users;  // Loses remainder
âœ… reward = balance * 1e18 / users / 1e18;

2. Accumulating rounding errors:
âŒ Track individual rewards that sum != total
âœ… Use lastUser = total - sum(others)

3. Division before multiplication:
âŒ (balance / total) * multiplier
âœ… (balance * multiplier) / total

4. Missing remainder handling:
uint256 perUser = total / userCount;
uint256 remainder = total % userCount;
// Handle remainder explicitly!

âš¡ MEDIUM: Transfer function without zero-value check - validate non-zero amounts
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ MISSING ZERO-VALUE CHECK:
function transfer(address to, uint256 amount) external {
_transfer(msg.sender, to, amount);
// What if amount is 0? Wastes gas, may break accounting
}

âœ… VALIDATE NON-ZERO:
function transfer(address to, uint256 amount) external {
require(amount > 0, "Zero amount");
require(to != address(0), "Zero address");
_transfer(msg.sender, to, amount);
}

âœ… COMPLETE VALIDATION:
function deposit(uint256 amount) external payable {
// For ERC20 deposits
require(amount > 0, "Zero amount");
require(amount <= MAX_DEPOSIT, "Exceeds maximum");

// For native ETH deposits
if (msg.value > 0) {
require(msg.value == amount, "Value mismatch");
}

// Proceed with deposit
}

âš¡ MEDIUM: Address parameter without zero-address validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ MISSING ADDRESS VALIDATION:
function setOwner(address newOwner) external {
owner = newOwner;  // What if newOwner is address(0)?
}

âœ… VALIDATE ADDRESS:
function setOwner(address newOwner) external onlyOwner {
require(newOwner != address(0), "Zero address");
require(newOwner != owner, "Same address");
owner = newOwner;
}

âœ… VALIDATE MULTIPLE ADDRESSES:
function initialize(
address _token,
address _oracle,
address _treasury
) external {
require(_token != address(0), "Zero token");
require(_oracle != address(0), "Zero oracle");
require(_treasury != address(0), "Zero treasury");

// Check for duplicates if needed
require(_token != _oracle, "Token == oracle");
require(_token != _treasury, "Token == treasury");

token = _token;
oracle = _oracle;
treasury = _treasury;
}

âš¡ MEDIUM: Unchecked block found - overflows/underflows won't revert (OWASP 2025)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:1:0
   â”œâ”€ Detector: post-080-overflow
   â””â”€ Fix: âš ï¸ UNCHECKED BLOCKS BYPASS SOLIDITY 0.8.0+ PROTECTION!

Solidity 0.8.0+ has automatic overflow/underflow checks,
but 'unchecked' blocks disable this protection.

âŒ DANGEROUS if user input involved:
unchecked {
balance += amount;  // Can overflow!
total = a * b;      // Can overflow!
}

âœ… SAFE usage (loop counters only):
for (uint256 i = 0; i < items.length;) {
// Process items[i]

unchecked {
++i;  // Safe: loop counter can't realistically overflow
}
}

âœ… SAFE usage (guaranteed no overflow):
unchecked {
// Safe: subtraction after comparison
if (a >= b) {
result = a - b;  // No underflow possible
}
}

âŒ NEVER use unchecked for:
- User-supplied values
- Token amounts
- Financial calculations
- Multiplication of arbitrary values

Only use unchecked when:
1. Loop counters (i++, ++i)
2. Mathematically proven safe
3. Gas optimization with careful review

âš ï¸  HIGH: Liquidity removal without time-lock protection - vulnerable to JIT attacks
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:1:1
   â”œâ”€ Detector: jit-liquidity-sandwich
   â””â”€ Fix: Add a minimum lock time for liquidity positions (e.g., 1 block or epoch-based system) to prevent JIT liquidity attacks

âš ï¸  HIGH: Liquidity becomes active immediately - may enable JIT sandwich attacks
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:1:1
   â”œâ”€ Detector: jit-liquidity-sandwich
   â””â”€ Fix: Consider delaying liquidity activation to the next epoch or block to mitigate JIT attacks

âš¡ MEDIUM: No minimum staking duration enforced - allows instant reward farming
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:1:1
   â”œâ”€ Detector: yield-farming-manipulation
   â””â”€ Fix: Add minimum staking duration requirement before allowing reward claims

âš ï¸  HIGH: No minimum deposit requirement - small deposits may round down to zero shares
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:1:1
   â”œâ”€ Detector: pool-donation-enhanced
   â””â”€ Fix: Enforce minimum deposit amount or minimum shares minted to prevent rounding attacks

âš ï¸  HIGH: Pool initialization lacks protection - first depositor can manipulate initial share price
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:1:1
   â”œâ”€ Detector: pool-donation-enhanced
   â””â”€ Fix: Require minimum initial deposit, mint dead shares on initialization, or use time-delayed activation

ğŸ”¥ CRITICAL: Function 'withdrawUnchecked' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'withdrawUnchecked'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

ğŸ”¥ CRITICAL: Function 'withdrawWithSend' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'withdrawWithSend'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

ğŸ”¥ CRITICAL: Function 'batchPayout' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'batchPayout'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

âš¡ MEDIUM: Function 'withdrawWithSend' in contract 'VulnerablePayment' calls send() without checking the return value. send() returns false on failure instead of reverting. The transaction will continue even if the ETH transfer failed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:33:1
   â”œâ”€ Detector: unchecked-send-return
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check send() return value or use transfer()/call():

// Option 1: Check return value
bool success = payable(to).send(amount);
require(success, "Send failed");

// Option 2: Use transfer (reverts on failure)
payable(to).transfer(amount);

// Option 3: Use call (recommended)
(bool success, ) = payable(to).call{value: amount}("");
require(success, "Transfer failed");

ğŸ”¥ CRITICAL: Function 'withdrawUnchecked' in contract 'VulnerablePayment' has sweeper-like naming and contains asset transfers. If used as an EIP-7702 delegation target, this could allow draining all assets from the delegating EOA.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: If this is a legitimate rescue function:

1. Add strict access control (onlyOwner, multi-sig)
2. Add timelock delays for large withdrawals
3. Emit events for all asset movements
4. Consider withdrawal limits
5. Document the function's intended use

NEVER use as EIP-7702 delegation target without safeguards.

ğŸ”¥ CRITICAL: Contract 'VulnerablePayment' allows instant liquidity add/remove without time lock. Attackers can perform JIT liquidity attacks by adding liquidity just before large swaps and removing immediately after to capture fees.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:13:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add time lock for liquidity operations:

mapping(address => uint256) public depositTime;
uint256 public constant MIN_LOCK_TIME = 1 hours;

function addLiquidity(uint256 amount) external {
depositTime[msg.sender] = block.timestamp;
// ... add liquidity
}

function removeLiquidity(uint256 shares) external {
require(
block.timestamp >= depositTime[msg.sender] + MIN_LOCK_TIME,
"Liquidity locked"
);
// ... remove liquidity
}

ğŸ”¥ CRITICAL: Function 'withdrawUnchecked' in contract 'VulnerablePayment' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

ğŸ”¥ CRITICAL: Function 'withdrawWithSend' in contract 'VulnerablePayment' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

âš ï¸  HIGH: Function 'withdrawUnchecked' in contract 'VulnerablePayment' has withdrawal race vulnerability. State changes during withdrawal period can be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: cross-l2-frontrunning
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add withdrawal protection:

1. Use pending/confirmed state pattern
2. Lock funds during withdrawal period
3. Add delay before withdrawal completion
4. Implement challenge mechanism

âš ï¸  HIGH: Function 'withdrawWithSend' in contract 'VulnerablePayment' has withdrawal race vulnerability. State changes during withdrawal period can be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:1
   â”œâ”€ Detector: cross-l2-frontrunning
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add withdrawal protection:

1. Use pending/confirmed state pattern
2. Lock funds during withdrawal period
3. Add delay before withdrawal completion
4. Implement challenge mechanism

âš ï¸  HIGH: Function 'batchPayout' in contract 'VulnerablePayment' performs batch operations that sequencers could exploit through partial execution ordering.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Improve batch operation safety:

1. Make batch operations atomic (all-or-nothing)
2. Add revert on partial failure
3. Implement batch ordering guarantees
4. Consider splitting into individual transactions

ğŸ”¥ CRITICAL: Function 'withdrawUnchecked' in contract 'VulnerablePayment' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdrawUnchecked' in contract 'VulnerablePayment' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdrawWithSend' in contract 'VulnerablePayment' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdrawWithSend' in contract 'VulnerablePayment' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimReward' in contract 'VulnerablePayment' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimReward' in contract 'VulnerablePayment' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

âš ï¸  HIGH: Function 'withdrawUnchecked' in contract 'VulnerablePayment' may be vulnerable to cross-chain double-spend. Balances updated before cross-chain confirmation could be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: cross-rollup-state-mismatch
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Prevent double-spending:

1. Lock funds during cross-chain transfers
2. Use pending/confirmed state pattern
3. Implement nullifiers for withdrawal claims
4. Update balances only after confirmation

âš ï¸  HIGH: Function 'withdrawWithSend' in contract 'VulnerablePayment' may be vulnerable to cross-chain double-spend. Balances updated before cross-chain confirmation could be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:1
   â”œâ”€ Detector: cross-rollup-state-mismatch
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Prevent double-spending:

1. Lock funds during cross-chain transfers
2. Use pending/confirmed state pattern
3. Implement nullifiers for withdrawal claims
4. Update balances only after confirmation

âš ï¸  HIGH: Function 'batchPayout' in contract 'VulnerablePayment' performs gas-intensive operations in a loop. This can exceed block gas limit with large arrays.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:40:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Move gas-intensive operations outside loops:

1. Use pull pattern for transfers
2. Batch operations with limits
3. Use events for off-chain processing
4. Consider withdrawal patterns

âš ï¸  HIGH: Function 'batchPayout' in contract 'VulnerablePayment' has DoS vulnerability: call() in loop. A single malicious or failing recipient can block the entire operation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:40:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use pull-over-push pattern:

// Instead of:
for (uint i = 0; i < recipients.length; i++) {
recipients[i].transfer(amounts[i]); // DoS risk
}

// Use:
mapping(address => uint256) pendingWithdrawals;

function withdraw() external {
uint256 amount = pendingWithdrawals[msg.sender];
pendingWithdrawals[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

âš ï¸  HIGH: Function 'batchPayout' in contract 'VulnerablePayment' uses push payment pattern for distribution. Single failing recipient will revert entire distribution.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Convert to pull payment pattern:

1. Store amounts in mapping instead of sending
2. Let recipients claim their share
3. Or use try-catch with failure tracking:

try recipient.call{value: amount}("") {
// success
} catch {
failedPayments[recipient] = amount;
}

âš ï¸  HIGH: Function 'batchPayout' in contract 'VulnerablePayment' makes batch external calls without error handling. Single failure will revert the entire batch.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Add error handling for batch operations:

for (uint i = 0; i < targets.length; i++) {
try IContract(targets[i]).method() {
// handle success
} catch {
// log failure, continue
emit BatchCallFailed(targets[i]);
}
}

âš ï¸  HIGH: Function 'batchPayout' in contract 'VulnerablePayment' has gas limit risk: Unbounded loop with gas-intensive operations. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:40:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'withdrawWithSend' in contract 'VulnerablePayment' has revert bomb risk: send() return value unchecked. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:33:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'claimReward' in contract 'VulnerablePayment' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:73:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'withdrawUnchecked' in contract 'VulnerablePayment' forwards unlimited gas to external call. Recipient can consume all gas causing out-of-gas revert.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:23:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit gas for external calls:

// Limit gas to prevent griefing
(bool success, ) = recipient.call{value: amount, gas: 10000}("");

// Or use transfer() which limits gas to 2300

âš ï¸  HIGH: Function 'batchPayout' in contract 'VulnerablePayment' forwards unlimited gas to external call. Recipient can consume all gas causing out-of-gas revert.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:42:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit gas for external calls:

// Limit gas to prevent griefing
(bool success, ) = recipient.call{value: amount, gas: 10000}("");

// Or use transfer() which limits gas to 2300

âš¡ MEDIUM: Function 'executeAction' is missing transaction deadline. Missing transaction deadline. Order execution operation 'executeAction' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:52:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'executeAction'. Implement: (1) Add 'deadline' parameter: function executeAction(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

âš¡ MEDIUM: Function 'withdrawWithSend' in contract 'IExternalContract' calls send() without checking the return value. send() returns false on failure instead of reverting. The transaction will continue even if the ETH transfer failed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:33:1
   â”œâ”€ Detector: unchecked-send-return
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check send() return value or use transfer()/call():

// Option 1: Check return value
bool success = payable(to).send(amount);
require(success, "Send failed");

// Option 2: Use transfer (reverts on failure)
payable(to).transfer(amount);

// Option 3: Use call (recommended)
(bool success, ) = payable(to).call{value: amount}("");
require(success, "Transfer failed");

ğŸ”¥ CRITICAL: Function 'withdrawUnchecked' in contract 'IExternalContract' has sweeper-like naming and contains asset transfers. If used as an EIP-7702 delegation target, this could allow draining all assets from the delegating EOA.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: If this is a legitimate rescue function:

1. Add strict access control (onlyOwner, multi-sig)
2. Add timelock delays for large withdrawals
3. Emit events for all asset movements
4. Consider withdrawal limits
5. Document the function's intended use

NEVER use as EIP-7702 delegation target without safeguards.

ğŸ”¥ CRITICAL: Contract 'IExternalContract' allows instant liquidity add/remove without time lock. Attackers can perform JIT liquidity attacks by adding liquidity just before large swaps and removing immediately after to capture fees.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:13:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add time lock for liquidity operations:

mapping(address => uint256) public depositTime;
uint256 public constant MIN_LOCK_TIME = 1 hours;

function addLiquidity(uint256 amount) external {
depositTime[msg.sender] = block.timestamp;
// ... add liquidity
}

function removeLiquidity(uint256 shares) external {
require(
block.timestamp >= depositTime[msg.sender] + MIN_LOCK_TIME,
"Liquidity locked"
);
// ... remove liquidity
}

ğŸ”¥ CRITICAL: Function 'withdrawUnchecked' in contract 'IExternalContract' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

ğŸ”¥ CRITICAL: Function 'withdrawWithSend' in contract 'IExternalContract' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

âš ï¸  HIGH: Function 'withdrawUnchecked' in contract 'IExternalContract' has withdrawal race vulnerability. State changes during withdrawal period can be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: cross-l2-frontrunning
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add withdrawal protection:

1. Use pending/confirmed state pattern
2. Lock funds during withdrawal period
3. Add delay before withdrawal completion
4. Implement challenge mechanism

âš ï¸  HIGH: Function 'withdrawWithSend' in contract 'IExternalContract' has withdrawal race vulnerability. State changes during withdrawal period can be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:1
   â”œâ”€ Detector: cross-l2-frontrunning
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add withdrawal protection:

1. Use pending/confirmed state pattern
2. Lock funds during withdrawal period
3. Add delay before withdrawal completion
4. Implement challenge mechanism

âš ï¸  HIGH: Function 'batchPayout' in contract 'IExternalContract' performs batch operations that sequencers could exploit through partial execution ordering.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Improve batch operation safety:

1. Make batch operations atomic (all-or-nothing)
2. Add revert on partial failure
3. Implement batch ordering guarantees
4. Consider splitting into individual transactions

ğŸ”¥ CRITICAL: Function 'withdrawUnchecked' in contract 'IExternalContract' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdrawUnchecked' in contract 'IExternalContract' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdrawWithSend' in contract 'IExternalContract' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdrawWithSend' in contract 'IExternalContract' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimReward' in contract 'IExternalContract' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimReward' in contract 'IExternalContract' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

âš ï¸  HIGH: Function 'withdrawUnchecked' in contract 'IExternalContract' may be vulnerable to cross-chain double-spend. Balances updated before cross-chain confirmation could be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: cross-rollup-state-mismatch
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Prevent double-spending:

1. Lock funds during cross-chain transfers
2. Use pending/confirmed state pattern
3. Implement nullifiers for withdrawal claims
4. Update balances only after confirmation

âš ï¸  HIGH: Function 'withdrawWithSend' in contract 'IExternalContract' may be vulnerable to cross-chain double-spend. Balances updated before cross-chain confirmation could be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:1
   â”œâ”€ Detector: cross-rollup-state-mismatch
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Prevent double-spending:

1. Lock funds during cross-chain transfers
2. Use pending/confirmed state pattern
3. Implement nullifiers for withdrawal claims
4. Update balances only after confirmation

âš ï¸  HIGH: Function 'batchPayout' in contract 'IExternalContract' performs gas-intensive operations in a loop. This can exceed block gas limit with large arrays.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:40:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Move gas-intensive operations outside loops:

1. Use pull pattern for transfers
2. Batch operations with limits
3. Use events for off-chain processing
4. Consider withdrawal patterns

âš ï¸  HIGH: Function 'batchPayout' in contract 'IExternalContract' has DoS vulnerability: call() in loop. A single malicious or failing recipient can block the entire operation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:40:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use pull-over-push pattern:

// Instead of:
for (uint i = 0; i < recipients.length; i++) {
recipients[i].transfer(amounts[i]); // DoS risk
}

// Use:
mapping(address => uint256) pendingWithdrawals;

function withdraw() external {
uint256 amount = pendingWithdrawals[msg.sender];
pendingWithdrawals[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

âš ï¸  HIGH: Function 'batchPayout' in contract 'IExternalContract' uses push payment pattern for distribution. Single failing recipient will revert entire distribution.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Convert to pull payment pattern:

1. Store amounts in mapping instead of sending
2. Let recipients claim their share
3. Or use try-catch with failure tracking:

try recipient.call{value: amount}("") {
// success
} catch {
failedPayments[recipient] = amount;
}

âš ï¸  HIGH: Function 'batchPayout' in contract 'IExternalContract' makes batch external calls without error handling. Single failure will revert the entire batch.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Add error handling for batch operations:

for (uint i = 0; i < targets.length; i++) {
try IContract(targets[i]).method() {
// handle success
} catch {
// log failure, continue
emit BatchCallFailed(targets[i]);
}
}

âš ï¸  HIGH: Function 'batchPayout' in contract 'IExternalContract' has gas limit risk: Unbounded loop with gas-intensive operations. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:40:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'withdrawWithSend' in contract 'IExternalContract' has revert bomb risk: send() return value unchecked. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:33:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'claimReward' in contract 'IExternalContract' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:73:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'withdrawUnchecked' in contract 'IExternalContract' forwards unlimited gas to external call. Recipient can consume all gas causing out-of-gas revert.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:23:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit gas for external calls:

// Limit gas to prevent griefing
(bool success, ) = recipient.call{value: amount, gas: 10000}("");

// Or use transfer() which limits gas to 2300

âš ï¸  HIGH: Function 'batchPayout' in contract 'IExternalContract' forwards unlimited gas to external call. Recipient can consume all gas causing out-of-gas revert.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:42:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit gas for external calls:

// Limit gas to prevent griefing
(bool success, ) = recipient.call{value: amount, gas: 10000}("");

// Or use transfer() which limits gas to 2300

ğŸ”¥ CRITICAL: Function 'claimReward' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'claimReward'

ğŸ”¥ CRITICAL: Function 'setReward' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:76:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'setReward'

âš ï¸  HIGH: Function 'claimReward' may be vulnerable to reentrancy attacks due to state changes after external calls
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:14
   â”œâ”€ Detector: classic-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Apply checks-effects-interactions pattern or use a reentrancy guard in function 'claimReward'

ğŸ”¥ CRITICAL: State variables modified after external call - potential reentrancy affecting state machine
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:73:9
   â”œâ”€ Detector: invalid-state-transition
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Use checks-effects-interactions pattern or reentrancy guards

âš¡ MEDIUM: Address parameter '_user' in function 'setReward' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:76:32
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_user != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter '_user' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:76:32
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_user != address(0), "Invalid address");

ğŸ“ LOW: Parameter '_amount' of type 'uint' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:76:47
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_amount > 0, "Amount must be positive");

âš ï¸  HIGH: Function 'claimReward' relies on a single oracle source, creating centralization risk
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:14
   â”œâ”€ Detector: single-oracle-source
   â”œâ”€ CWE: CWE-693
   â””â”€ Fix: Use multiple oracle sources and implement price aggregation in function 'claimReward'

âš¡ MEDIUM: External call in function 'claimReward' does not check return value
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:14
   â”œâ”€ Detector: unchecked-external-call
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check the return value of external calls in function 'claimReward'

âš ï¸  HIGH: Function 'claimReward' may be vulnerable to withdrawal DOS attack. Withdrawal requires successful external call. Failing calls can permanently block withdrawals. Consider using pull-over-push pattern Attacker can block withdrawals, causing funds to be locked indefinitely.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:14
   â”œâ”€ Detector: vault-withdrawal-dos
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Protect 'claimReward' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.

âš ï¸  HIGH: Function 'claimReward' may be vulnerable to hook reentrancy attack. Uses raw transfer() instead of SafeERC20. No protection against malicious token implementations with callback hooks ERC-777/ERC-1363 token callbacks can re-enter and manipulate vault state.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:14
   â”œâ”€ Detector: vault-hook-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Protect 'claimReward' from hook reentrancy. Solutions: (1) Add nonReentrant modifier from OpenZeppelin ReentrancyGuard, (2) Follow checks-effects-interactions (CEI) pattern strictly, (3) Update state BEFORE external calls with callbacks, (4) Validate token doesn't implement hooks (ERC-777/ERC-1363/callbacks), (5) Use reentrancy guard on all vault entry points, (6) Consider EIP-1153 transient storage for gas-efficient protection (Solidity 0.8.24+), (7) Use SafeERC20 wrapper library for token operations.

âš ï¸  HIGH: Function 'claimReward' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'claimReward'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function 'setReward' has extractable MEV. Reward distribution without commit-reveal, enables front-running of reward claims Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:76:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'setReward'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function 'claimReward' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:14
   â”œâ”€ Detector: validator-front-running
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate validator front-running in 'claimReward'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.

âš ï¸  HIGH: Function 'setReward' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:76:14
   â”œâ”€ Detector: validator-front-running
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate validator front-running in 'setReward'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.

âš¡ MEDIUM: Function 'claimReward' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:14
   â”œâ”€ Detector: gas-griefing
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Mitigate gas griefing in 'claimReward'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.

âš¡ MEDIUM: Function 'claimReward' contains variable shadowing. Parameter 'reward' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'claimReward'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš¡ MEDIUM: Function 'claimReward' contains variable shadowing. Local variable 'reward' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'claimReward'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

âš ï¸  HIGH: Reward calculation doesn't account for totalSupply in 'claimReward'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Calculate rewards: rewardPerToken = (rewardRate * timeDelta * 1e18) / totalSupply;

âš ï¸  HIGH: No timestamp tracking for reward accrual in 'claimReward'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Track time: lastUpdateTime = block.timestamp; Use for accurate reward calculation

ğŸ”¥ CRITICAL: Missing reward debt tracking (double-claim risk) in 'claimReward'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Track debt: userRewardDebt[user] = (userBalance * rewardPerToken) / 1e18;

âš¡ MEDIUM: Reward calculation without precision multiplier (rounding errors) in 'claimReward'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add precision: Use 1e18 multiplier for reward calculations to minimize rounding errors

âš ï¸  HIGH: Reward calculation doesn't account for totalSupply in 'setReward'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:76:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Calculate rewards: rewardPerToken = (rewardRate * timeDelta * 1e18) / totalSupply;

âš ï¸  HIGH: No timestamp tracking for reward accrual in 'setReward'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:76:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Track time: lastUpdateTime = block.timestamp; Use for accurate reward calculation

ğŸ”¥ CRITICAL: Missing reward debt tracking (double-claim risk) in 'setReward'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:76:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Track debt: userRewardDebt[user] = (userBalance * rewardPerToken) / 1e18;

âš¡ MEDIUM: Reward calculation without precision multiplier (rounding errors) in 'setReward'
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:76:0
   â”œâ”€ Detector: defi-yield-farming-exploits
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add precision: Use 1e18 multiplier for reward calculations to minimize rounding errors

âš¡ MEDIUM: Function 'claimReward' is missing transaction deadline. Missing transaction deadline. Claim operation 'claimReward' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:14
   â”œâ”€ Detector: missing-transaction-deadline
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Add deadline to 'claimReward'. Implement: (1) Add 'deadline' parameter: function claimReward(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users

ğŸ”¥ CRITICAL: Vulnerable to transient storage reentrancy in 'claimReward' - transfer()/send() no longer safe with EIP-1153
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:0
   â”œâ”€ Detector: transient-storage-reentrancy
   â””â”€ Fix: EIP-1153 breaks transfer()/send() safety assumption:

CRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within
the 2300 gas stipend of transfer() and send().

Fix 1: Use checks-effects-interactions pattern
function withdraw() public {
uint256 amount = balances[msg.sender];
require(amount > 0);

// âœ… Update state BEFORE external call
balances[msg.sender] = 0;

payable(msg.sender).transfer(amount);
}

Fix 2: Use ReentrancyGuard
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

function withdraw() public nonReentrant {
uint256 amount = balances[msg.sender];
require(amount > 0);

balances[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

Reference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)

ğŸ”¥ CRITICAL: Function 'claimReward' can withdraw Ether but lacks access control. This allows anyone to call this function and potentially drain contract funds.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:14
   â”œâ”€ Detector: swc105-unprotected-ether-withdrawal
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add access control to 'claimReward'. Options:
1. Add an 'onlyOwner' modifier
2. Use OpenZeppelin's Ownable or AccessControl
3. Add require(msg.sender == owner) check
4. Implement a pull pattern where users withdraw their own funds

âš¡ MEDIUM: Function 'withdrawWithSend' in contract 'VulnerableIntegration' calls send() without checking the return value. send() returns false on failure instead of reverting. The transaction will continue even if the ETH transfer failed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:33:1
   â”œâ”€ Detector: unchecked-send-return
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check send() return value or use transfer()/call():

// Option 1: Check return value
bool success = payable(to).send(amount);
require(success, "Send failed");

// Option 2: Use transfer (reverts on failure)
payable(to).transfer(amount);

// Option 3: Use call (recommended)
(bool success, ) = payable(to).call{value: amount}("");
require(success, "Transfer failed");

ğŸ”¥ CRITICAL: Function 'withdrawUnchecked' in contract 'VulnerableIntegration' has sweeper-like naming and contains asset transfers. If used as an EIP-7702 delegation target, this could allow draining all assets from the delegating EOA.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: If this is a legitimate rescue function:

1. Add strict access control (onlyOwner, multi-sig)
2. Add timelock delays for large withdrawals
3. Emit events for all asset movements
4. Consider withdrawal limits
5. Document the function's intended use

NEVER use as EIP-7702 delegation target without safeguards.

ğŸ”¥ CRITICAL: Contract 'VulnerableIntegration' allows instant liquidity add/remove without time lock. Attackers can perform JIT liquidity attacks by adding liquidity just before large swaps and removing immediately after to capture fees.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:13:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add time lock for liquidity operations:

mapping(address => uint256) public depositTime;
uint256 public constant MIN_LOCK_TIME = 1 hours;

function addLiquidity(uint256 amount) external {
depositTime[msg.sender] = block.timestamp;
// ... add liquidity
}

function removeLiquidity(uint256 shares) external {
require(
block.timestamp >= depositTime[msg.sender] + MIN_LOCK_TIME,
"Liquidity locked"
);
// ... remove liquidity
}

ğŸ”¥ CRITICAL: Function 'withdrawUnchecked' in contract 'VulnerableIntegration' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

ğŸ”¥ CRITICAL: Function 'withdrawWithSend' in contract 'VulnerableIntegration' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

âš ï¸  HIGH: Function 'withdrawUnchecked' in contract 'VulnerableIntegration' has withdrawal race vulnerability. State changes during withdrawal period can be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: cross-l2-frontrunning
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add withdrawal protection:

1. Use pending/confirmed state pattern
2. Lock funds during withdrawal period
3. Add delay before withdrawal completion
4. Implement challenge mechanism

âš ï¸  HIGH: Function 'withdrawWithSend' in contract 'VulnerableIntegration' has withdrawal race vulnerability. State changes during withdrawal period can be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:1
   â”œâ”€ Detector: cross-l2-frontrunning
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add withdrawal protection:

1. Use pending/confirmed state pattern
2. Lock funds during withdrawal period
3. Add delay before withdrawal completion
4. Implement challenge mechanism

âš ï¸  HIGH: Function 'batchPayout' in contract 'VulnerableIntegration' performs batch operations that sequencers could exploit through partial execution ordering.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Improve batch operation safety:

1. Make batch operations atomic (all-or-nothing)
2. Add revert on partial failure
3. Implement batch ordering guarantees
4. Consider splitting into individual transactions

ğŸ”¥ CRITICAL: Function 'withdrawUnchecked' in contract 'VulnerableIntegration' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdrawUnchecked' in contract 'VulnerableIntegration' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdrawWithSend' in contract 'VulnerableIntegration' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdrawWithSend' in contract 'VulnerableIntegration' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimReward' in contract 'VulnerableIntegration' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimReward' in contract 'VulnerableIntegration' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

âš ï¸  HIGH: Function 'withdrawUnchecked' in contract 'VulnerableIntegration' may be vulnerable to cross-chain double-spend. Balances updated before cross-chain confirmation could be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: cross-rollup-state-mismatch
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Prevent double-spending:

1. Lock funds during cross-chain transfers
2. Use pending/confirmed state pattern
3. Implement nullifiers for withdrawal claims
4. Update balances only after confirmation

âš ï¸  HIGH: Function 'withdrawWithSend' in contract 'VulnerableIntegration' may be vulnerable to cross-chain double-spend. Balances updated before cross-chain confirmation could be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:1
   â”œâ”€ Detector: cross-rollup-state-mismatch
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Prevent double-spending:

1. Lock funds during cross-chain transfers
2. Use pending/confirmed state pattern
3. Implement nullifiers for withdrawal claims
4. Update balances only after confirmation

âš ï¸  HIGH: Function 'batchPayout' in contract 'VulnerableIntegration' performs gas-intensive operations in a loop. This can exceed block gas limit with large arrays.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:40:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Move gas-intensive operations outside loops:

1. Use pull pattern for transfers
2. Batch operations with limits
3. Use events for off-chain processing
4. Consider withdrawal patterns

âš ï¸  HIGH: Function 'batchPayout' in contract 'VulnerableIntegration' has DoS vulnerability: call() in loop. A single malicious or failing recipient can block the entire operation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:40:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use pull-over-push pattern:

// Instead of:
for (uint i = 0; i < recipients.length; i++) {
recipients[i].transfer(amounts[i]); // DoS risk
}

// Use:
mapping(address => uint256) pendingWithdrawals;

function withdraw() external {
uint256 amount = pendingWithdrawals[msg.sender];
pendingWithdrawals[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

âš ï¸  HIGH: Function 'batchPayout' in contract 'VulnerableIntegration' uses push payment pattern for distribution. Single failing recipient will revert entire distribution.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Convert to pull payment pattern:

1. Store amounts in mapping instead of sending
2. Let recipients claim their share
3. Or use try-catch with failure tracking:

try recipient.call{value: amount}("") {
// success
} catch {
failedPayments[recipient] = amount;
}

âš ï¸  HIGH: Function 'batchPayout' in contract 'VulnerableIntegration' makes batch external calls without error handling. Single failure will revert the entire batch.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Add error handling for batch operations:

for (uint i = 0; i < targets.length; i++) {
try IContract(targets[i]).method() {
// handle success
} catch {
// log failure, continue
emit BatchCallFailed(targets[i]);
}
}

âš ï¸  HIGH: Function 'batchPayout' in contract 'VulnerableIntegration' has gas limit risk: Unbounded loop with gas-intensive operations. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:40:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'withdrawWithSend' in contract 'VulnerableIntegration' has revert bomb risk: send() return value unchecked. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:33:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'claimReward' in contract 'VulnerableIntegration' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:73:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'withdrawUnchecked' in contract 'VulnerableIntegration' forwards unlimited gas to external call. Recipient can consume all gas causing out-of-gas revert.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:23:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit gas for external calls:

// Limit gas to prevent griefing
(bool success, ) = recipient.call{value: amount, gas: 10000}("");

// Or use transfer() which limits gas to 2300

âš ï¸  HIGH: Function 'batchPayout' in contract 'VulnerableIntegration' forwards unlimited gas to external call. Recipient can consume all gas causing out-of-gas revert.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:42:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit gas for external calls:

// Limit gas to prevent griefing
(bool success, ) = recipient.call{value: amount, gas: 10000}("");

// Or use transfer() which limits gas to 2300

âš¡ MEDIUM: Address parameter '_vulnerableContract' in function 'attack' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:94:29
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_vulnerableContract != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter '_vulnerableContract' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:94:29
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_vulnerableContract != address(0), "Invalid address");

ğŸ“ LOW: Parameter '_amount' of type 'uint' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:94:58
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_amount > 0, "Amount must be positive");

âš ï¸  HIGH: Function 'attack' relies on a single oracle source, creating centralization risk
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:94:14
   â”œâ”€ Detector: single-oracle-source
   â”œâ”€ CWE: CWE-693
   â””â”€ Fix: Use multiple oracle sources and implement price aggregation in function 'attack'

âš¡ MEDIUM: External call in function 'attack' does not check return value
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:94:14
   â”œâ”€ Detector: unchecked-external-call
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check the return value of external calls in function 'attack'

âš ï¸  HIGH: Function 'attack' has validator front-running vulnerability. Price-sensitive operations without fair sequencing, validators can reorder transactions for MEV extraction Validators can observe pending transactions and extract value by front-running users.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:94:14
   â”œâ”€ Detector: validator-front-running
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Mitigate validator front-running in 'attack'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.

âš¡ MEDIUM: Function 'attack' contains unchecked arithmetic operations. Unchecked subtraction detected. Subtraction can underflow without reversion Unchecked math can silently overflow/underflow leading to incorrect calculations and potential exploits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:94:14
   â”œâ”€ Detector: unchecked-math
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Remove unsafe unchecked blocks in 'attack'. Solidity 0.8+ has built-in overflow protection. Only use 'unchecked' for gas optimization when overflow is mathematically impossible. Add explicit validation or use OpenZeppelin SafeMath for Solidity <0.8.

âš¡ MEDIUM: Function 'withdrawWithSend' in contract 'MaliciousReceiver' calls send() without checking the return value. send() returns false on failure instead of reverting. The transaction will continue even if the ETH transfer failed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:33:1
   â”œâ”€ Detector: unchecked-send-return
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check send() return value or use transfer()/call():

// Option 1: Check return value
bool success = payable(to).send(amount);
require(success, "Send failed");

// Option 2: Use transfer (reverts on failure)
payable(to).transfer(amount);

// Option 3: Use call (recommended)
(bool success, ) = payable(to).call{value: amount}("");
require(success, "Transfer failed");

ğŸ”¥ CRITICAL: Function 'withdrawUnchecked' in contract 'MaliciousReceiver' has sweeper-like naming and contains asset transfers. If used as an EIP-7702 delegation target, this could allow draining all assets from the delegating EOA.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: eip7702-sweeper-attack
   â”œâ”€ CWE: CWE-306
   â””â”€ Fix: If this is a legitimate rescue function:

1. Add strict access control (onlyOwner, multi-sig)
2. Add timelock delays for large withdrawals
3. Emit events for all asset movements
4. Consider withdrawal limits
5. Document the function's intended use

NEVER use as EIP-7702 delegation target without safeguards.

ğŸ”¥ CRITICAL: Contract 'MaliciousReceiver' allows instant liquidity add/remove without time lock. Attackers can perform JIT liquidity attacks by adding liquidity just before large swaps and removing immediately after to capture fees.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:13:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add time lock for liquidity operations:

mapping(address => uint256) public depositTime;
uint256 public constant MIN_LOCK_TIME = 1 hours;

function addLiquidity(uint256 amount) external {
depositTime[msg.sender] = block.timestamp;
// ... add liquidity
}

function removeLiquidity(uint256 shares) external {
require(
block.timestamp >= depositTime[msg.sender] + MIN_LOCK_TIME,
"Liquidity locked"
);
// ... remove liquidity
}

ğŸ”¥ CRITICAL: Function 'withdrawUnchecked' in contract 'MaliciousReceiver' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

ğŸ”¥ CRITICAL: Function 'withdrawWithSend' in contract 'MaliciousReceiver' allows liquidity removal in the same block as deposit. This enables atomic JIT attacks within a single transaction.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:1
   â”œâ”€ Detector: jit-liquidity-extraction
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Block same-block liquidity removal:

mapping(address => uint256) public lastDepositBlock;

function deposit() external {
lastDepositBlock[msg.sender] = block.number;
// ...
}

function withdraw() external {
require(
block.number > lastDepositBlock[msg.sender],
"Cannot withdraw same block"
);
// ...
}

âš ï¸  HIGH: Function 'withdrawUnchecked' in contract 'MaliciousReceiver' has withdrawal race vulnerability. State changes during withdrawal period can be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: cross-l2-frontrunning
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add withdrawal protection:

1. Use pending/confirmed state pattern
2. Lock funds during withdrawal period
3. Add delay before withdrawal completion
4. Implement challenge mechanism

âš ï¸  HIGH: Function 'withdrawWithSend' in contract 'MaliciousReceiver' has withdrawal race vulnerability. State changes during withdrawal period can be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:1
   â”œâ”€ Detector: cross-l2-frontrunning
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Add withdrawal protection:

1. Use pending/confirmed state pattern
2. Lock funds during withdrawal period
3. Add delay before withdrawal completion
4. Implement challenge mechanism

âš ï¸  HIGH: Function 'batchPayout' in contract 'MaliciousReceiver' performs batch operations that sequencers could exploit through partial execution ordering.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:1
   â”œâ”€ Detector: l2-mev-sequencer-leak
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Improve batch operation safety:

1. Make batch operations atomic (all-or-nothing)
2. Add revert on partial failure
3. Implement batch ordering guarantees
4. Consider splitting into individual transactions

ğŸ”¥ CRITICAL: Function 'withdrawUnchecked' in contract 'MaliciousReceiver' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdrawUnchecked' in contract 'MaliciousReceiver' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdrawWithSend' in contract 'MaliciousReceiver' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'withdrawWithSend' in contract 'MaliciousReceiver' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimReward' in contract 'MaliciousReceiver' has merkle bypass vulnerability: Bridge function without merkle proof verification. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

ğŸ”¥ CRITICAL: Function 'claimReward' in contract 'MaliciousReceiver' has merkle bypass vulnerability: Bridge function without root validation. Attackers may be able to forge withdrawal proofs or relay unauthorized messages.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:64:1
   â”œâ”€ Detector: bridge-merkle-bypass
   â”œâ”€ CWE: CWE-345
   â””â”€ Fix: Add proper merkle proof validation:

1. Require merkle proof parameter for all withdrawals
2. Verify proof against confirmed state root
3. Use battle-tested merkle proof libraries
4. Validate leaf hash includes all message data
5. Check proof length matches tree depth

âš ï¸  HIGH: Function 'withdrawUnchecked' in contract 'MaliciousReceiver' may be vulnerable to cross-chain double-spend. Balances updated before cross-chain confirmation could be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:18:1
   â”œâ”€ Detector: cross-rollup-state-mismatch
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Prevent double-spending:

1. Lock funds during cross-chain transfers
2. Use pending/confirmed state pattern
3. Implement nullifiers for withdrawal claims
4. Update balances only after confirmation

âš ï¸  HIGH: Function 'withdrawWithSend' in contract 'MaliciousReceiver' may be vulnerable to cross-chain double-spend. Balances updated before cross-chain confirmation could be exploited.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:28:1
   â”œâ”€ Detector: cross-rollup-state-mismatch
   â”œâ”€ CWE: CWE-662
   â””â”€ Fix: Prevent double-spending:

1. Lock funds during cross-chain transfers
2. Use pending/confirmed state pattern
3. Implement nullifiers for withdrawal claims
4. Update balances only after confirmation

âš ï¸  HIGH: Function 'batchPayout' in contract 'MaliciousReceiver' performs gas-intensive operations in a loop. This can exceed block gas limit with large arrays.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:40:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Move gas-intensive operations outside loops:

1. Use pull pattern for transfers
2. Batch operations with limits
3. Use events for off-chain processing
4. Consider withdrawal patterns

âš ï¸  HIGH: Function 'batchPayout' in contract 'MaliciousReceiver' has DoS vulnerability: call() in loop. A single malicious or failing recipient can block the entire operation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:40:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use pull-over-push pattern:

// Instead of:
for (uint i = 0; i < recipients.length; i++) {
recipients[i].transfer(amounts[i]); // DoS risk
}

// Use:
mapping(address => uint256) pendingWithdrawals;

function withdraw() external {
uint256 amount = pendingWithdrawals[msg.sender];
pendingWithdrawals[msg.sender] = 0;
payable(msg.sender).transfer(amount);
}

âš ï¸  HIGH: Function 'batchPayout' in contract 'MaliciousReceiver' uses push payment pattern for distribution. Single failing recipient will revert entire distribution.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Convert to pull payment pattern:

1. Store amounts in mapping instead of sending
2. Let recipients claim their share
3. Or use try-catch with failure tracking:

try recipient.call{value: amount}("") {
// success
} catch {
failedPayments[recipient] = amount;
}

âš ï¸  HIGH: Function 'batchPayout' in contract 'MaliciousReceiver' makes batch external calls without error handling. Single failure will revert the entire batch.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:37:1
   â”œâ”€ Detector: dos-external-call-loop
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Add error handling for batch operations:

for (uint i = 0; i < targets.length; i++) {
try IContract(targets[i]).method() {
// handle success
} catch {
// log failure, continue
emit BatchCallFailed(targets[i]);
}
}

âš ï¸  HIGH: Function 'batchPayout' in contract 'MaliciousReceiver' has gas limit risk: Unbounded loop with gas-intensive operations. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:40:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

âš ï¸  HIGH: Function 'withdrawWithSend' in contract 'MaliciousReceiver' has revert bomb risk: send() return value unchecked. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:33:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'claimReward' in contract 'MaliciousReceiver' has revert bomb risk: transfer() will revert on failure. Malicious contracts can force reverts via receive/fallback.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:73:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Use call with return value check:

(bool success, ) = recipient.call{value: amount}("");
if (!success) {
// Handle failure - store for later claim
pendingWithdrawals[recipient] += amount;
}

âš ï¸  HIGH: Function 'withdrawUnchecked' in contract 'MaliciousReceiver' forwards unlimited gas to external call. Recipient can consume all gas causing out-of-gas revert.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:23:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit gas for external calls:

// Limit gas to prevent griefing
(bool success, ) = recipient.call{value: amount, gas: 10000}("");

// Or use transfer() which limits gas to 2300

âš ï¸  HIGH: Function 'batchPayout' in contract 'MaliciousReceiver' forwards unlimited gas to external call. Recipient can consume all gas causing out-of-gas revert.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UncheckedCall.sol:42:1
   â”œâ”€ Detector: dos-revert-bomb
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Limit gas for external calls:

// Limit gas to prevent griefing
(bool success, ) = recipient.call{value: amount, gas: 10000}("");

// Or use transfer() which limits gas to 2300

ğŸ”¥ CRITICAL: Function 'addUser' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:33:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'addUser'

ğŸ”¥ CRITICAL: Function 'updateUser' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:44:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'updateUser'

âš¡ MEDIUM: Address parameter '_addr' in function 'addUser' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:33:30
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_addr != address(0), "Zero address not allowed");

âš¡ MEDIUM: Address parameter '_addr' in function 'updateUser' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:44:49
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_addr != address(0), "Zero address not allowed");

âš ï¸  HIGH: Array access to 'users' may be out of bounds - index not validated
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:46:29
   â”œâ”€ Detector: array-bounds-check
   â”œâ”€ CWE: CWE-125
   â””â”€ Fix: Add bounds check: require(index < users.length, "Index out of bounds");

ğŸ“ LOW: Parameter '_addr' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:33:30
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_addr != address(0), "Invalid address");

ğŸ“ LOW: Parameter '_addr' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:44:49
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_addr != address(0), "Invalid address");

âš ï¸  HIGH: Function 'addUser' relies on a single oracle source, creating centralization risk
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:33:14
   â”œâ”€ Detector: single-oracle-source
   â”œâ”€ CWE: CWE-693
   â””â”€ Fix: Use multiple oracle sources and implement price aggregation in function 'addUser'

âš¡ MEDIUM: External call in function 'addUser' does not check return value
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:33:14
   â”œâ”€ Detector: unchecked-external-call
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check the return value of external calls in function 'addUser'

ğŸ”¥ CRITICAL: Function '' has token supply manipulation vulnerability. Function directly modifies totalSupply variable, bypasses mint/burn controls for supply manipulation Improper supply controls can lead to unlimited minting, hyperinflation, or complete token devaluation.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:27:5
   â”œâ”€ Detector: token-supply-manipulation
   â”œâ”€ CWE: CWE-682
   â””â”€ Fix: Fix token supply controls in ''. Implement maximum supply cap, add minting rate limits, require multi-signature for minting, add supply change events, validate burn amounts, and implement supply monitoring.

ğŸ“ LOW: Inefficient storage pattern detected. Struct contains mixed uint256 and smaller types. Pack smaller types together for gas savings Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:19:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

ğŸ“ LOW: Inefficient storage pattern detected. Function 'addUser' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:33:0
   â”œâ”€ Detector: inefficient-storage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.

âš ï¸  HIGH: Contract has centralization risk. Contract uses single owner without multi-signature protection. Single private key compromise leads to total contract control Single point of failure can lead to fund loss, governance attacks, or complete system compromise.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:1:0
   â”œâ”€ Detector: centralization-risk
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.

âš¡ MEDIUM: Function 'addUser' contains variable shadowing. Parameter 'owner' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:33:14
   â”œâ”€ Detector: shadowing-variables
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Rename shadowing variables in 'addUser'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.

ğŸ“ LOW: Floating pragma detected: pragma solidity ^0.7.6;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:2:0
   â”œâ”€ Detector: floating-pragma
   â”œâ”€ CWE: CWE-710
   â””â”€ Fix: Lock pragma to specific version: 'pragma solidity 0.7.6;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.

âš ï¸  HIGH: Sensitive data 'private' in 'private' variable - all blockchain storage is publicly readable
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:108:0
   â”œâ”€ Detector: private-variable-exposure
   â””â”€ Fix: CRITICAL: 'private' visibility does NOT encrypt data!

All blockchain storage is publicly readable via:
- eth_getStorageAt RPC call
- Block explorers
- Archive nodes

âŒ This is INSECURE:
string private password = "mysecret123";

âœ… Correct approaches:

1. NEVER store secrets on-chain
2. Store hashes instead:
bytes32 public passwordHash = keccak256("password");

3. Use commit-reveal for sensitive values:
bytes32 public commitment = keccak256(abi.encode(value, salt));

4. For truly private data, use off-chain storage or ZK proofs

âš ï¸  HIGH: Potential division before multiplication - causes precision loss (OWASP 2025)
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:1:0
   â”œâ”€ Detector: logic-error-patterns
   â””â”€ Fix: âŒ PRECISION LOSS ($63.8M in losses):
uint256 reward = (amount / totalSupply) * rewardRate;
// Result: 0 if amount < totalSupply!

âœ… CORRECT ORDER:
uint256 reward = (amount * rewardRate) / totalSupply;
// Maximizes precision, multiply before divide

âœ… BEST: Use fixed-point math:
uint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;

Real incidents:
- Cork Protocol: $11M (May 2025) - Division rounding
- SIR.trading: $355K (March 2025) - Reward calculation
- Multiple 2024 incidents: $63.8M total

âš¡ MEDIUM: Transfer function without zero-value check - validate non-zero amounts
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ MISSING ZERO-VALUE CHECK:
function transfer(address to, uint256 amount) external {
_transfer(msg.sender, to, amount);
// What if amount is 0? Wastes gas, may break accounting
}

âœ… VALIDATE NON-ZERO:
function transfer(address to, uint256 amount) external {
require(amount > 0, "Zero amount");
require(to != address(0), "Zero address");
_transfer(msg.sender, to, amount);
}

âœ… COMPLETE VALIDATION:
function deposit(uint256 amount) external payable {
// For ERC20 deposits
require(amount > 0, "Zero amount");
require(amount <= MAX_DEPOSIT, "Exceeds maximum");

// For native ETH deposits
if (msg.value > 0) {
require(msg.value == amount, "Value mismatch");
}

// Proceed with deposit
}

âš¡ MEDIUM: Address parameter without zero-address validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:1:0
   â”œâ”€ Detector: enhanced-input-validation
   â””â”€ Fix: âŒ MISSING ADDRESS VALIDATION:
function setOwner(address newOwner) external {
owner = newOwner;  // What if newOwner is address(0)?
}

âœ… VALIDATE ADDRESS:
function setOwner(address newOwner) external onlyOwner {
require(newOwner != address(0), "Zero address");
require(newOwner != owner, "Same address");
owner = newOwner;
}

âœ… VALIDATE MULTIPLE ADDRESSES:
function initialize(
address _token,
address _oracle,
address _treasury
) external {
require(_token != address(0), "Zero token");
require(_oracle != address(0), "Zero oracle");
require(_treasury != address(0), "Zero treasury");

// Check for duplicates if needed
require(_token != _oracle, "Token == oracle");
require(_token != _treasury, "Token == treasury");

token = _token;
oracle = _oracle;
treasury = _treasury;
}

âš ï¸  HIGH: Pool initialization lacks protection - first depositor can manipulate initial share price
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:1:1
   â”œâ”€ Detector: pool-donation-enhanced
   â””â”€ Fix: Require minimum initial deposit, mint dead shares on initialization, or use time-delayed activation

âš ï¸  HIGH: Constructor in contract 'VulnerableStorage' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:27:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableStorage' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:66:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableStorage' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:94:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableStorage' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:129:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableStorage' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:185:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableStorage' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:27:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableStorage' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:66:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableStorage' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:94:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableStorage' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:129:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableStorage' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:185:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

âš ï¸  HIGH: Function 'addUser' in contract 'VulnerableStorage' has DoS vulnerability: Unbounded push to array 'users'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:40:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'addItem' in contract 'VulnerableStorage' has DoS vulnerability: Unbounded push to array 'items'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:82:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'createTransaction' in contract 'VulnerableStorage' has DoS vulnerability: Unbounded push to array 'transactions'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:141:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'addValue' in contract 'VulnerableStorage' has DoS vulnerability: Unbounded push to array 'values'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:190:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'processItems' in contract 'VulnerableStorage' iterates over unbounded array: Iteration over unbounded array 'items'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:74:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'processItems' in contract 'VulnerableStorage' has gas limit risk: Unbounded loop with gas-intensive operations. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:74:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

ğŸ”¥ CRITICAL: Function 'addItem' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:81:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'addItem'

âš ï¸  HIGH: Address parameter '_owner' in function 'addItem' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:81:30
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_owner != address(0), "Zero address not allowed");

âš ï¸  HIGH: Array access to 'items' may be out of bounds - index not validated
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:75:33
   â”œâ”€ Detector: array-bounds-check
   â”œâ”€ CWE: CWE-125
   â””â”€ Fix: Add bounds check: require(index < items.length, "Index out of bounds");

âš ï¸  HIGH: Parameter '_owner' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:81:30
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_owner != address(0), "Invalid address");

ğŸ“ LOW: Parameter '_amount' of type 'uint' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:81:46
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_amount > 0, "Amount must be positive");

âš ï¸  HIGH: Function 'addItem' relies on a single oracle source, creating centralization risk
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:81:14
   â”œâ”€ Detector: single-oracle-source
   â”œâ”€ CWE: CWE-693
   â””â”€ Fix: Use multiple oracle sources and implement price aggregation in function 'addItem'

âš¡ MEDIUM: External call in function 'addItem' does not check return value
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:81:14
   â”œâ”€ Detector: unchecked-external-call
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check the return value of external calls in function 'addItem'

âš ï¸  HIGH: Function 'processItems' performs arithmetic operations in Solidity < 0.8.0 without SafeMath. Performs addition without SafeMath protection Integer overflow/underflow can occur, leading to incorrect calculations and potential exploits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:72:14
   â”œâ”€ Detector: integer-overflow
   â”œâ”€ CWE: CWE-190
   â””â”€ Fix: Use SafeMath library in 'processItems' for Solidity < 0.8.0. Example: `using SafeMath for uint256;` and use `.add()`, `.sub()`, `.mul()`, `.div()` methods. Or upgrade to Solidity >= 0.8.0 for automatic overflow checks.

âš ï¸  HIGH: Function 'processItems' has DOS vulnerability via unbounded operation. Loop over unbounded array without iteration limit, large arrays cause out-of-gas Can cause out-of-gas errors blocking contract functionality.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:72:14
   â”œâ”€ Detector: dos-unbounded-operation
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Fix unbounded operation in 'processItems'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.

ğŸ“ LOW: Function 'processItems' contains excessive gas usage pattern. Storage write operation inside loop. Consider using memory array Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:72:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'processItems'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

ğŸ“ LOW: Function 'processItems' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:72:14
   â”œâ”€ Detector: excessive-gas-usage
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Optimize gas usage in 'processItems'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.

âš ï¸  HIGH: Constructor in contract 'VulnerableArray' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:27:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableArray' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:66:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableArray' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:94:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableArray' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:129:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableArray' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:185:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableArray' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:27:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableArray' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:66:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableArray' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:94:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableArray' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:129:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableArray' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:185:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

âš ï¸  HIGH: Function 'addUser' in contract 'VulnerableArray' has DoS vulnerability: Unbounded push to array 'users'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:40:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'addItem' in contract 'VulnerableArray' has DoS vulnerability: Unbounded push to array 'items'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:82:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'createTransaction' in contract 'VulnerableArray' has DoS vulnerability: Unbounded push to array 'transactions'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:141:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'addValue' in contract 'VulnerableArray' has DoS vulnerability: Unbounded push to array 'values'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:190:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'processItems' in contract 'VulnerableArray' iterates over unbounded array: Iteration over unbounded array 'items'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:74:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'processItems' in contract 'VulnerableArray' has gas limit risk: Unbounded loop with gas-intensive operations. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:74:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

ğŸ”¥ CRITICAL: Function 'changeOwner' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:103:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'changeOwner'

ğŸ”¥ CRITICAL: Function 'resetSecret' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:109:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'resetSecret'

âš ï¸  HIGH: Address parameter '_newOwner' in function 'changeOwner' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:103:34
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_newOwner != address(0), "Zero address not allowed");

âš ï¸  HIGH: Parameter '_newOwner' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:103:34
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_newOwner != address(0), "Invalid address");

âš ï¸  HIGH: Constructor in contract 'VulnerableVisibility' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:27:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableVisibility' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:66:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableVisibility' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:94:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableVisibility' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:129:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableVisibility' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:185:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableVisibility' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:27:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableVisibility' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:66:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableVisibility' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:94:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableVisibility' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:129:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableVisibility' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:185:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

âš ï¸  HIGH: Function 'addUser' in contract 'VulnerableVisibility' has DoS vulnerability: Unbounded push to array 'users'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:40:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'addItem' in contract 'VulnerableVisibility' has DoS vulnerability: Unbounded push to array 'items'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:82:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'createTransaction' in contract 'VulnerableVisibility' has DoS vulnerability: Unbounded push to array 'transactions'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:141:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'addValue' in contract 'VulnerableVisibility' has DoS vulnerability: Unbounded push to array 'values'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:190:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'processItems' in contract 'VulnerableVisibility' iterates over unbounded array: Iteration over unbounded array 'items'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:74:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'processItems' in contract 'VulnerableVisibility' has gas limit risk: Unbounded loop with gas-intensive operations. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:74:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

ğŸ”¥ CRITICAL: Function 'createTransaction' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:136:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'createTransaction'

âš ï¸  HIGH: Address parameter '_recipient' in function 'createTransaction' is not checked for zero address
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:136:40
   â”œâ”€ Detector: missing-zero-address-check
   â”œâ”€ CWE: CWE-476
   â””â”€ Fix: Add require(_recipient != address(0), "Zero address not allowed");

ğŸ“ LOW: Parameter '_recipient' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:136:40
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_recipient != address(0), "Invalid address");

ğŸ“ LOW: Parameter '_amount' of type 'uint' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:136:60
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_amount > 0, "Amount must be positive");

âš ï¸  HIGH: Function 'createTransaction' relies on a single oracle source, creating centralization risk
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:136:14
   â”œâ”€ Detector: single-oracle-source
   â”œâ”€ CWE: CWE-693
   â””â”€ Fix: Use multiple oracle sources and implement price aggregation in function 'createTransaction'

âš¡ MEDIUM: External call in function 'createTransaction' does not check return value
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:136:14
   â”œâ”€ Detector: unchecked-external-call
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check the return value of external calls in function 'createTransaction'

âš ï¸  HIGH: Constructor in contract 'StorageCollision' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:27:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'StorageCollision' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:66:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'StorageCollision' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:94:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'StorageCollision' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:129:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'StorageCollision' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:185:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Constructor in contract 'StorageCollision' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:27:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'StorageCollision' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:66:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'StorageCollision' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:94:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'StorageCollision' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:129:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'StorageCollision' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:185:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

âš ï¸  HIGH: Function 'addUser' in contract 'StorageCollision' has DoS vulnerability: Unbounded push to array 'users'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:40:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'addItem' in contract 'StorageCollision' has DoS vulnerability: Unbounded push to array 'items'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:82:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'createTransaction' in contract 'StorageCollision' has DoS vulnerability: Unbounded push to array 'transactions'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:141:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'addValue' in contract 'StorageCollision' has DoS vulnerability: Unbounded push to array 'values'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:190:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'processItems' in contract 'StorageCollision' iterates over unbounded array: Iteration over unbounded array 'items'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:74:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'processItems' in contract 'StorageCollision' has gas limit risk: Unbounded loop with gas-intensive operations. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:74:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

ğŸ”¥ CRITICAL: Function 'createUser' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:157:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'createUser'

ğŸ”¥ CRITICAL: Function 'approve' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:161:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'approve'

ğŸ”¥ CRITICAL: Function 'deleteUser' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:166:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'deleteUser'

ğŸ“ LOW: Parameter '_spender' of type 'address' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:161:30
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_spender != address(0), "Invalid address");

ğŸ“ LOW: Parameter '_amount' of type 'uint' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:161:48
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: require(_amount > 0, "Amount must be positive");

âš ï¸  HIGH: Function 'createUser' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:157:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'createUser'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function 'approve' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:161:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'approve'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function 'deleteUser' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:166:14
   â”œâ”€ Detector: mev-extractable-value
   â”œâ”€ CWE: CWE-362
   â””â”€ Fix: Reduce MEV extractability in 'deleteUser'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.

âš ï¸  HIGH: Function 'deleteUser' has DOS vulnerability via unbounded operation. Deleting array or mapping without size limit, can exceed gas limit Can cause out-of-gas errors blocking contract functionality.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:166:14
   â”œâ”€ Detector: dos-unbounded-operation
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Fix unbounded operation in 'deleteUser'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.

âš ï¸  HIGH: Constructor in contract 'VulnerableMapping' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:27:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableMapping' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:66:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableMapping' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:94:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableMapping' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:129:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableMapping' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:185:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableMapping' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:27:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableMapping' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:66:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableMapping' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:94:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableMapping' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:129:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableMapping' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:185:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

âš ï¸  HIGH: Function 'addUser' in contract 'VulnerableMapping' has DoS vulnerability: Unbounded push to array 'users'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:40:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'addItem' in contract 'VulnerableMapping' has DoS vulnerability: Unbounded push to array 'items'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:82:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'createTransaction' in contract 'VulnerableMapping' has DoS vulnerability: Unbounded push to array 'transactions'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:141:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'addValue' in contract 'VulnerableMapping' has DoS vulnerability: Unbounded push to array 'values'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:190:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'processItems' in contract 'VulnerableMapping' iterates over unbounded array: Iteration over unbounded array 'items'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:74:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'processItems' in contract 'VulnerableMapping' has gas limit risk: Unbounded loop with gas-intensive operations. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:74:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}

ğŸ”¥ CRITICAL: Function 'addValue' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:189:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'addValue'

ğŸ”¥ CRITICAL: Function 'deleteValue' performs critical operations but lacks access control modifiers
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:194:14
   â”œâ”€ Detector: missing-access-modifiers
   â”œâ”€ CWE: CWE-284
   â””â”€ Fix: Add an access control modifier like 'onlyOwner' to function 'deleteValue'

ğŸ“ LOW: Parameter '_value' of type 'uint' may need validation
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:189:31
   â”œâ”€ Detector: parameter-consistency
   â”œâ”€ CWE: CWE-20
   â””â”€ Fix: Add appropriate range validation for _value

âš ï¸  HIGH: Function 'addValue' relies on a single oracle source, creating centralization risk
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:189:14
   â”œâ”€ Detector: single-oracle-source
   â”œâ”€ CWE: CWE-693
   â””â”€ Fix: Use multiple oracle sources and implement price aggregation in function 'addValue'

âš¡ MEDIUM: External call in function 'addValue' does not check return value
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:189:14
   â”œâ”€ Detector: unchecked-external-call
   â”œâ”€ CWE: CWE-252
   â””â”€ Fix: Check the return value of external calls in function 'addValue'

âš ï¸  HIGH: Function 'deleteValue' has DOS vulnerability via unbounded operation. Deleting array or mapping without size limit, can exceed gas limit Can cause out-of-gas errors blocking contract functionality.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:194:14
   â”œâ”€ Detector: dos-unbounded-operation
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Fix unbounded operation in 'deleteValue'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.

âš ï¸  HIGH: Function 'getValue' has DOS vulnerability via unbounded operation. Deleting array or mapping without size limit, can exceed gas limit Can cause out-of-gas errors blocking contract functionality.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:202:14
   â”œâ”€ Detector: dos-unbounded-operation
   â”œâ”€ CWE: CWE-834
   â””â”€ Fix: Fix unbounded operation in 'getValue'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.

âš ï¸  HIGH: Constructor in contract 'VulnerableArrayDeletion' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:27:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableArrayDeletion' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:66:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableArrayDeletion' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:94:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableArrayDeletion' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:129:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

âš ï¸  HIGH: Constructor in contract 'VulnerableArrayDeletion' makes external calls. Reentrancy can occur before security mechanisms are initialized.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:185:1
   â”œâ”€ Detector: constructor-reentrancy
   â”œâ”€ CWE: CWE-841
   â””â”€ Fix: Avoid external calls in constructor:

1. Move external calls to an initialize() function
2. Use two-step initialization pattern
3. Ensure all state is set before external calls
4. Use reentrancy guards even in constructor

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableArrayDeletion' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:27:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableArrayDeletion' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:66:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableArrayDeletion' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:94:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableArrayDeletion' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:129:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

ğŸ”¥ CRITICAL: Constructor in contract 'VulnerableArrayDeletion' grants privileges. Constructor grants roles in upgradeable contract. In upgradeable contracts, constructors run once per implementation, potentially granting unintended access.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:185:1
   â”œâ”€ Detector: role-escalation-upgrade
   â”œâ”€ CWE: CWE-269
   â””â”€ Fix: Move privilege grants to initializer:

1. Never grant roles in constructor for upgradeable contracts
2. Use initializer modifier with proper access control
3. Disable initializers in constructor: _disableInitializers()

Example:
constructor() {
_disableInitializers();
}

function initialize(address admin) initializer public {
__AccessControl_init();
_grantRole(DEFAULT_ADMIN_ROLE, admin);
}

âš ï¸  HIGH: Function 'addUser' in contract 'VulnerableArrayDeletion' has DoS vulnerability: Unbounded push to array 'users'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:40:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'addItem' in contract 'VulnerableArrayDeletion' has DoS vulnerability: Unbounded push to array 'items'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:82:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'createTransaction' in contract 'VulnerableArrayDeletion' has DoS vulnerability: Unbounded push to array 'transactions'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:141:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'addValue' in contract 'VulnerableArrayDeletion' has DoS vulnerability: Unbounded push to array 'values'. Users can grow array indefinitely, making iteration exceed gas limits.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:190:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Prevent unbounded array growth:

1. Add maximum length check:
require(array.length < MAX_SIZE, "Array full");

2. Use mapping instead of array for iteration
3. Implement pagination for large datasets
4. Use pull pattern instead of push

âš ï¸  HIGH: Function 'processItems' in contract 'VulnerableArrayDeletion' iterates over unbounded array: Iteration over unbounded array 'items'. Attackers can grow array to cause out-of-gas failures.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:74:1
   â”œâ”€ Detector: dos-push-pattern
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Avoid unbounded iteration:

1. Limit array size on push operations
2. Use pagination for processing:
function process(uint start, uint count) external {
for (uint i = start; i < start + count && i < arr.length; i++) {
// process arr[i]
}
}
3. Consider pull-over-push pattern

âš ï¸  HIGH: Function 'processItems' in contract 'VulnerableArrayDeletion' has gas limit risk: Unbounded loop with gas-intensive operations. As data grows, function may exceed block gas limit.
   â”œâ”€ Location: /Users/pwner/Git/vulnerable-smart-contract-examples/contracts/solidity/UninitializedStorage.sol:74:1
   â”œâ”€ Detector: dos-block-gas-limit
   â”œâ”€ CWE: CWE-400
   â””â”€ Fix: Implement pagination for large operations:

function processItems(uint256 start, uint256 count) external {
uint256 end = start + count;
if (end > items.length) end = items.length;

for (uint256 i = start; i < end; i++) {
// process items[i]
}
}


ğŸ“Š Analysis Summary
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Severity        â”‚ Count â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ”¥ Critical     â”‚  1240 â”‚
â”‚ âš ï¸  High        â”‚  2229 â”‚
â”‚ âš¡ Medium       â”‚   421 â”‚
â”‚ ğŸ“ Low          â”‚   147 â”‚
â”‚ â„¹ï¸  Info        â”‚     0 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Total Issues    â”‚  4037 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ”’ BlockSecOps.com - Enterprise-Grade DevSecOps Platform for Smart Contracts
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”