Loaded configuration from: .soliditydefend.yml
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘       ğŸ§™  SOLIDITY DEFEND ğŸ§™          â•‘
â•‘    Smart Contract Security Analyzer   â•‘
â•‘                v1.1.0                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Starting analysis...
Analyzing: tests/real-contracts/compound/cDAI.sol
  Found 369 issues
Found 117 issues in 1 file:
â— inefficient-storage Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations. 39:0

â— inefficient-storage Inefficient storage pattern detected. Small uint type as standalone storage variable. Use uint256 or pack with other variables Inefficient storage layout increases gas costs for all state-modifying operations. 42:0

â— inefficient-storage Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations. 68:0

â— inefficient-storage Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations. 133:0

â— inefficient-storage Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations. 164:0

â— aa-initialization-vulnerability EIP-7702 delegation initialized without safety checks. Delegation without validation of target contract Unsafe delegation initialization can brick the account if delegating to incompatible or malicious contract. 331:0

â— hardware-wallet-delegation Delegation contract missing recovery mechanism. No recovery mechanism found - users cannot undo delegation Without recovery, hardware wallet users lose access if delegation target is compromised or becomes incompatible. 1:0

â— hardware-wallet-delegation Delegation target not validated for interface compatibility. Missing interface validation can cause hardware wallet to delegate to incompatible code, bricking the account. 1:0

â— token-decimal-confusion Hardcoded decimal assumption (18) - incompatible with USDC (6), WBTC (8), etc. 1:1

â— token-decimal-confusion Token price/exchange calculation without decimal normalization - incorrect conversions 1:1

â— token-decimal-confusion Decimal-sensitive math operations without validation - verify decimal assumptions 1:1

â— mev-backrun-opportunities Liquidation without delay - MEV bots can frontrun health factor checks and backrun liquidations 1:1

â— mev-priority-gas-auction First-come-first-served mint - creates PGA where users bid up gas to mint first 1:1

â— floating-pragma Floating pragma detected: pragma solidity ^0.5.12;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes. 2:0

â— unused-state-variables State variable '_notEntered' is declared but never used. Unused state variables waste storage slots and increase deployment gas costs. Each unused storage slot costs gas during deployment. 39:0

â— unused-state-variables State variable 'initialExchangeRateMantissa' is declared but never used. Unused state variables waste storage slots and increase deployment gas costs. Each unused storage slot costs gas during deployment. 49:0

â— unused-state-variables State variable 'principal' is declared but never used. Unused state variables waste storage slots and increase deployment gas costs. Each unused storage slot costs gas during deployment. 60:0

â— multisig-bypass Missing nonce validation in signature verification (replay attack risk) 0:0

â— eip7702-storage-collision EIP-7702 delegate uses storage - verify no collision with EOA state 1:0

â— eip7702-sweeper-detection MALICIOUS SWEEPER DETECTED (score: 4/10) - Batch token operations, Approve + transferFrom pattern (token drainage) 1:0

â— logic-error-patterns Potential division before multiplication - causes precision loss (OWASP 2025) 1:0

â— enhanced-input-validation Array access without length validation - can cause out-of-bounds access 1:0

â— enhanced-input-validation Transfer function without zero-value check - validate non-zero amounts 1:0

â— enhanced-input-validation Address parameter without zero-address validation 1:0

â— post-080-overflow Assembly arithmetic detected - no overflow protection! ($223M Cetus DEX) 1:0

â— post-080-overflow Type casting to smaller uint - verify no overflow on downcast 1:0

â— pool-donation-enhanced No minimum deposit requirement - small deposits may round down to zero shares 1:1

â— pool-donation-enhanced Pool initialization lacks protection - first depositor can manipulate initial share price 1:1

â— parameter-consistency Parameter 'owner' in function 'allowance' may shadow a state variable 90:32

â— parameter-consistency Parameter 'owner' in function 'balanceOf' may shadow a state variable 91:32

â— parameter-consistency Parameter 'owner' in function 'balanceOfUnderlying' may shadow a state variable 92:42

â— missing-access-modifiers Function 'mint' performs critical operations but lacks access control modifiers 175:14

â— missing-access-modifiers Function 'exchangeRateCurrent' performs critical operations but lacks access control modifiers 270:14

â— missing-access-modifiers Function '_setPendingAdmin' performs critical operations but lacks access control modifiers 295:14

â— missing-access-modifiers Function '_setComptroller' performs critical operations but lacks access control modifiers 300:14

â— missing-access-modifiers Function '_setReserveFactor' performs critical operations but lacks access control modifiers 305:14

â— missing-access-modifiers Function '_acceptAdmin' performs critical operations but lacks access control modifiers 310:14

â— missing-access-modifiers Function '_addReserves' performs critical operations but lacks access control modifiers 315:14

â— missing-access-modifiers Function '_setInterestRateModel' performs critical operations but lacks access control modifiers 325:14

â— missing-zero-address-check Address parameter 'underlying_' in function '' is not checked for zero address 143:17

â— missing-zero-address-check Address parameter 'implementation_' in function '' is not checked for zero address 151:17

â— missing-zero-address-check Address parameter 'implementation_' in function '_setImplementation' is not checked for zero address 164:41

â— missing-zero-address-check Address parameter 'borrower' in function 'repayBorrowBehalf' is not checked for zero address 200:40

â— missing-zero-address-check Address parameter 'borrower' in function 'liquidateBorrow' is not checked for zero address 205:38

â— missing-zero-address-check Address parameter 'dst' in function 'transfer' is not checked for zero address 210:31

â— missing-zero-address-check Address parameter 'src' in function 'transferFrom' is not checked for zero address 215:35

â— missing-zero-address-check Address parameter 'dst' in function 'transferFrom' is not checked for zero address 215:48

â— missing-zero-address-check Address parameter 'spender' in function 'approve' is not checked for zero address 220:30

â— missing-zero-address-check Address parameter 'owner' in function 'balanceOfUnderlying' is not checked for zero address 235:42

â— missing-zero-address-check Address parameter 'account' in function 'borrowBalanceCurrent' is not checked for zero address 260:43

â— missing-zero-address-check Address parameter 'liquidator' in function 'seize' is not checked for zero address 290:28

â— missing-zero-address-check Address parameter 'borrower' in function 'seize' is not checked for zero address 290:48

â— missing-zero-address-check Address parameter 'callee' in function 'delegateTo' is not checked for zero address 330:33

â— parameter-consistency Parameter 'underlying_' of type 'address' may need validation 143:17

â— parameter-consistency Parameter 'initialExchangeRateMantissa_' of type 'uint' may need validation 146:14

â— parameter-consistency Parameter 'implementation_' of type 'address' may need validation 151:17

â— parameter-consistency Parameter 'implementation_' of type 'address' may need validation 164:41

â— parameter-consistency Parameter 'mintAmount' of type 'uint' may need validation 175:24

â— parameter-consistency Parameter 'redeemAmount' of type 'uint' may need validation 185:36

â— parameter-consistency Parameter 'borrowAmount' of type 'uint' may need validation 190:26

â— parameter-consistency Parameter 'repayAmount' of type 'uint' may need validation 195:31

â— parameter-consistency Parameter 'borrower' of type 'address' may need validation 200:40

â— parameter-consistency Parameter 'repayAmount' of type 'uint' may need validation 200:55

â— parameter-consistency Parameter 'borrower' of type 'address' may need validation 205:38

â— parameter-consistency Parameter 'repayAmount' of type 'uint' may need validation 205:53

â— parameter-consistency Parameter 'dst' of type 'address' may need validation 210:31

â— parameter-consistency Parameter 'amount' of type 'uint' may need validation 210:41

â— parameter-consistency Parameter 'src' of type 'address' may need validation 215:35

â— parameter-consistency Parameter 'dst' of type 'address' may need validation 215:48

â— parameter-consistency Parameter 'amount' of type 'uint' may need validation 215:61

â— parameter-consistency Parameter 'spender' of type 'address' may need validation 220:30

â— parameter-consistency Parameter 'amount' of type 'uint' may need validation 220:47

â— parameter-consistency Parameter 'owner' of type 'address' may need validation 225:32

â— parameter-consistency Parameter 'spender' of type 'address' may need validation 225:47

â— parameter-consistency Parameter 'owner' in function 'allowance' may shadow a state variable 225:32

â— parameter-consistency Parameter 'owner' of type 'address' may need validation 230:32

â— parameter-consistency Parameter 'owner' in function 'balanceOf' may shadow a state variable 230:32

â— parameter-consistency Parameter 'owner' of type 'address' may need validation 235:42

â— parameter-consistency Parameter 'owner' in function 'balanceOfUnderlying' may shadow a state variable 235:42

â— parameter-consistency Parameter 'account' of type 'address' may need validation 240:41

â— parameter-consistency Parameter 'account' of type 'address' may need validation 260:43

â— parameter-consistency Parameter 'account' of type 'address' may need validation 265:42

â— parameter-consistency Parameter 'liquidator' of type 'address' may need validation 290:28

â— parameter-consistency Parameter 'borrower' of type 'address' may need validation 290:48

â— parameter-consistency Parameter 'addAmount' of type 'uint' may need validation 315:32

â— parameter-consistency Parameter 'reduceAmount' of type 'uint' may need validation 320:35

â— parameter-consistency Parameter 'callee' of type 'address' may need validation 330:33

â— parameter-consistency Parameter 'data' is declared but never used 340:52

â— storage-collision Function '' uses delegatecall which can cause storage collision. Delegatecall to variable target without storage layout verification Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state. 354:5

â— dangerous-delegatecall Function 'delegateTo' contains dangerous delegatecall pattern. Delegatecall target is controlled by function parameters or user input, allowing arbitrary code execution Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds. 330:14

â— dangerous-delegatecall Function '' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds. 354:5

â— amm-liquidity-manipulation Function 'mint' is vulnerable to AMM liquidity manipulation. Liquidity operations lack minimum liquidity lock or time-based restrictions, enabling flash loan pool manipulation Liquidity manipulation can drain pools, enable sandwich attacks, or allow attackers to profit from price manipulation. 175:14

â— lending-liquidation-abuse Function 'liquidateBorrow' has liquidation abuse vulnerability. No liquidation cooldown period, allowing instant repeated liquidations and front-running of user's repayment transactions Unfair liquidation mechanics can be exploited to profit from borrowers or manipulated to prevent legitimate liquidations. 205:14

â— lending-liquidation-abuse Function 'seize' has liquidation abuse vulnerability. No liquidation cooldown period, allowing instant repeated liquidations and front-running of user's repayment transactions Unfair liquidation mechanics can be exploited to profit from borrowers or manipulated to prevent legitimate liquidations. 290:14

â— price-impact-manipulation Function 'exchangeRateCurrent' vulnerable to price impact manipulation. No maximum trade size limit enforced, allowing trades of any size that can cause extreme price impact and drain pool liquidity Large trades without size limits or impact checks can drain liquidity, manipulate prices, and cause excessive slippage for other users. 270:14

â— price-impact-manipulation Function 'exchangeRateStored' vulnerable to price impact manipulation. No maximum trade size limit enforced, allowing trades of any size that can cause extreme price impact and drain pool liquidity Large trades without size limits or impact checks can drain liquidity, manipulate prices, and cause excessive slippage for other users. 275:14

â— sandwich-resistant-swap Function 'exchangeRateCurrent' lacks sandwich attack protection. No minimum output amount (amountOutMin) parameter for slippage protection, leaving swap vulnerable to sandwich attacks MEV bots can front-run user swaps, manipulate price, then back-run to profit from the price difference at user's expense. 270:14

â— sandwich-resistant-swap Function 'exchangeRateStored' lacks sandwich attack protection. No minimum output amount (amountOutMin) parameter for slippage protection, leaving swap vulnerable to sandwich attacks MEV bots can front-run user swaps, manipulate price, then back-run to profit from the price difference at user's expense. 275:14

â— mev-extractable-value Function '' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running. 142:5

â— mev-extractable-value Function '_setImplementation' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running. 164:14

â— mev-extractable-value Function 'transfer' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running. 210:14

â— mev-extractable-value Function 'transferFrom' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running. 215:14

â— mev-extractable-value Function '' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running. 354:5

â— upgradeable-proxy-issues Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover. 142:5

â— upgradeable-proxy-issues Function '_setImplementation' has upgradeable proxy vulnerability. Upgrade executes immediately without timelock delay, no time for users to exit before malicious upgrade Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover. 164:14

â— upgradeable-proxy-issues Function 'delegateTo' has upgradeable proxy vulnerability. Delegatecall without validating implementation address, can delegate to non-contract or malicious code Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover. 330:14

â— upgradeable-proxy-issues Function 'delegateToImplementation' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover. 340:14

â— upgradeable-proxy-issues Function '' has upgradeable proxy vulnerability. Upgrade function lacks proper access control, anyone can upgrade contract to malicious implementation Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover. 354:5

â— token-supply-manipulation Function 'mint' has token supply manipulation vulnerability. Mint function lacks maximum supply cap, enables unlimited token minting and hyperinflation Improper supply controls can lead to unlimited minting, hyperinflation, or complete token devaluation. 175:14

â— circular-dependency Function 'delegateTo' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable. 330:14

â— circular-dependency Function '' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable. 354:5

â— shadowing-variables Function '' contains variable shadowing. Local variable 'payable' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed. 142:5

â— shadowing-variables Function '_setImplementation' contains variable shadowing. Local variable 'oldImplementation' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed. 164:14

â— missing-input-validation Function 'transfer' missing input validation. Transfer/withdraw function lacks amount validation Missing validation can lead to unexpected behavior, zero address transfers, or invalid state. 210:14

â— missing-input-validation Function 'transferFrom' missing input validation. Transfer/withdraw function lacks amount validation Missing validation can lead to unexpected behavior, zero address transfers, or invalid state. 215:14

â— unsafe-type-casting Function 'mint' contains unsafe type casting. uint to int conversion without overflow check. Large values may become negative Unsafe type conversions can lead to data loss, value truncation, or unexpected behavior. 175:0

â— erc20-approve-race Function 'approve' has approve race condition vulnerability. Standard ERC-20 approve without race condition protection Vulnerable to front-running attack (SWC-114). 220:14


Summary: 22 critical, 33 high, 27 medium, 35 low

Analysis complete:
  Files analyzed: 1
  Successful: 1
  Issues found: 117
  Duplicates removed: 252
  Time taken: 0.24s

Exiting with code 1 due to:
  - Found high or critical severity issues
