// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title Parity Multisig Wallet Library (Nov 2017 - $150M frozen)
 * @notice Simplified version of the Parity multisig library that was killed.
 *
 * VULNERABILITY: The WalletLibrary was deployed as a standalone contract
 * with an unprotected initWallet() function. An attacker called initWallet()
 * to become the owner, then called kill() to selfdestruct the library,
 * freezing ~$150M in all dependent wallets.
 *
 * Real contract: 0x863DF6BFa4469f3ead0bE8f9F2AAE51c91A907b4
 * Attacker tx: 0x05f71e1b2cb4f03e547739db15d080fd30c989eda04b37d
 */

// The vulnerable library contract
contract WalletLibrary {
    address public owner;
    mapping(address => bool) public isOwner;
    uint public required;
    uint public numOwners;

    // VULNERABILITY: initWallet is public and has no protection against re-initialization
    // Anyone can call this and become the owner
    function initWallet(address[] calldata _owners, uint _required) public {
        // No check if already initialized!
        numOwners = _owners.length;
        for (uint i = 0; i < _owners.length; i++) {
            isOwner[_owners[i]] = true;
        }
        owner = _owners[0];
        required = _required;
    }

    // VULNERABILITY: selfdestruct accessible to whoever calls initWallet first
    function kill(address payable _to) public {
        require(msg.sender == owner, "Not owner");
        selfdestruct(_to);
    }

    function execute(address _to, uint _value, bytes calldata _data) public {
        require(isOwner[msg.sender], "Not owner");
        (bool success,) = _to.call{value: _value}(_data);
        require(success, "Call failed");
    }

    receive() external payable {}
}

// The wallet proxy that delegates to the library
contract ParityMultisigWallet {
    address public walletLibrary;

    constructor(address _library, address[] memory _owners, uint _required) {
        walletLibrary = _library;
        // Delegate initialization to library
        (bool success,) = _library.delegatecall(
            abi.encodeWithSignature("initWallet(address[],uint256)", _owners, _required)
        );
        require(success, "Init failed");
    }

    // All calls delegated to library - if library is killed, wallet is bricked
    fallback() external payable {
        address lib = walletLibrary;
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), lib, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }

    receive() external payable {}
}
