// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title Ronin Bridge (Mar 2022 - $625M stolen)
 * @notice Simplified version of the Ronin Network bridge exploit.
 *
 * VULNERABILITY: The Ronin bridge used a multi-sig validator scheme requiring
 * only 5 of 9 validators to approve cross-chain withdrawals. The attacker
 * (Lazarus Group) compromised 5 validator private keys:
 *   - 4 keys belonged to Sky Mavis (the Ronin operator)
 *   - 1 key belonged to Axie DAO (granted via an old gas-free RPC allowlist)
 *
 * With 5 compromised keys the attacker forged withdrawal approvals and drained
 * 173,600 ETH (~$600M) and 25.5M USDC from the bridge. The exploit went
 * undetected for 6 days because there was no monitoring, no withdrawal limits,
 * and no time-delay on large transfers.
 *
 * Key design flaws modeled here:
 *   1. Low quorum (5/9) with too many keys under one entity
 *   2. No withdrawal rate limits or per-tx caps
 *   3. No time-lock / delay for large withdrawals
 *   4. No on-chain monitoring or alerting mechanism
 */

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract RoninBridge {
    address public owner;

    // Validator set -- only 9 validators, 5 needed to approve
    address[9] public validators;
    uint256 public constant TOTAL_VALIDATORS = 9;
    uint256 public constant QUORUM = 5; // VULNERABILITY: low quorum, easy to reach

    // Tracks approvals per withdrawal request
    struct WithdrawalRequest {
        address token;      // address(0) for ETH
        address recipient;
        uint256 amount;
        uint256 approvals;
        bool executed;
        mapping(address => bool) hasApproved;
    }

    uint256 public withdrawalCount;
    mapping(uint256 => WithdrawalRequest) public withdrawals;
    mapping(address => bool) public isValidator;

    event WithdrawalRequested(uint256 indexed id, address token, address recipient, uint256 amount);
    event WithdrawalApproved(uint256 indexed id, address indexed validator);
    event WithdrawalExecuted(uint256 indexed id, address recipient, uint256 amount);

    constructor(address[9] memory _validators) {
        owner = msg.sender;
        for (uint256 i = 0; i < TOTAL_VALIDATORS; i++) {
            validators[i] = _validators[i];
            isValidator[_validators[i]] = true;
        }
    }

    receive() external payable {}

    /// @notice Any validator can create a withdrawal request (simulates cross-chain relay)
    function requestWithdrawal(address token, address recipient, uint256 amount) external returns (uint256) {
        require(isValidator[msg.sender], "Not a validator");

        uint256 id = withdrawalCount++;
        WithdrawalRequest storage req = withdrawals[id];
        req.token = token;
        req.recipient = recipient;
        req.amount = amount;

        // VULNERABILITY: No cap on withdrawal amount -- attacker drained entire balance
        // VULNERABILITY: No time-lock or delay period before execution

        emit WithdrawalRequested(id, token, recipient, amount);
        return id;
    }

    /// @notice Validators approve a pending withdrawal; executes automatically at quorum
    function approveWithdrawal(uint256 id) external {
        require(isValidator[msg.sender], "Not a validator");
        WithdrawalRequest storage req = withdrawals[id];
        require(!req.executed, "Already executed");
        require(req.amount > 0, "Invalid withdrawal");
        require(!req.hasApproved[msg.sender], "Already approved");

        req.hasApproved[msg.sender] = true;
        req.approvals++;

        emit WithdrawalApproved(id, msg.sender);

        // VULNERABILITY: Executes immediately once quorum is met -- no delay, no review
        // With 5 compromised keys, attacker reaches quorum instantly
        if (req.approvals >= QUORUM) {
            _executeWithdrawal(id);
        }
    }

    function _executeWithdrawal(uint256 id) internal {
        WithdrawalRequest storage req = withdrawals[id];
        req.executed = true;

        // VULNERABILITY: No monitoring or alerting for large withdrawals
        // The real exploit went undetected for 6 days

        if (req.token == address(0)) {
            // ETH withdrawal
            (bool success, ) = req.recipient.call{value: req.amount}("");
            require(success, "ETH transfer failed");
        } else {
            // ERC-20 withdrawal (e.g. USDC)
            require(IERC20(req.token).transfer(req.recipient, req.amount), "Token transfer failed");
        }

        emit WithdrawalExecuted(id, req.recipient, req.amount);
    }

    /// @notice Deposit ETH into the bridge (users lock funds for cross-chain transfer)
    function deposit() external payable {
        require(msg.value > 0, "Zero deposit");
    }
}
