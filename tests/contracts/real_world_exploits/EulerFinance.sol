// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title Euler Finance (Mar 2023 - $197M stolen)
 * @notice Simplified version of the Euler Finance flash loan exploit.
 *
 * VULNERABILITY: The donateToReserves() function allowed a borrower to
 * donate their debt tokens to the reserve, inflating their collateral
 * ratio. Combined with a flash loan, this allowed draining the protocol.
 *
 * Attack flow:
 * 1. Flash loan large amount of DAI
 * 2. Deposit DAI as collateral, mint eDAI
 * 3. Borrow 10x leveraged position
 * 4. Use donateToReserves() to inflate eDAI value
 * 5. Liquidate self at inflated value
 * 6. Profit exceeds flash loan repayment
 */

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract EulerLendingPool {
    IERC20 public underlying;

    // User deposits and borrows
    mapping(address => uint256) public deposits;
    mapping(address => uint256) public borrows;

    // Pool state
    uint256 public totalDeposits;
    uint256 public totalBorrows;
    uint256 public reserves;

    // eToken (deposit receipt) tracking
    mapping(address => uint256) public eTokenBalance;
    uint256 public totalETokens;

    uint256 public constant COLLATERAL_FACTOR = 90; // 90%
    uint256 public constant LIQUIDATION_BONUS = 110; // 10% bonus

    event Deposit(address indexed user, uint256 amount);
    event Borrow(address indexed user, uint256 amount);
    event Liquidation(address indexed liquidator, address indexed borrower, uint256 amount);

    constructor(address _underlying) {
        underlying = IERC20(_underlying);
    }

    function deposit(uint256 amount) external {
        underlying.transferFrom(msg.sender, address(this), amount);

        uint256 eTokens;
        if (totalETokens == 0) {
            eTokens = amount;
        } else {
            // VULNERABILITY: eToken exchange rate can be manipulated
            eTokens = (amount * totalETokens) / totalDeposits;
        }

        eTokenBalance[msg.sender] += eTokens;
        totalETokens += eTokens;
        deposits[msg.sender] += amount;
        totalDeposits += amount;

        emit Deposit(msg.sender, amount);
    }

    function borrow(uint256 amount) external {
        uint256 collateralValue = getCollateralValue(msg.sender);
        uint256 maxBorrow = (collateralValue * COLLATERAL_FACTOR) / 100;
        require(borrows[msg.sender] + amount <= maxBorrow, "Insufficient collateral");

        borrows[msg.sender] += amount;
        totalBorrows += amount;
        underlying.transfer(msg.sender, amount);

        emit Borrow(msg.sender, amount);
    }

    // VULNERABILITY: donateToReserves inflates the eToken exchange rate
    // by reducing totalDeposits while keeping totalETokens the same,
    // making remaining eTokens worth more
    function donateToReserves(uint256 amount) external {
        require(borrows[msg.sender] >= amount, "Nothing to donate");

        borrows[msg.sender] -= amount;
        totalBorrows -= amount;
        reserves += amount;

        // BUG: This reduces debt but doesn't reduce eToken supply
        // Effect: remaining eTokens become more valuable
        // The attacker's collateral value increases without adding real value
    }

    function getCollateralValue(address user) public view returns (uint256) {
        if (totalETokens == 0) return 0;
        // eToken value = (deposits in pool) / (total eTokens) * user's eTokens
        return (totalDeposits * eTokenBalance[user]) / totalETokens;
    }

    // Liquidation at inflated collateral value
    function liquidate(address borrower, uint256 repayAmount) external {
        uint256 collateralValue = getCollateralValue(borrower);
        uint256 maxBorrow = (collateralValue * COLLATERAL_FACTOR) / 100;

        // Check if undercollateralized
        require(borrows[borrower] > maxBorrow, "Not liquidatable");

        underlying.transferFrom(msg.sender, address(this), repayAmount);
        borrows[borrower] -= repayAmount;
        totalBorrows -= repayAmount;

        // VULNERABILITY: Liquidation bonus calculated on inflated collateral
        uint256 seizeAmount = (repayAmount * LIQUIDATION_BONUS) / 100;
        uint256 seizeETokens = (seizeAmount * totalETokens) / totalDeposits;

        eTokenBalance[borrower] -= seizeETokens;
        eTokenBalance[msg.sender] += seizeETokens;

        emit Liquidation(msg.sender, borrower, repayAmount);
    }
}
