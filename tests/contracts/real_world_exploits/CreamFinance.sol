// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title Cream Finance V2 (Oct 2021 - $130M stolen)
 * @notice Simplified version of the Cream Finance flash loan price oracle
 *         manipulation exploit.
 *
 * VULNERABILITY: The price oracle relied on spot DEX reserves (Uniswap-style
 * x*y=k pool balances) to determine token prices. An attacker could use a
 * flash loan to temporarily skew pool reserves, inflating the perceived value
 * of their collateral, then borrow far more than legitimately allowed.
 *
 * Attack flow:
 * 1. Flash loan a large amount of ETH
 * 2. Swap into the DEX pool to skew reserves (inflate token price)
 * 3. Deposit a small amount of the inflated token as collateral
 * 4. Borrow maximum against the artificially high collateral value
 * 5. Restore the DEX pool, repay the flash loan, keep the profit
 */

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

/**
 * @dev Simplified Uniswap-style AMM pool used as a price source.
 *      The oracle reads spot reserves directly, which is trivially
 *      manipulable within a single transaction via flash loans.
 */
contract VulnerableDEXPool {
    IERC20 public tokenA;
    IERC20 public tokenB;

    uint256 public reserveA;
    uint256 public reserveB;

    constructor(address _tokenA, address _tokenB) {
        tokenA = IERC20(_tokenA);
        tokenB = IERC20(_tokenB);
    }

    function addLiquidity(uint256 amountA, uint256 amountB) external {
        tokenA.transferFrom(msg.sender, address(this), amountA);
        tokenB.transferFrom(msg.sender, address(this), amountB);
        reserveA += amountA;
        reserveB += amountB;
    }

    // Constant-product swap: x * y = k
    function swap(address tokenIn, uint256 amountIn) external returns (uint256 amountOut) {
        bool isA = (tokenIn == address(tokenA));
        require(isA || tokenIn == address(tokenB), "Invalid token");

        IERC20 inToken  = isA ? tokenA : tokenB;
        IERC20 outToken = isA ? tokenB : tokenA;

        uint256 resIn  = isA ? reserveA : reserveB;
        uint256 resOut = isA ? reserveB : reserveA;

        inToken.transferFrom(msg.sender, address(this), amountIn);

        // x * y = k  =>  amountOut = resOut - k / (resIn + amountIn)
        amountOut = (resOut * amountIn) / (resIn + amountIn);
        outToken.transfer(msg.sender, amountOut);

        // Update reserves after swap -- these are what the oracle reads
        if (isA) {
            reserveA += amountIn;
            reserveB -= amountOut;
        } else {
            reserveB += amountIn;
            reserveA -= amountOut;
        }
    }
}

/**
 * @dev Price oracle that reads spot reserves from the DEX pool.
 *      VULNERABILITY: Spot prices from AMM reserves can be manipulated
 *      within a single transaction. A TWAP oracle would mitigate this.
 */
contract VulnerableSpotPriceOracle {
    VulnerableDEXPool public pool;

    constructor(address _pool) {
        pool = VulnerableDEXPool(_pool);
    }

    // VULNERABILITY: Price derived from current reserves, not a time-weighted
    // average. A large swap in the same tx will skew this value dramatically.
    function getPrice() external view returns (uint256) {
        uint256 resA = pool.reserveA();
        uint256 resB = pool.reserveB();
        require(resA > 0, "No liquidity");
        // Price of tokenA in terms of tokenB (scaled by 1e18)
        return (resB * 1e18) / resA;
    }
}

/**
 * @dev Simplified Cream-style lending pool.
 *      Collateral is valued using the manipulable spot oracle, so a flash
 *      loan can inflate collateral value and drain the pool.
 */
contract CreamLendingPool {
    IERC20 public collateralToken; // tokenA used as collateral
    IERC20 public borrowToken;     // tokenB available to borrow

    VulnerableSpotPriceOracle public oracle;

    mapping(address => uint256) public collateralDeposits;
    mapping(address => uint256) public borrows;

    uint256 public constant COLLATERAL_FACTOR = 80; // 80%

    event Deposit(address indexed user, uint256 amount);
    event Borrow(address indexed user, uint256 amount);
    event Repay(address indexed user, uint256 amount);

    constructor(address _collateral, address _borrow, address _oracle) {
        collateralToken = IERC20(_collateral);
        borrowToken = IERC20(_borrow);
        oracle = VulnerableSpotPriceOracle(_oracle);
    }

    function deposit(uint256 amount) external {
        collateralToken.transferFrom(msg.sender, address(this), amount);
        collateralDeposits[msg.sender] += amount;
        emit Deposit(msg.sender, amount);
    }

    // VULNERABILITY: Borrow limit is based on the spot oracle price, which
    // the attacker inflates moments before calling this function.
    function borrow(uint256 amount) external {
        uint256 collateralValue = getCollateralValue(msg.sender);
        uint256 maxBorrow = (collateralValue * COLLATERAL_FACTOR) / 100;

        require(
            borrows[msg.sender] + amount <= maxBorrow,
            "Insufficient collateral"
        );

        borrows[msg.sender] += amount;
        borrowToken.transfer(msg.sender, amount);

        emit Borrow(msg.sender, amount);
    }

    function repay(uint256 amount) external {
        borrowToken.transferFrom(msg.sender, address(this), amount);
        borrows[msg.sender] -= amount;
        emit Repay(msg.sender, amount);
    }

    // Collateral value = deposits * oracle price (which is manipulable)
    function getCollateralValue(address user) public view returns (uint256) {
        uint256 price = oracle.getPrice(); // <-- reads manipulated spot price
        return (collateralDeposits[user] * price) / 1e18;
    }
}
