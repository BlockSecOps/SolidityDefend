// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title Wormhole Bridge (Feb 2022 - $326M stolen)
 * @notice Simplified version of the Wormhole bridge vulnerability.
 *
 * VULNERABILITY: The bridge's signature verification used a deprecated
 * Solana instruction (verify_signatures) that could be spoofed.
 * In this Solidity simplification, the vulnerability is in accepting
 * guardian signatures without proper validation of the guardian set.
 *
 * Real contract: Solana-side, but this captures the EVM verification pattern
 */

interface IERC20 {
    function mint(address to, uint256 amount) external;
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}

contract WormholeBridge {
    address public owner;
    IERC20 public wrappedToken;

    // Guardian set for cross-chain message verification
    mapping(address => bool) public guardians;
    uint256 public guardianSetIndex;
    uint256 public numGuardians;
    uint256 public quorum;

    // Processed VAAs (Verified Action Approvals)
    mapping(bytes32 => bool) public processedVAAs;

    struct VAA {
        uint8 version;
        uint32 guardianSetIndex;
        bytes32 hash;
        address[] signers;
        bytes[] signatures;
        uint256 amount;
        address recipient;
        uint16 sourceChain;
    }

    event TokensMinted(address indexed recipient, uint256 amount, uint16 sourceChain);

    constructor(address _token, address[] memory _guardians, uint256 _quorum) {
        owner = msg.sender;
        wrappedToken = IERC20(_token);
        quorum = _quorum;
        numGuardians = _guardians.length;
        for (uint i = 0; i < _guardians.length; i++) {
            guardians[_guardians[i]] = true;
        }
    }

    // VULNERABILITY: Signature verification is insufficient
    // The real Wormhole bug was that the "verify_signatures" instruction
    // could be spoofed. Here we simulate incomplete guardian validation.
    function completeTransfer(VAA calldata vaa) external {
        require(!processedVAAs[vaa.hash], "Already processed");

        // VULNERABILITY: Only checks that signers are in guardian set,
        // but doesn't verify the signatures themselves are valid for the hash
        uint256 validSigners = 0;
        for (uint i = 0; i < vaa.signers.length; i++) {
            if (guardians[vaa.signers[i]]) {
                validSigners++;
            }
            // MISSING: actual ecrecover verification that signer signed the hash
        }

        // VULNERABILITY: Quorum check passes even with fake signatures
        require(validSigners >= quorum, "No quorum");

        processedVAAs[vaa.hash] = true;

        // Mint tokens - attacker can mint unlimited tokens with fake signatures
        wrappedToken.mint(vaa.recipient, vaa.amount);
        emit TokensMinted(vaa.recipient, vaa.amount, vaa.sourceChain);
    }

    function updateGuardianSet(address[] calldata newGuardians, uint256 newQuorum) external {
        require(msg.sender == owner, "Not owner");
        for (uint i = 0; i < newGuardians.length; i++) {
            guardians[newGuardians[i]] = true;
        }
        numGuardians = newGuardians.length;
        quorum = newQuorum;
        guardianSetIndex++;
    }
}
