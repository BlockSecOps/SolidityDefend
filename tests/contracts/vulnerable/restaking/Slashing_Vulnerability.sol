// SPDX-License-Identifier: MIT
// Based on: EigenLayer theoretical vulnerabilities - Cascading slashing risk
// Reference: EigenLayer security research 2024-2025
pragma solidity ^0.8.20;

/**
 * @title Restaking Slashing Vulnerability
 * @notice Demonstrates theoretical cascading slashing vulnerability
 * @dev This contract is VULNERABLE - demonstrates security risks
 *
 * Vulnerability: Multiple AVSs can slash same stake >100%
 * Should trigger: restaking-slashing-conditions detector
 *
 * Risk Scenario:
 * 1. Operator restakes 32 ETH across 5 AVSs
 * 2. Each AVS can slash up to 100% for violations
 * 3. Operator violates rules in 3 AVSs simultaneously
 * 4. Total slashing: 3 Ã— 32 ETH = 96 ETH (but only has 32 ETH)
 * 5. Cascading failure: first AVS gets full 32 ETH, others get 0
 * 6. System becomes insolvent
 */
contract Vulnerable_Restaking_Slasher {
    struct Stake {
        uint256 amount;
        uint256 slashedAmount;
        bool isActive;
    }

    struct AVS {
        address avsContract;
        uint256 slashingPercentage; // Can be up to 100%
        bool isRegistered;
    }

    mapping(address => Stake) public stakes;
    mapping(address => mapping(address => AVS)) public operatorAVSs; // operator => avsAddress => AVS
    mapping(address => uint256) public avsCount;

    // VULNERABILITY: No maximum slashing cap
    // VULNERABILITY: No coordination between AVSs
    // VULNERABILITY: First-come-first-served slashing (no prioritization)

    function registerOperatorToAVS(
        address operator,
        address avsContract,
        uint256 slashingPercentage
    ) external {
        // VULNERABLE: No limit on number of AVSs
        // VULNERABLE: Each AVS can set slashing up to 100%

        require(slashingPercentage <= 100, "Max 100%");

        operatorAVSs[operator][avsContract] = AVS({
            avsContract: avsContract,
            slashingPercentage: slashingPercentage,
            isRegistered: true
        });

        avsCount[operator]++;

        // VULNERABLE: No check for total exposure
        // If operator has 5 AVSs each with 100% slashing, exposure is 500%!
    }

    /**
     * @notice Slash operator for misbehavior
     * @dev VULNERABLE: No evidence requirement, no appeal period, no coordination
     */
    function slashOperator(
        address operator,
        address avsContract,
        uint256 percentage  // VULNERABLE: Can slash without evidence
    ) external {
        AVS memory avs = operatorAVSs[operator][avsContract];
        require(avs.isRegistered, "AVS not registered");
        require(msg.sender == avsContract, "Only AVS can slash");

        // VULNERABLE: No evidence parameter
        // VULNERABLE: No appeal period
        // VULNERABLE: Instant slashing

        Stake storage stake = stakes[operator];
        uint256 slashAmount = (stake.amount * percentage) / 100;

        // VULNERABLE: Compound slashing possible
        // If operator has 32 ETH and 3 AVSs each slash 100%:
        // AVS1 slashes 32 ETH (stake now 0)
        // AVS2 tries to slash 32 ETH (fails, gets 0)
        // AVS3 tries to slash 32 ETH (fails, gets 0)
        // Cascading failure!

        if (stake.amount >= slashAmount) {
            stake.amount -= slashAmount;
            stake.slashedAmount += slashAmount;
        } else {
            // VULNERABLE: Partial slashing with no coordination
            stake.slashedAmount += stake.amount;
            stake.amount = 0;
            stake.isActive = false;
        }

        // VULNERABLE: No MAX_SLASH_PERCENTAGE constant
        // VULNERABLE: No limit on total slashing across AVSs
    }

    /**
     * @notice Calculate total slashing exposure
     * @dev Helper to show vulnerability severity
     */
    function calculateMaxSlashingExposure(address operator) public view returns (uint256) {
        // This can exceed 100%!
        uint256 totalExposure = 0;

        // VULNERABLE: Would need to iterate all AVSs (not implemented)
        // Total exposure = sum of all AVS slashing percentages
        // Can easily reach 300-500% for operators in multiple AVSs

        return totalExposure;
    }

    function stake() external payable {
        stakes[msg.sender].amount += msg.value;
        stakes[msg.sender].isActive = true;
    }

    function withdraw() external {
        Stake memory userStake = stakes[msg.sender];
        require(userStake.amount > 0, "No stake");

        // VULNERABLE: No withdrawal delay
        // Should have 7-day delay like EigenLayer

        uint256 amount = userStake.amount;
        stakes[msg.sender].amount = 0;
        stakes[msg.sender].isActive = false;

        payable(msg.sender).transfer(amount);
    }
}

/**
 * Expected Detection:
 * - restaking-slashing-conditions: Multiple critical findings
 *   - No evidence parameter in slashing function
 *   - No appeal period for slashing
 *   - Compound slashing possible (operator can lose >100%)
 *   - No MAX_SLASH_PERCENTAGE constant
 *   - No coordination between AVSs
 *   - Cascading slashing risk
 *
 * - restaking-withdrawal-delays: High finding
 *   - No withdrawal delay (instant withdrawal)
 *   - Missing 7-day delay requirement
 */
