// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title PermitExploit
 * @notice Demonstrates EIP-2612 permit signature vulnerabilities
 *
 * VULNERABILITY: Permit signature exploits
 * SEVERITY: Critical
 * CATEGORY: Signature / Authentication
 *
 * BACKGROUND:
 * EIP-2612 introduces gasless approvals via off-chain signatures.
 * Users sign a message approving token spending, which can be submitted by anyone.
 *
 * ATTACK VECTORS:
 * 1. Front-running: Attacker frontruns permit() call and drains tokens
 * 2. Signature phishing: Trick users into signing malicious permit
 * 3. Cross-chain replay: Replay signature on different chain
 * 4. Unlimited approvals: Permit for type(uint256).max
 * 5. Deadline manipulation: Long deadlines leave users vulnerable
 *
 * REAL-WORLD CASES:
 * - Multiple DeFi phishing attacks (2022-2024)
 * - MEV bots exploiting permit frontrunning
 * - Cross-chain signature replay attacks
 *
 * TESTED DETECTORS:
 * - permit-signature-exploit
 * - signature-replay
 * - front-running
 * - missing-chainid-validation
 */

/**
 * @title VulnerableERC20Permit
 * @notice ERC20 with vulnerable permit implementation
 */
contract VulnerableERC20Permit {
    string public name = "Vulnerable Permit Token";
    string public symbol = "VPT";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => uint256) public nonces;

    // VULNERABILITY 1: Missing chainId in DOMAIN_SEPARATOR
    bytes32 public DOMAIN_SEPARATOR;
    bytes32 public constant PERMIT_TYPEHASH = keccak256(
        "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
    );

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;

        // VULNERABLE: DOMAIN_SEPARATOR doesn't include chainId
        DOMAIN_SEPARATOR = keccak256(abi.encode(
            keccak256("EIP712Domain(string name,string version,address verifyingContract)"),
            keccak256(bytes(name)),
            keccak256(bytes("1")),
            address(this)
        ));
    }

    function transfer(address to, uint256 value) external returns (bool) {
        require(balanceOf[msg.sender] >= value, "Insufficient balance");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) external returns (bool) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value)
        external
        returns (bool)
    {
        require(balanceOf[from] >= value, "Insufficient balance");
        require(allowance[from][msg.sender] >= value, "Insufficient allowance");

        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;

        emit Transfer(from, to, value);
        return true;
    }

    /**
     * @notice VULNERABILITY 2: No protection against frontrunning
     * @dev Attacker can see signature in mempool and frontrun
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        // VULNERABLE: No deadline validation allows expired signatures
        require(deadline >= block.timestamp, "Signature expired");

        bytes32 structHash = keccak256(abi.encode(
            PERMIT_TYPEHASH,
            owner,
            spender,
            value,
            nonces[owner]++,
            deadline
        ));

        bytes32 digest = keccak256(abi.encodePacked(
            "\x19\x01",
            DOMAIN_SEPARATOR,
            structHash
        ));

        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress != address(0), "Invalid signature");
        require(recoveredAddress == owner, "Invalid signer");

        // VULNERABLE: No protection against frontrunning
        // Attacker can call this before legitimate user
        allowance[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @notice VULNERABILITY 3: Allows unlimited approvals
     */
    function permitUnlimited(
        address owner,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        // VULNERABLE: Approves unlimited spending (common phishing vector)
        this.permit(owner, msg.sender, type(uint256).max, deadline, v, r, s);
    }
}

/**
 * @title PermitPhishingContract
 * @notice Malicious contract that tricks users into signing permits
 */
contract PermitPhishingContract {
    VulnerableERC20Permit public token;

    constructor(address _token) {
        token = VulnerableERC20Permit(_token);
    }

    /**
     * @notice ATTACK 1: Phishing attack - claim to be "airdrop claimer"
     * @dev User signs permit thinking they'll get airdrop
     */
    function claimAirdrop(
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        // User thinks they're claiming airdrop
        // Actually approving unlimited token spending

        token.permitUnlimited(msg.sender, deadline, v, r, s);

        // Steal all tokens
        uint256 balance = token.balanceOf(msg.sender);
        token.transferFrom(msg.sender, address(this), balance);
    }

    /**
     * @notice ATTACK 2: Fake "gas refund" requiring permit signature
     */
    function claimGasRefund(
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        // User signs permit thinking they'll get gas refund
        token.permit(msg.sender, address(this), value, deadline, v, r, s);

        // Steal tokens
        token.transferFrom(msg.sender, address(this), value);
    }
}

/**
 * @title PermitFrontrunAttacker
 * @notice Demonstrates permit frontrunning
 */
contract PermitFrontrunAttacker {
    VulnerableERC20Permit public token;

    constructor(address _token) {
        token = VulnerableERC20Permit(_token);
    }

    /**
     * @notice ATTACK 3: Frontrun permit and drain tokens
     */
    function frontrunPermit(
        address owner,
        address intendedSpender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        // Attacker sees permit signature in mempool
        // Frontruns with higher gas price
        // Gets approval before intended spender

        token.permit(owner, address(this), value, deadline, v, r, s);

        // Drain tokens
        token.transferFrom(owner, address(this), value);
    }

    /**
     * @notice ATTACK 4: Replay signature on different chain
     */
    function replayOnDifferentChain(
        address owner,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        // VULNERABLE: DOMAIN_SEPARATOR doesn't include chainId
        // Signature from mainnet can be replayed on testnet/L2

        token.permit(owner, address(this), value, deadline, v, r, s);
        token.transferFrom(owner, address(this), value);
    }
}

/**
 * @title VulnerablePermitSwap
 * @notice Vulnerable DEX using permit for approvals
 */
contract VulnerablePermitSwap {
    VulnerableERC20Permit public tokenA;
    VulnerableERC20Permit public tokenB;

    uint256 public reserveA;
    uint256 public reserveB;

    constructor(address _tokenA, address _tokenB) {
        tokenA = VulnerableERC20Permit(_tokenA);
        tokenB = VulnerableERC20Permit(_tokenB);
    }

    /**
     * @notice VULNERABILITY 4: Swap with permit (frontrunning risk)
     */
    function swapWithPermit(
        uint256 amountIn,
        uint256 minAmountOut,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        // User signs permit + swap in one tx
        // VULNERABLE: Attacker can frontrun and manipulate reserves

        tokenA.permit(msg.sender, address(this), amountIn, deadline, v, r, s);

        // VULNERABLE: No slippage protection check before permit
        // Attacker can sandwich attack

        uint256 amountOut = (amountIn * reserveB) / (reserveA + amountIn);
        require(amountOut >= minAmountOut, "Insufficient output");

        tokenA.transferFrom(msg.sender, address(this), amountIn);
        tokenB.transfer(msg.sender, amountOut);

        reserveA += amountIn;
        reserveB -= amountOut;
    }

    /**
     * @notice VULNERABILITY 5: Batch permit without atomic execution
     */
    function batchSwapWithPermit(
        address[] calldata owners,
        uint256[] calldata amounts,
        uint256[] calldata deadlines,
        uint8[] calldata vs,
        bytes32[] calldata rs,
        bytes32[] calldata ss
    ) external {
        // VULNERABLE: Non-atomic batch permits
        // Some permits may succeed, others may be frontrun

        for (uint256 i = 0; i < owners.length; i++) {
            tokenA.permit(
                owners[i],
                address(this),
                amounts[i],
                deadlines[i],
                vs[i],
                rs[i],
                ss[i]
            );

            // VULNERABLE: If one permit is frontrun, entire batch fails
            tokenA.transferFrom(owners[i], address(this), amounts[i]);
        }
    }

    function addLiquidity(uint256 amountA, uint256 amountB) external {
        tokenA.transferFrom(msg.sender, address(this), amountA);
        tokenB.transferFrom(msg.sender, address(this), amountB);
        reserveA += amountA;
        reserveB += amountB;
    }
}

/**
 * @title SecureERC20Permit
 * @notice Demonstrates proper permit implementation
 */
contract SecureERC20Permit {
    string public constant name = "Secure Permit Token";
    string public constant symbol = "SPT";
    uint8 public constant decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => uint256) public nonces;

    // MITIGATION 1: Include chainId in DOMAIN_SEPARATOR
    bytes32 public immutable DOMAIN_SEPARATOR;
    bytes32 public constant PERMIT_TYPEHASH = keccak256(
        "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
    );

    // MITIGATION 2: Track used signatures
    mapping(bytes32 => bool) public usedSignatures;

    // MITIGATION 3: Configurable max deadline
    uint256 public constant MAX_DEADLINE_DURATION = 1 hours;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor() {
        totalSupply = 1000000 * 10**18;
        balanceOf[msg.sender] = totalSupply;

        // MITIGATION 1: Include chainId
        DOMAIN_SEPARATOR = keccak256(abi.encode(
            keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
            keccak256(bytes(name)),
            keccak256(bytes("1")),
            block.chainid,
            address(this)
        ));
    }

    function transfer(address to, uint256 value) external returns (bool) {
        require(balanceOf[msg.sender] >= value, "Insufficient balance");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) external returns (bool) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value)
        external
        returns (bool)
    {
        require(balanceOf[from] >= value, "Insufficient balance");
        require(allowance[from][msg.sender] >= value, "Insufficient allowance");

        balanceOf[from] -= value;
        balanceOf[to] += value;

        if (allowance[from][msg.sender] != type(uint256).max) {
            allowance[from][msg.sender] -= value;
        }

        emit Transfer(from, to, value);
        return true;
    }

    /**
     * @notice SECURE: Protected permit implementation
     */
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external {
        // MITIGATION 2: Strict deadline validation
        require(deadline >= block.timestamp, "Signature expired");
        require(deadline <= block.timestamp + MAX_DEADLINE_DURATION, "Deadline too far");

        bytes32 structHash = keccak256(abi.encode(
            PERMIT_TYPEHASH,
            owner,
            spender,
            value,
            nonces[owner]++,
            deadline
        ));

        bytes32 digest = keccak256(abi.encodePacked(
            "\x19\x01",
            DOMAIN_SEPARATOR,
            structHash
        ));

        // MITIGATION 3: Prevent signature reuse
        require(!usedSignatures[digest], "Signature already used");
        usedSignatures[digest] = true;

        address recoveredAddress = ecrecover(digest, v, r, s);
        require(recoveredAddress != address(0), "Invalid signature");
        require(recoveredAddress == owner, "Invalid signer");

        // MITIGATION 4: Emit event for monitoring
        allowance[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    /**
     * @notice SECURE: Permit with immediate execution
     * @dev Reduces frontrunning window
     */
    function permitAndTransferFrom(
        address owner,
        address to,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) external returns (bool) {
        // Permit and execute in same transaction
        this.permit(owner, msg.sender, value, deadline, v, r, s);
        return this.transferFrom(owner, to, value);
    }
}

/**
 * @title PermitHelper
 * @notice Helper for secure permit patterns
 */
contract PermitHelper {
    /**
     * @notice SECURE: Validate permit parameters before signing
     */
    function validatePermitParameters(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline
    ) external view returns (bool) {
        // Validation checks users should perform before signing
        require(owner == msg.sender, "Not your tokens");
        require(spender != address(0), "Invalid spender");
        require(value > 0 && value != type(uint256).max, "Suspicious value");
        require(deadline <= block.timestamp + 1 hours, "Deadline too long");
        require(deadline >= block.timestamp + 5 minutes, "Deadline too short");

        return true;
    }

    /**
     * @notice SECURE: Revoke permit by incrementing nonce
     */
    function revokePermit(address token) external {
        // Increment nonce to invalidate any pending permits
        SecureERC20Permit(token).permit(
            msg.sender,
            address(0),
            0,
            block.timestamp,
            0,
            bytes32(0),
            bytes32(0)
        );
    }
}
