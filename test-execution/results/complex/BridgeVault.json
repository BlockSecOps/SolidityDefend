{
  "version": "1.3.6",
  "timestamp": "2025-11-17T22:55:14.141337Z",
  "findings": [
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Variable initialized with constant value but not marked as constant/immutable. Use constant or immutable Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 59,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "time-locked-admin-bypass",
      "message": "Admin functions exist but don't enforce timelock delay - timelock may be bypassable",
      "severity": "critical",
      "location": {
        "line": 1,
        "column": 1,
        "length": 10992
      },
      "fix_suggestion": {
        "description": "Route all admin functions through timelock contract with schedule‚Üíexecute pattern",
        "replacements": []
      }
    },
    {
      "detector_id": "time-locked-admin-bypass",
      "message": "Timelock implementation incomplete - missing queue/schedule or execute functions",
      "severity": "critical",
      "location": {
        "line": 1,
        "column": 1,
        "length": 10992
      },
      "fix_suggestion": {
        "description": "Implement complete timelock flow: propose‚Üíqueue‚Üíwait(delay)‚Üíexecute",
        "replacements": []
      }
    },
    {
      "detector_id": "time-locked-admin-bypass",
      "message": "Emergency functions bypass timelock without multisig protection",
      "severity": "critical",
      "location": {
        "line": 1,
        "column": 1,
        "length": 10992
      },
      "fix_suggestion": {
        "description": "Require multisig approval for emergency functions that bypass timelock",
        "replacements": []
      }
    },
    {
      "detector_id": "guardian-role-centralization",
      "message": "Guardian role lacks explicit revocation mechanism - may be irremovable if compromised",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 10992
      },
      "fix_suggestion": {
        "description": "Implement guardian revocation function callable by DAO/owner for emergency scenarios",
        "replacements": []
      }
    },
    {
      "detector_id": "erc20-transfer-return-bomb",
      "message": "Token transfer lacks return data size validation - vulnerable to return bomb DOS",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 10992
      },
      "fix_suggestion": {
        "description": "Check returndatasize() and reject if excessive (>64 bytes): require(returndatasize() <= 64)",
        "replacements": []
      }
    },
    {
      "detector_id": "token-decimal-confusion",
      "message": "Multiple tokens (5) without decimal tracking - calculation errors likely",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 10992
      },
      "fix_suggestion": {
        "description": "Store decimals per token: mapping(address => uint8) public tokenDecimals",
        "replacements": []
      }
    },
    {
      "detector_id": "token-decimal-confusion",
      "message": "Decimal-sensitive math operations without validation - verify decimal assumptions",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 10992
      },
      "fix_suggestion": {
        "description": "Validate expected decimals: require(token.decimals() == EXPECTED_DECIMALS)",
        "replacements": []
      }
    },
    {
      "detector_id": "floating-pragma",
      "message": "Floating pragma detected: pragma solidity ^0.8.20;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.",
      "severity": "low",
      "location": {
        "line": 2,
        "column": 0,
        "length": 24
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Lock pragma to specific version: 'pragma solidity 0.8.20;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.",
        "replacements": []
      }
    },
    {
      "detector_id": "logic-error-patterns",
      "message": "Potential division before multiplication - causes precision loss (OWASP 2025)",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "‚ùå PRECISION LOSS ($63.8M in losses):\nuint256 reward = (amount / totalSupply) * rewardRate;\n// Result: 0 if amount < totalSupply!\n\n‚úÖ CORRECT ORDER:\nuint256 reward = (amount * rewardRate) / totalSupply;\n// Maximizes precision, multiply before divide\n\n‚úÖ BEST: Use fixed-point math:\nuint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;\n\nReal incidents:\n- Cork Protocol: $11M (May 2025) - Division rounding\n- SIR.trading: $355K (March 2025) - Reward calculation\n- Multiple 2024 incidents: $63.8M total",
        "replacements": []
      }
    },
    {
      "detector_id": "logic-error-patterns",
      "message": "Percentage calculation - verify order of operations for precision",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Percentage calculations require careful ordering:\n\n‚ùå WRONG (precision loss):\nuint256 fee = (amount / 10000) * feePercent;\n\n‚úÖ CORRECT:\nuint256 fee = (amount * feePercent) / 10000;\n\n‚úÖ BEST (with basis points):\nuint256 constant BASIS_POINTS = 10000;\nuint256 fee = (amount * feeBasisPoints) / BASIS_POINTS;\n\nExample: 250 basis points = 2.5%\namount = 1000, feeBasisPoints = 250\nfee = (1000 * 250) / 10000 = 25 ‚úÖ\n\nWRONG order:\nfee = (1000 / 10000) * 250 = 0 * 250 = 0 ‚ùå",
        "replacements": []
      }
    },
    {
      "detector_id": "oracle-time-window-attack",
      "message": "Oracle price usage without time-weighted average - consider TWAP",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Single-block price oracles are manipulable:\n\n‚ùå Vulnerable patterns:\n- Using spot price from DEX\n- Single block price snapshot\n- No time-weighting\n- No price deviation checks\n\n‚úÖ Recommended solutions:\n\n1. Use Uniswap V3 TWAP (30+ minute window)\n2. Use Chainlink Price Feeds (aggregated off-chain)\n3. Combine multiple oracle sources\n4. Implement price deviation bounds:\nrequire(abs(newPrice - lastPrice) < maxDelta);\n5. Use time-weighted moving average:\npriceSum += currentPrice;\npriceCount++;\navgPrice = priceSum / priceCount;\n\nMinimum TWAP window: 30 minutes (longer is better)\nMaximum price deviation: 2-5% from last update",
        "replacements": []
      }
    },
    {
      "detector_id": "post-080-overflow",
      "message": "Assembly arithmetic detected - no overflow protection! ($223M Cetus DEX)",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "üö® CRITICAL: Assembly has NO overflow protection!\n\nReal incident: Cetus DEX - $223M loss (May 2025)\nCause: Assembly arithmetic overflow\n\n‚ùå VULNERABLE (Cetus-style vulnerability):\nassembly {\nlet result := add(a, b)  // NO OVERFLOW CHECK!\nlet product := mul(x, y) // NO OVERFLOW CHECK!\nmstore(0x00, result)\n}\n\n‚úÖ SOLUTION 1 - Add manual checks:\nassembly {\nlet result := add(a, b)\n// Manual overflow check\nif lt(result, a) {\nrevert(0, 0)  // Overflow detected\n}\n}\n\n‚úÖ SOLUTION 2 - Use Solidity instead:\n// Let Solidity handle overflow checks\nuint256 result = a + b;  // Automatic overflow check\n\n‚úÖ SOLUTION 3 - SafeMath for assembly:\nfunction safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\nuint256 c;\nassembly {\nc := add(a, b)\n}\nrequire(c >= a, \"Overflow\");  // Check outside assembly\nreturn c;\n}\n\nAssembly arithmetic operations with NO checks:\n- add(a, b)     ‚Üí wraps on overflow\n- sub(a, b)     ‚Üí wraps on underflow\n- mul(a, b)     ‚Üí wraps on overflow\n- div(a, b)     ‚Üí returns 0 if b is 0 (no revert!)\n\n‚ö†Ô∏è Only use assembly arithmetic when absolutely necessary\nand with manual overflow checks!",
        "replacements": []
      }
    },
    {
      "detector_id": "post-080-overflow",
      "message": "Type casting to smaller uint - verify no overflow on downcast",
      "severity": "low",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Downcasting can silently overflow even in Solidity 0.8.0+!\n\n‚ùå UNSAFE DOWNCAST:\nuint256 bigValue = 1000;\nuint8 smallValue = uint8(bigValue);  // Wraps to 232! (1000 % 256)\n\n‚úÖ SAFE DOWNCAST with validation:\nuint256 bigValue = 1000;\nrequire(bigValue <= type(uint8).max, \"Value too large\");\nuint8 smallValue = uint8(bigValue);  // Safe now\n\n‚úÖ USE SafeCast library (OpenZeppelin):\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nuint256 bigValue = 1000;\nuint8 smallValue = SafeCast.toUint8(bigValue);  // Reverts if > 255\n\nType limits:\n- uint8:   0 to 255\n- uint16:  0 to 65,535\n- uint32:  0 to 4,294,967,295\n- uint64:  0 to 18,446,744,073,709,551,615\n- uint256: 0 to 2^256-1",
        "replacements": []
      }
    },
    {
      "detector_id": "pool-donation-enhanced",
      "message": "Pool initialization lacks protection - first depositor can manipulate initial share price",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 10992
      },
      "fix_suggestion": {
        "description": "Require minimum initial deposit, mint dead shares on initialization, or use time-delayed activation",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-access-modifiers",
      "message": "Function 'initiateBridge' performs critical operations but lacks access control modifiers",
      "severity": "critical",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier like 'onlyOwner' to function 'initiateBridge'",
        "replacements": []
      }
    },
    {
      "detector_id": "unprotected-initializer",
      "message": "Initializer function 'initiateBridge' lacks access control and can be called by anyone",
      "severity": "high",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier to 'initiateBridge' or ensure it can only be called once during deployment",
        "replacements": []
      }
    },
    {
      "detector_id": "classic-reentrancy",
      "message": "Function 'initiateBridge' may be vulnerable to reentrancy attacks due to state changes after external calls",
      "severity": "high",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Apply checks-effects-interactions pattern or use a reentrancy guard in function 'initiateBridge'",
        "replacements": []
      }
    },
    {
      "detector_id": "readonly-reentrancy",
      "message": "View function 'getValidatorCount' reads state that may be inconsistent during reentrancy. Contract has state-changing functions that make external calls before updating state.",
      "severity": "medium",
      "location": {
        "line": 311,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Add a reentrancy guard to state-changing functions or ensure view function 'getValidatorCount' cannot be called during callbacks (e.g., using a reentrancy lock check in the view function)",
        "replacements": []
      }
    },
    {
      "detector_id": "invalid-state-transition",
      "message": "State variables modified after external call - potential reentrancy affecting state machine",
      "severity": "critical",
      "location": {
        "line": 200,
        "column": 9,
        "length": 69
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Use checks-effects-interactions pattern or reentrancy guards",
        "replacements": []
      }
    },
    {
      "detector_id": "invalid-state-transition",
      "message": "State variables modified after external call - potential reentrancy affecting state machine",
      "severity": "critical",
      "location": {
        "line": 215,
        "column": 9,
        "length": 34
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Use checks-effects-interactions pattern or reentrancy guards",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'token' in function 'initiateBridge' is not checked for zero address",
      "severity": "high",
      "location": {
        "line": 109,
        "column": 17,
        "length": 5
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(token != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'token' in function 'emergencyWithdraw' is not checked for zero address",
      "severity": "high",
      "location": {
        "line": 209,
        "column": 17,
        "length": 5
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(token != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'to' in function 'emergencyWithdraw' is not checked for zero address",
      "severity": "high",
      "location": {
        "line": 211,
        "column": 17,
        "length": 2
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(to != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'bridgeAddress' in function 'addSupportedChain' is not checked for zero address",
      "severity": "medium",
      "location": {
        "line": 249,
        "column": 17,
        "length": 13
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(bridgeAddress != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "array-bounds-check",
      "message": "Array access to '_validators' may be out of bounds - index not validated",
      "severity": "high",
      "location": {
        "line": 100,
        "column": 33,
        "length": 14
      },
      "cwe": "CWE-125",
      "fix_suggestion": {
        "description": "Add bounds check: require(index < _validators.length, \"Index out of bounds\");",
        "replacements": []
      }
    },
    {
      "detector_id": "array-bounds-check",
      "message": "Array access to 'newValidators' may be out of bounds - index not validated",
      "severity": "high",
      "location": {
        "line": 238,
        "column": 33,
        "length": 16
      },
      "cwe": "CWE-125",
      "fix_suggestion": {
        "description": "Add bounds check: require(index < newValidators.length, \"Index out of bounds\");",
        "replacements": []
      }
    },
    {
      "detector_id": "short-address-attack",
      "message": "Function 'emergencyWithdraw' may be vulnerable to short address attack. Accepts address and value parameters but doesn't validate msg.data.length. An attacker can provide a truncated address causing the EVM to pad it, potentially shifting the value parameter and allowing larger transfers than intended.",
      "severity": "medium",
      "location": {
        "line": 208,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "Add msg.data.length validation to 'emergencyWithdraw'. Add at function start: require(msg.data.length >= 68, \"Invalid input length\"); For functions with address+uint256: 4 bytes (selector) + 32 bytes (address) + 32 bytes (uint256) = 68 bytes minimum. Adjust the required length based on your function's parameters.",
        "replacements": []
      }
    },
    {
      "detector_id": "unchecked-external-call",
      "message": "External call in function 'completeBridge' does not check return value",
      "severity": "medium",
      "location": {
        "line": 153,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-252",
      "fix_suggestion": {
        "description": "Check the return value of external calls in function 'completeBridge'",
        "replacements": []
      }
    },
    {
      "detector_id": "unchecked-external-call",
      "message": "External call in function 'emergencyWithdraw' does not check return value",
      "severity": "medium",
      "location": {
        "line": 208,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-252",
      "fix_suggestion": {
        "description": "Check the return value of external calls in function 'emergencyWithdraw'",
        "replacements": []
      }
    },
    {
      "detector_id": "external-calls-loop",
      "message": "Function 'completeBridge' contains external calls within loops. This can lead to DoS attacks if any external call fails or consumes excessive gas, and can be exploited in governance systems to block proposal execution.",
      "severity": "high",
      "location": {
        "line": 153,
        "column": 0,
        "length": 14
      },
      "cwe": "CWE-834",
      "fix_suggestion": {
        "description": "Avoid external calls in loops. Consider using a withdrawal pattern, batch processing, or fail-safe mechanisms for critical operations.",
        "replacements": []
      }
    },
    {
      "detector_id": "signature-replay",
      "message": "Function '' verifies signatures without replay protection. Attackers can reuse valid signatures to perform unauthorized actions. This is particularly dangerous in governance systems for vote manipulation.",
      "severity": "high",
      "location": {
        "line": 93,
        "column": 0,
        "length": 0
      },
      "cwe": "CWE-294",
      "fix_suggestion": {
        "description": "Implement a nonce system to prevent signature replay attacks. Include a unique nonce in the signed message and track used nonces.",
        "replacements": []
      }
    },
    {
      "detector_id": "signature-replay",
      "message": "Function 'recoverSigner' verifies signatures without replay protection. Attackers can reuse valid signatures to perform unauthorized actions. This is particularly dangerous in governance systems for vote manipulation.",
      "severity": "high",
      "location": {
        "line": 278,
        "column": 0,
        "length": 13
      },
      "cwe": "CWE-294",
      "fix_suggestion": {
        "description": "Implement a nonce system to prevent signature replay attacks. Include a unique nonce in the signed message and track used nonces.",
        "replacements": []
      }
    },
    {
      "detector_id": "cross-chain-replay",
      "message": "Function 'completeBridge' generates hash/signature without chain ID protection. This allows the same signature to be replayed on different chains, potentially draining funds on all supported chains.",
      "severity": "critical",
      "location": {
        "line": 153,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-294",
      "fix_suggestion": {
        "description": "Include 'block.chainid' in the hash calculation for function 'completeBridge'. Example: keccak256(abi.encodePacked(..., block.chainid))",
        "replacements": []
      }
    },
    {
      "detector_id": "weak-signature-validation",
      "message": "Function 'completeBridge' validates multiple signatures without checking for duplicates. An attacker can submit the same valid signature multiple times to meet the required signature threshold, bypassing multi-signature protection.",
      "severity": "high",
      "location": {
        "line": 153,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-345",
      "fix_suggestion": {
        "description": "Add duplicate signer check in function 'completeBridge'. Example: Track seen signers in a mapping or check array for duplicates. require(!seen[signer], \"Duplicate signer\"); seen[signer] = true;",
        "replacements": []
      }
    },
    {
      "detector_id": "emergency-function-abuse",
      "message": "Function 'emergencyWithdraw' is an emergency function without time-lock or multi-signature protection. A single admin can execute emergency actions immediately, enabling potential abuse or rug pulls.",
      "severity": "medium",
      "location": {
        "line": 208,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-269",
      "fix_suggestion": {
        "description": "Add time-lock and multi-sig protection to emergency function 'emergencyWithdraw'. Example: Require time-lock delay (e.g., 24-48 hours) and multi-signature approval before emergency actions can be executed.",
        "replacements": []
      }
    },
    {
      "detector_id": "signature-malleability",
      "message": "Function 'recoverSigner' uses ECDSA signature verification without malleability protection. Uses ecrecover without checking 's' value against secp256k1 curve order ECDSA signatures have two valid forms (s and -s mod n). Without checking that s is in the lower half range, attackers can create alternate valid signatures for replay attacks.",
      "severity": "high",
      "location": {
        "line": 278,
        "column": 14,
        "length": 13
      },
      "cwe": "CWE-347",
      "fix_suggestion": {
        "description": "Add signature malleability check in 'recoverSigner'. Use OpenZeppelin's ECDSA library or add: `require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid signature 's' value\");` This ensures s is in the lower half of the curve order.",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-eip712-domain",
      "message": "Function 'recoverSigner' Uses ecrecover() without proper EIP-712 domain separator. Signatures are vulnerable to replay attacks across contracts and chains.",
      "severity": "high",
      "location": {
        "line": 278,
        "column": 14,
        "length": 13
      },
      "cwe": "CWE-345",
      "fix_suggestion": {
        "description": "Implement proper EIP-712 domain separator:\n1. Define DOMAIN_SEPARATOR with all required fields (name, version, chainId, verifyingContract)\n2. Use structured data hashing with EIP-712\n3. Include domain separator in signature hash: keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, structHash))\n4. Or use OpenZeppelin's EIP712 implementation",
        "replacements": []
      }
    },
    {
      "detector_id": "vault-donation-attack",
      "message": "Function 'completeBridge' may be vulnerable to vault donation attack. Uses balanceOf(address(this)) for share price calculation without internal balance tracking. Vulnerable to direct token donation manipulation Attacker can manipulate share price by directly transferring tokens to vault, causing rounding errors that steal from depositors.",
      "severity": "high",
      "location": {
        "line": 153,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Protect 'completeBridge' from donation attack. Solutions: (1) Track assets internally instead of using balanceOf, (2) Implement donation guards that track expected vs actual balance, (3) Use virtual shares/assets to make donations economically infeasible (OpenZeppelin ERC4626), (4) Require minimum initial deposits, (5) Use dead shares pattern (Uniswap V2 style), (6) Consider EigenLayer delegation pattern for restaking protocols.",
        "replacements": []
      }
    },
    {
      "detector_id": "timestamp-manipulation",
      "message": "Function 'initiateBridge' has dangerous timestamp dependency. Uses keccak256 with block variables (timestamp/difficulty/number/prevrandao) for randomness. These values are predictable/manipulable by miners and validators, enabling attacks on randomness-dependent logic. Use Chainlink VRF or commit-reveal schemes instead Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.",
      "severity": "high",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-367",
      "fix_suggestion": {
        "description": "Reduce timestamp dependency in 'initiateBridge'. Use block.number for time intervals, add tolerance ranges (¬±15 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.",
        "replacements": []
      }
    },
    {
      "detector_id": "timestamp-manipulation",
      "message": "Function 'completeBridge' has dangerous timestamp dependency. Uses keccak256 with block variables (timestamp/difficulty/number/prevrandao) for randomness. These values are predictable/manipulable by miners and validators, enabling attacks on randomness-dependent logic. Use Chainlink VRF or commit-reveal schemes instead Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.",
      "severity": "high",
      "location": {
        "line": 153,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-367",
      "fix_suggestion": {
        "description": "Reduce timestamp dependency in 'completeBridge'. Use block.number for time intervals, add tolerance ranges (¬±15 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.",
        "replacements": []
      }
    },
    {
      "detector_id": "deadline-manipulation",
      "message": "Function 'initiateBridge' has deadline manipulation risk. Deadline parameter exists but is not validated against current time, allowing expired transactions to execute Validators can hold transactions and execute them at times that benefit MEV extraction or harm users.",
      "severity": "medium",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-367",
      "fix_suggestion": {
        "description": "Improve deadline handling in 'initiateBridge'. Use reasonable default deadlines (e.g., block.timestamp + 15 minutes), validate deadline parameters, add minimum deadline checks, or implement deadline extensions for failed transactions.",
        "replacements": []
      }
    },
    {
      "detector_id": "deadline-manipulation",
      "message": "Function 'completeBridge' has deadline manipulation risk. Deadline parameter exists but is not validated against current time, allowing expired transactions to execute Validators can hold transactions and execute them at times that benefit MEV extraction or harm users.",
      "severity": "medium",
      "location": {
        "line": 153,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-367",
      "fix_suggestion": {
        "description": "Improve deadline handling in 'completeBridge'. Use reasonable default deadlines (e.g., block.timestamp + 15 minutes), validate deadline parameters, add minimum deadline checks, or implement deadline extensions for failed transactions.",
        "replacements": []
      }
    },
    {
      "detector_id": "nonce-reuse",
      "message": "Function 'initiateBridge' has nonce management vulnerability. Uses global nonce instead of per-user mapping, forces sequential execution and limits parallelization Improper nonce handling enables replay attacks or transaction reordering exploits.",
      "severity": "medium",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-294",
      "fix_suggestion": {
        "description": "Fix nonce management in 'initiateBridge'. Increment nonce after validation, use mapping(address => uint256) for per-user nonces, validate nonce before execution, include nonce in signature hash, and implement nonce cancellation mechanism.",
        "replacements": []
      }
    },
    {
      "detector_id": "nonce-reuse",
      "message": "Function 'completeBridge' has nonce management vulnerability. Nonce reuse vulnerability marker detected Improper nonce handling enables replay attacks or transaction reordering exploits.",
      "severity": "medium",
      "location": {
        "line": 153,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-294",
      "fix_suggestion": {
        "description": "Fix nonce management in 'completeBridge'. Increment nonce after validation, use mapping(address => uint256) for per-user nonces, validate nonce before execution, include nonce in signature hash, and implement nonce cancellation mechanism.",
        "replacements": []
      }
    },
    {
      "detector_id": "validator-griefing",
      "message": "Function '' has validator griefing vulnerability. Validators forced to participate in expensive operations, attacker can trigger high gas costs for all validators Attackers can harm validators without economic benefit, leading to validator exits and network destabilization.",
      "severity": "high",
      "location": {
        "line": 93,
        "column": 5,
        "length": 0
      },
      "cwe": "CWE-405",
      "fix_suggestion": {
        "description": "Mitigate validator griefing in ''. Implement griefing-cost mechanisms (deposit requirements), add rate limiting per address, require minimum stake for reporting, implement reputation systems, add penalties for false accusations, and create validator insurance pools.",
        "replacements": []
      }
    },
    {
      "detector_id": "validator-griefing",
      "message": "Function 'completeBridge' has validator griefing vulnerability. Validators forced to participate in expensive operations, attacker can trigger high gas costs for all validators Attackers can harm validators without economic benefit, leading to validator exits and network destabilization.",
      "severity": "high",
      "location": {
        "line": 153,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-405",
      "fix_suggestion": {
        "description": "Mitigate validator griefing in 'completeBridge'. Implement griefing-cost mechanisms (deposit requirements), add rate limiting per address, require minimum stake for reporting, implement reputation systems, add penalties for false accusations, and create validator insurance pools.",
        "replacements": []
      }
    },
    {
      "detector_id": "validator-griefing",
      "message": "Function 'updateValidators' has validator griefing vulnerability. No rate limiting on validator-affecting actions, allows spam attacks to overwhelm validators or slashing logic Attackers can harm validators without economic benefit, leading to validator exits and network destabilization.",
      "severity": "high",
      "location": {
        "line": 221,
        "column": 14,
        "length": 16
      },
      "cwe": "CWE-405",
      "fix_suggestion": {
        "description": "Mitigate validator griefing in 'updateValidators'. Implement griefing-cost mechanisms (deposit requirements), add rate limiting per address, require minimum stake for reporting, implement reputation systems, add penalties for false accusations, and create validator insurance pools.",
        "replacements": []
      }
    },
    {
      "detector_id": "withdrawal-delay",
      "message": "Function 'emergencyWithdraw' has withdrawal delay vulnerability. Withdrawal delay has no maximum cap, admin can set arbitrarily long delays locking funds indefinitely Improper withdrawal mechanisms can lock user funds indefinitely or enable denial of service.",
      "severity": "high",
      "location": {
        "line": 208,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Fix withdrawal mechanism in 'emergencyWithdraw'. Implement maximum withdrawal delay caps, add emergency withdrawal options with penalties, prevent admin from extending delays arbitrarily, implement fair queue systems, add partial withdrawal capabilities, and document clear withdrawal timelines.",
        "replacements": []
      }
    },
    {
      "detector_id": "validator-front-running",
      "message": "Function 'emergencyWithdraw' has validator front-running vulnerability. Price-sensitive operations without fair sequencing, validators can reorder transactions for MEV extraction Validators can observe pending transactions and extract value by front-running users.",
      "severity": "high",
      "location": {
        "line": 208,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Mitigate validator front-running in 'emergencyWithdraw'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
        "replacements": []
      }
    },
    {
      "detector_id": "gas-griefing",
      "message": "Function 'initiateBridge' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
      "severity": "medium",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Mitigate gas griefing in 'initiateBridge'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
        "replacements": []
      }
    },
    {
      "detector_id": "gas-griefing",
      "message": "Function 'completeBridge' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.",
      "severity": "medium",
      "location": {
        "line": 153,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Mitigate gas griefing in 'completeBridge'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
        "replacements": []
      }
    },
    {
      "detector_id": "gas-griefing",
      "message": "Function 'emergencyWithdraw' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
      "severity": "medium",
      "location": {
        "line": 208,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Mitigate gas griefing in 'emergencyWithdraw'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
        "replacements": []
      }
    },
    {
      "detector_id": "dos-unbounded-operation",
      "message": "Function 'updateValidators' has DOS vulnerability via unbounded operation. Deleting array or mapping without size limit, can exceed gas limit Can cause out-of-gas errors blocking contract functionality.",
      "severity": "high",
      "location": {
        "line": 221,
        "column": 14,
        "length": 16
      },
      "cwe": "CWE-834",
      "fix_suggestion": {
        "description": "Fix unbounded operation in 'updateValidators'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.",
        "replacements": []
      }
    },
    {
      "detector_id": "dos-failed-transfer",
      "message": "Function 'completeBridge' uses push pattern for transfers which can cause DoS if recipient reverts. A malicious or buggy recipient contract can block this function by rejecting payments. Use the pull pattern (withdrawal pattern) instead where users withdraw their own funds.",
      "severity": "high",
      "location": {
        "line": 153,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Refactor 'completeBridge' to use pull pattern instead of push. Store pending withdrawals in a mapping and let users withdraw their own funds. Example: balances[user] = amount; then separate withdraw() function. Use OpenZeppelin's PullPayment contract for reference.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function '' contains excessive gas usage pattern. Storage array push operation inside loop. Extremely gas-intensive Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 93,
        "column": 5,
        "length": 0
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in ''. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function '' contains excessive gas usage pattern. Storage write operation inside loop. Consider using memory array Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 93,
        "column": 5,
        "length": 0
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in ''. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function '' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 93,
        "column": 5,
        "length": 0
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in ''. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function 'completeBridge' contains excessive gas usage pattern. Storage write operation inside loop. Consider using memory array Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 153,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in 'completeBridge'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function 'completeBridge' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 153,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in 'completeBridge'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function 'completeBridge' contains excessive gas usage pattern. Event emission inside loop. Can cause excessive gas costs for large arrays Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 153,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in 'completeBridge'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function 'updateValidators' contains excessive gas usage pattern. Storage array push operation inside loop. Extremely gas-intensive Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 221,
        "column": 14,
        "length": 16
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in 'updateValidators'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function 'updateValidators' contains excessive gas usage pattern. Storage write operation inside loop. Consider using memory array Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 221,
        "column": 14,
        "length": 16
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in 'updateValidators'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function 'updateValidators' contains excessive gas usage pattern. Storage deletion inside loop. Each delete costs significant gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 221,
        "column": 14,
        "length": 16
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in 'updateValidators'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function 'updateValidators' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 221,
        "column": 14,
        "length": 16
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in 'updateValidators'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "redundant-checks",
      "message": "Function '' contains redundant checks. 3 consecutive require statements. Consider combining into fewer checks Redundant checks waste gas and increase transaction costs unnecessarily.",
      "severity": "low",
      "location": {
        "line": 93,
        "column": 5,
        "length": 0
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Remove redundant checks in ''. Consider: (1) Eliminate duplicate require() statements, (2) Combine multiple checks into single require(), (3) Remove overflow checks in Solidity >=0.8, (4) Avoid checking same condition in modifier and function, (5) Use custom errors instead of require with strings.",
        "replacements": []
      }
    },
    {
      "detector_id": "redundant-checks",
      "message": "Function 'initiateBridge' contains redundant checks. Manual overflow/underflow check in Solidity 0.8+. Built-in protection makes this redundant Redundant checks waste gas and increase transaction costs unnecessarily.",
      "severity": "low",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Remove redundant checks in 'initiateBridge'. Consider: (1) Eliminate duplicate require() statements, (2) Combine multiple checks into single require(), (3) Remove overflow checks in Solidity >=0.8, (4) Avoid checking same condition in modifier and function, (5) Use custom errors instead of require with strings.",
        "replacements": []
      }
    },
    {
      "detector_id": "redundant-checks",
      "message": "Function 'initiateBridge' contains redundant checks. 3 consecutive require statements. Consider combining into fewer checks Redundant checks waste gas and increase transaction costs unnecessarily.",
      "severity": "low",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Remove redundant checks in 'initiateBridge'. Consider: (1) Eliminate duplicate require() statements, (2) Combine multiple checks into single require(), (3) Remove overflow checks in Solidity >=0.8, (4) Avoid checking same condition in modifier and function, (5) Use custom errors instead of require with strings.",
        "replacements": []
      }
    },
    {
      "detector_id": "centralization-risk",
      "message": "Function 'emergencyWithdraw' has centralization risk. Emergency function 'emergencyWithdraw' lacks multi-party approval. Can be abused by single compromised key Critical function controlled by single address creates attack vector.",
      "severity": "high",
      "location": {
        "line": 208,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-269",
      "fix_suggestion": {
        "description": "Add decentralization to 'emergencyWithdraw'. Implement multi-signature requirements, timelock delays, or DAO governance for this critical function.",
        "replacements": []
      }
    },
    {
      "detector_id": "insufficient-randomness",
      "message": "Function 'initiateBridge' uses weak randomness source. Uses block.timestamp for randomness generation. Miners can manipulate timestamp within ~15 second range to influence outcome Predictable randomness enables attackers to manipulate outcomes in lotteries, games, or selection processes.",
      "severity": "high",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-338",
      "fix_suggestion": {
        "description": "Use secure randomness in 'initiateBridge'. Implement: (1) Chainlink VRF for verifiable randomness, (2) Commit-reveal scheme with multi-block delay, (3) External oracle for random number generation, (4) Avoid block.timestamp, blockhash, or block.number, (5) Use Randao for Ethereum 2.0.",
        "replacements": []
      }
    },
    {
      "detector_id": "insufficient-randomness",
      "message": "Function 'completeBridge' uses weak randomness source. Uses block.timestamp for randomness generation. Miners can manipulate timestamp within ~15 second range to influence outcome Predictable randomness enables attackers to manipulate outcomes in lotteries, games, or selection processes.",
      "severity": "high",
      "location": {
        "line": 153,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-338",
      "fix_suggestion": {
        "description": "Use secure randomness in 'completeBridge'. Implement: (1) Chainlink VRF for verifiable randomness, (2) Commit-reveal scheme with multi-block delay, (3) External oracle for random number generation, (4) Avoid block.timestamp, blockhash, or block.number, (5) Use Randao for Ethereum 2.0.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function '' contains variable shadowing. Parameter 'MAX_VALIDATORS' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 93,
        "column": 5,
        "length": 0
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in ''. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'initiateBridge' contains variable shadowing. Parameter 'token' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'initiateBridge'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'initiateBridge' contains variable shadowing. Parameter 'amount' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'initiateBridge'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'initiateBridge' contains variable shadowing. Parameter 'targetChain' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'initiateBridge'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'initiateBridge' contains variable shadowing. Local variable 'token' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'initiateBridge'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'initiateBridge' contains variable shadowing. Local variable 'amount' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'initiateBridge'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'initiateBridge' contains variable shadowing. Local variable 'targetChain' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'initiateBridge'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'initiateBridge' contains variable shadowing. Local variable 'targetAddress' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'initiateBridge'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'initiateBridge' contains variable shadowing. Local variable 'deadline' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'initiateBridge'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'initiateBridge' contains variable shadowing. Local variable 'nonce' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'initiateBridge'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'initiateBridge' contains variable shadowing. Local variable 'bridgeAmount' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'initiateBridge'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'emergencyWithdraw' contains variable shadowing. Parameter 'token' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 208,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'emergencyWithdraw'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'emergencyWithdraw' contains variable shadowing. Parameter 'amount' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 208,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'emergencyWithdraw'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'emergencyWithdraw' contains variable shadowing. Local variable 'token' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 208,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'emergencyWithdraw'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'emergencyWithdraw' contains variable shadowing. Local variable 'amount' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 208,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'emergencyWithdraw'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'recoverSigner' contains variable shadowing. Local variable 'v' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 278,
        "column": 14,
        "length": 13
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'recoverSigner'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-input-validation",
      "message": "Function 'emergencyWithdraw' missing input validation. Critical function with address parameter lacks zero address validation Missing validation can lead to unexpected behavior, zero address transfers, or invalid state.",
      "severity": "medium",
      "location": {
        "line": 208,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "Add input validation to 'emergencyWithdraw'. Implement: (1) Zero address checks for address parameters, (2) Bounds validation for numeric inputs, (3) Array length validation, (4) require() statements at function start, (5) OpenZeppelin Address library for address validation.",
        "replacements": []
      }
    },
    {
      "detector_id": "unsafe-type-casting",
      "message": "Function 'completeBridge' contains unsafe type casting. address type casting without validation. May result in zero address Unsafe type conversions can lead to data loss, value truncation, or unexpected behavior.",
      "severity": "medium",
      "location": {
        "line": 196,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-704",
      "fix_suggestion": {
        "description": "Add safe type casting in 'completeBridge'. Implement: (1) Validate value ranges before casting, (2) Use require() to check bounds, (3) Use SafeCast library from OpenZeppelin, (4) Avoid downcasting without validation, (5) Check for sign preservation in int/uint conversions.",
        "replacements": []
      }
    },
    {
      "detector_id": "price-manipulation-frontrun",
      "message": "Function 'completeBridge' has price manipulation vulnerability. Uses balanceOf for price calculation. Function 'completeBridge' calculates prices using token balances which can be manipulated via flash loans or large trades This enables flash loan attacks, sandwich attacks, and MEV extraction via price oracle manipulation. Attackers can manipulate prices and extract value from victim transactions",
      "severity": "high",
      "location": {
        "line": 153,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Fix price manipulation in 'completeBridge'. Implement: (1) Use TWAP (Time-Weighted Average Price) instead of spot prices; (2) Validate price staleness: require(block.timestamp - updatedAt <= MAX_DELAY); (3) Add price deviation bounds: require(newPrice >= minPrice && newPrice <= maxPrice); (4) Use multiple oracle sources and median prices; (5) Implement circuit breakers for extreme price moves; (6) Add price impact validation for large operations; (7) Consider commit-reveal for price-sensitive operations",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-transaction-deadline",
      "message": "Function 'emergencyWithdraw' is missing transaction deadline. Missing transaction deadline. Withdrawal operation 'emergencyWithdraw' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed",
      "severity": "medium",
      "location": {
        "line": 208,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add deadline to 'emergencyWithdraw'. Implement: (1) Add 'deadline' parameter: function emergencyWithdraw(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users",
        "replacements": []
      }
    },
    {
      "detector_id": "lending-borrow-bypass",
      "message": "Lending protocol function 'emergencyWithdraw' has borrow bypass vulnerabilities: Collateral withdrawal doesn't validate health factor after removal, may allow withdrawal that causes undercollateralization",
      "severity": "critical",
      "location": {
        "line": 208,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure lending function 'emergencyWithdraw': Calculate and validate health factor before borrow, enforce collateral factor (LTV) limits, add reentrancy guards, implement same-block borrow restrictions for flash loans, update state before external calls (checks-effects-interactions pattern)",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-bridge-message-validation",
      "message": "Function 'emergencyWithdraw' finalizes withdrawals without proper checks. No finality check before withdrawal. Should verify L2 state is finalized Missing validation can allow premature or unauthorized withdrawals.",
      "severity": "critical",
      "location": {
        "line": 208,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-345",
      "fix_suggestion": {
        "description": "Add finality checks to 'emergencyWithdraw': (1) Verify sufficient block confirmations, (2) Check withdrawal was properly initiated on L2, (3) Validate proof of L2 state, (4) Prevent replay with nonce tracking.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-bridge-message-validation",
      "message": "Function 'emergencyWithdraw' finalizes withdrawals without proper checks. Missing withdrawal proof validation. Should verify withdrawal was initiated on L2 Missing validation can allow premature or unauthorized withdrawals.",
      "severity": "critical",
      "location": {
        "line": 208,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-345",
      "fix_suggestion": {
        "description": "Add finality checks to 'emergencyWithdraw': (1) Verify sufficient block confirmations, (2) Check withdrawal was properly initiated on L2, (3) Validate proof of L2 state, (4) Prevent replay with nonce tracking.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-bridge-message-validation",
      "message": "Function 'emergencyWithdraw' finalizes withdrawals without proper checks. Missing replay protection. Withdrawals could be claimed multiple times Missing validation can allow premature or unauthorized withdrawals.",
      "severity": "critical",
      "location": {
        "line": 208,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-345",
      "fix_suggestion": {
        "description": "Add finality checks to 'emergencyWithdraw': (1) Verify sufficient block confirmations, (2) Check withdrawal was properly initiated on L2, (3) Validate proof of L2 state, (4) Prevent replay with nonce tracking.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'initiateBridge' updates fees without proper protections. No access control on fee updates. Anyone can modify fees leading to manipulation Vulnerable fee updates can be front-run or manipulated to extract value.",
      "severity": "medium",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect fee updates in 'initiateBridge': (1) Implement time-delayed fee changes with announcement period, (2) Add governance or multi-sig control for fee updates, (3) Limit rate of fee changes (e.g., max 10% per day), (4) Emit events before fee changes take effect, (5) Consider using commit-reveal scheme for fee updates.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'initiateBridge' updates fees without proper protections. No rate limiting on fee updates. Fees could be changed too frequently causing instability Vulnerable fee updates can be front-run or manipulated to extract value.",
      "severity": "medium",
      "location": {
        "line": 108,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect fee updates in 'initiateBridge': (1) Implement time-delayed fee changes with announcement period, (2) Add governance or multi-sig control for fee updates, (3) Limit rate of fee changes (e.g., max 10% per day), (4) Emit events before fee changes take effect, (5) Consider using commit-reveal scheme for fee updates.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'updateBridgeFee' updates fees without proper protections. No access control on fee updates. Anyone can modify fees leading to manipulation Vulnerable fee updates can be front-run or manipulated to extract value.",
      "severity": "medium",
      "location": {
        "line": 259,
        "column": 14,
        "length": 15
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect fee updates in 'updateBridgeFee': (1) Implement time-delayed fee changes with announcement period, (2) Add governance or multi-sig control for fee updates, (3) Limit rate of fee changes (e.g., max 10% per day), (4) Emit events before fee changes take effect, (5) Consider using commit-reveal scheme for fee updates.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'updateBridgeFee' updates fees without proper protections. No event emission for fee updates. Users cannot track fee changes or prepare for them Vulnerable fee updates can be front-run or manipulated to extract value.",
      "severity": "medium",
      "location": {
        "line": 259,
        "column": 14,
        "length": 15
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect fee updates in 'updateBridgeFee': (1) Implement time-delayed fee changes with announcement period, (2) Add governance or multi-sig control for fee updates, (3) Limit rate of fee changes (e.g., max 10% per day), (4) Emit events before fee changes take effect, (5) Consider using commit-reveal scheme for fee updates.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'updateBridgeFee' updates fees without proper protections. No rate limiting on fee updates. Fees could be changed too frequently causing instability Vulnerable fee updates can be front-run or manipulated to extract value.",
      "severity": "medium",
      "location": {
        "line": 259,
        "column": 14,
        "length": 15
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect fee updates in 'updateBridgeFee': (1) Implement time-delayed fee changes with announcement period, (2) Add governance or multi-sig control for fee updates, (3) Limit rate of fee changes (e.g., max 10% per day), (4) Emit events before fee changes take effect, (5) Consider using commit-reveal scheme for fee updates.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'updateBridgeFee' updates fees without proper protections. No validation of new fee value. Should enforce reasonable bounds on fee changes Vulnerable fee updates can be front-run or manipulated to extract value.",
      "severity": "medium",
      "location": {
        "line": 259,
        "column": 14,
        "length": 15
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect fee updates in 'updateBridgeFee': (1) Implement time-delayed fee changes with announcement period, (2) Add governance or multi-sig control for fee updates, (3) Limit rate of fee changes (e.g., max 10% per day), (4) Emit events before fee changes take effect, (5) Consider using commit-reveal scheme for fee updates.",
        "replacements": []
      }
    },
    {
      "detector_id": "transient-storage-reentrancy",
      "message": "Vulnerable to transient storage reentrancy in 'completeBridge' - transfer()/send() no longer safe with EIP-1153",
      "severity": "critical",
      "location": {
        "line": 153,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "EIP-1153 breaks transfer()/send() safety assumption:\n\nCRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within\nthe 2300 gas stipend of transfer() and send().\n\nFix 1: Use checks-effects-interactions pattern\nfunction withdraw() public {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\n// ‚úÖ Update state BEFORE external call\nbalances[msg.sender] = 0;\n\npayable(msg.sender).transfer(amount);\n}\n\nFix 2: Use ReentrancyGuard\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nfunction withdraw() public nonReentrant {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\nbalances[msg.sender] = 0;\npayable(msg.sender).transfer(amount);\n}\n\nReference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)",
        "replacements": []
      }
    }
  ],
  "metadata": {
    "tool_name": "SolidityDefend",
    "tool_version": "1.3.6",
    "scan_type": "static_analysis",
    "language": "solidity",
    "rules_version": "1.3.6",
    "branding": {
      "name": "BlockSecOps",
      "url": "https://BlockSecOps.com",
      "description": "Enterprise-Grade DevSecOps Platform for Smart Contracts"
    }
  },
  "statistics": {
    "total_findings": 102,
    "severity_counts": {
      "low": 16,
      "medium": 42,
      "critical": 12,
      "high": 32,
      "info": 0
    },
    "unique_detectors": 49
  }
}