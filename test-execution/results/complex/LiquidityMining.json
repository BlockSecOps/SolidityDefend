{
  "version": "1.3.6",
  "timestamp": "2025-11-17T22:55:15.073960Z",
  "findings": [
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Struct contains mixed uint256 and smaller types. Pack smaller types together for gas savings Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 46,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Struct contains mixed uint256 and smaller types. Pack smaller types together for gas savings Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 57,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Struct contains mixed uint256 and smaller types. Pack smaller types together for gas savings Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 71,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Variable initialized with constant value but not marked as constant/immutable. Use constant or immutable Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 95,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Variable initialized with constant value but not marked as constant/immutable. Use constant or immutable Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 97,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "centralization-risk",
      "message": "Contract has centralization risk. Critical operations (withdraw/pause/upgrade) lack timelock delays. Malicious owner can drain funds or brick contract instantly Single point of failure can lead to fund loss, governance attacks, or complete system compromise.",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-269",
      "fix_suggestion": {
        "description": "Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.",
        "replacements": []
      }
    },
    {
      "detector_id": "guardian-role-centralization",
      "message": "Guardian role lacks explicit revocation mechanism - may be irremovable if compromised",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 18865
      },
      "fix_suggestion": {
        "description": "Implement guardian revocation function callable by DAO/owner for emergency scenarios",
        "replacements": []
      }
    },
    {
      "detector_id": "erc20-transfer-return-bomb",
      "message": "Token transfer lacks return data size validation - vulnerable to return bomb DOS",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 18865
      },
      "fix_suggestion": {
        "description": "Check returndatasize() and reject if excessive (>64 bytes): require(returndatasize() <= 64)",
        "replacements": []
      }
    },
    {
      "detector_id": "token-decimal-confusion",
      "message": "Token price/exchange calculation without decimal normalization - incorrect conversions",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 18865
      },
      "fix_suggestion": {
        "description": "Normalize decimals: amount * 10**token1.decimals() / 10**token2.decimals()",
        "replacements": []
      }
    },
    {
      "detector_id": "token-decimal-confusion",
      "message": "Multiple tokens (5) without decimal tracking - calculation errors likely",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 18865
      },
      "fix_suggestion": {
        "description": "Store decimals per token: mapping(address => uint8) public tokenDecimals",
        "replacements": []
      }
    },
    {
      "detector_id": "token-decimal-confusion",
      "message": "Decimal-sensitive math operations without validation - verify decimal assumptions",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 18865
      },
      "fix_suggestion": {
        "description": "Validate expected decimals: require(token.decimals() == EXPECTED_DECIMALS)",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-priority-gas-auction",
      "message": "First-come-first-served mint - creates PGA where users bid up gas to mint first",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 18865
      },
      "fix_suggestion": {
        "description": "Use commit-reveal, whitelist, or fair launch mechanism instead of FCFS",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-priority-gas-auction",
      "message": "Public arbitrage function - creates PGA as bots compete for profit",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 18865
      },
      "fix_suggestion": {
        "description": "Capture MEV for protocol via auction mechanism or restrict to specific keepers",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-toxic-flow-exposure",
      "message": "Static fees on AMM - no protection against toxic flow from informed traders",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 18865
      },
      "fix_suggestion": {
        "description": "Implement dynamic fees that increase with volatility or trade size to discourage toxic flow",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-toxic-flow-exposure",
      "message": "No trade size limits - large informed trades can extract maximum value from LPs",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 18865
      },
      "fix_suggestion": {
        "description": "Add maximum trade size as percentage of reserves: require(amountIn < reserves * maxBps / 10000)",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-toxic-flow-exposure",
      "message": "Instant arbitrage possible - informed traders can extract value with zero risk",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 18865
      },
      "fix_suggestion": {
        "description": "Add block delay or use time-weighted pricing to reduce instant arbitrage opportunities",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-k-invariant-violation",
      "message": "AMM function 'transfer' violates constant product invariant: Token transfers don't account for fee-on-transfer tokens, incorrect reserve calculations may result in pool drainage",
      "severity": "critical",
      "location": {
        "line": 9,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure AMM function 'transfer': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
        "replacements": []
      }
    },
    {
      "detector_id": "floating-pragma",
      "message": "Floating pragma detected: pragma solidity ^0.8.20;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.",
      "severity": "low",
      "location": {
        "line": 2,
        "column": 0,
        "length": 24
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Lock pragma to specific version: 'pragma solidity 0.8.20;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.",
        "replacements": []
      }
    },
    {
      "detector_id": "eip7702-sweeper-detection",
      "message": "MALICIOUS SWEEPER DETECTED (score: 4/10) - Batch token operations, Approve + transferFrom pattern (token drainage)",
      "severity": "critical",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "üö® CRITICAL: This appears to be a malicious sweeper contract!\n\nRisk indicators detected:\n1. Batch token operations\n2. Approve + transferFrom pattern (token drainage)\n\nSweeper contracts are responsible for 97% of malicious EIP-7702 delegations\nin 2025, causing $12M+ in losses.\n\nTypical sweeper behavior:\n1. Accepts EIP-7702 delegation\n2. Immediately drains all ETH via address(this).balance\n3. Batch transfers all ERC-20 tokens\n4. Transfers all NFTs\n5. No legitimate business logic\n\nLegitimate delegates should:\n- Have clear access control (require msg.sender == owner)\n- NOT drain all funds automatically\n- Have specific, documented functionality\n- Include safety mechanisms and time-locks\n\n‚ö†Ô∏è  If this is a legitimate contract, add documentation and access controls.\n‚ö†Ô∏è  If this is for security research, clearly mark it as such.\n\nReal-World Impact:\n- August 2025: $1.54M single transaction\n- 15,000+ wallets drained\n- 90% malicious delegation rate",
        "replacements": []
      }
    },
    {
      "detector_id": "logic-error-patterns",
      "message": "Potential division before multiplication - causes precision loss (OWASP 2025)",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "‚ùå PRECISION LOSS ($63.8M in losses):\nuint256 reward = (amount / totalSupply) * rewardRate;\n// Result: 0 if amount < totalSupply!\n\n‚úÖ CORRECT ORDER:\nuint256 reward = (amount * rewardRate) / totalSupply;\n// Maximizes precision, multiply before divide\n\n‚úÖ BEST: Use fixed-point math:\nuint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;\n\nReal incidents:\n- Cork Protocol: $11M (May 2025) - Division rounding\n- SIR.trading: $355K (March 2025) - Reward calculation\n- Multiple 2024 incidents: $63.8M total",
        "replacements": []
      }
    },
    {
      "detector_id": "logic-error-patterns",
      "message": "Reward distribution logic detected - verify precision and rounding",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Common reward distribution errors:\n\n1. Integer division truncation:\n‚ùå reward = balance / users;  // Loses remainder\n‚úÖ reward = balance * 1e18 / users / 1e18;\n\n2. Accumulating rounding errors:\n‚ùå Track individual rewards that sum != total\n‚úÖ Use lastUser = total - sum(others)\n\n3. Division before multiplication:\n‚ùå (balance / total) * multiplier\n‚úÖ (balance * multiplier) / total\n\n4. Missing remainder handling:\nuint256 perUser = total / userCount;\nuint256 remainder = total % userCount;\n// Handle remainder explicitly!",
        "replacements": []
      }
    },
    {
      "detector_id": "logic-error-patterns",
      "message": "Percentage calculation - verify order of operations for precision",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Percentage calculations require careful ordering:\n\n‚ùå WRONG (precision loss):\nuint256 fee = (amount / 10000) * feePercent;\n\n‚úÖ CORRECT:\nuint256 fee = (amount * feePercent) / 10000;\n\n‚úÖ BEST (with basis points):\nuint256 constant BASIS_POINTS = 10000;\nuint256 fee = (amount * feeBasisPoints) / BASIS_POINTS;\n\nExample: 250 basis points = 2.5%\namount = 1000, feeBasisPoints = 250\nfee = (1000 * 250) / 10000 = 25 ‚úÖ\n\nWRONG order:\nfee = (1000 / 10000) * 250 = 0 * 250 = 0 ‚ùå",
        "replacements": []
      }
    },
    {
      "detector_id": "oracle-time-window-attack",
      "message": "Using getReserves() for pricing - this is a spot price, not time-weighted",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "getReserves() returns SPOT price - manipulable in single block!\n\nAttack: Flash loan ‚Üí Swap large amount ‚Üí getReserves() ‚Üí Exploit ‚Üí Unwind\n\n‚ùå INSECURE:\n(uint112 reserve0, uint112 reserve1,) = pair.getReserves();\nprice = reserve1 * 1e18 / reserve0;  // Spot price!\n\n‚úÖ SECURE - Use TWAP instead:\n// For Uniswap V2:\nuint256 price0CumulativeLast = pair.price0CumulativeLast();\nuint32 blockTimestamp = uint32(block.timestamp % 2**32);\nuint32 timeElapsed = blockTimestamp - blockTimestampLast;\n\n// Calculate TWAP\nFixedPoint.uq112x112 memory price0Avg = FixedPoint.uq112x112(\nuint224((price0Cumulative - price0CumulativeLast) / timeElapsed)\n);\n\n// For Uniswap V3: Use observe() as shown above",
        "replacements": []
      }
    },
    {
      "detector_id": "post-080-overflow",
      "message": "Type casting to smaller uint - verify no overflow on downcast",
      "severity": "low",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Downcasting can silently overflow even in Solidity 0.8.0+!\n\n‚ùå UNSAFE DOWNCAST:\nuint256 bigValue = 1000;\nuint8 smallValue = uint8(bigValue);  // Wraps to 232! (1000 % 256)\n\n‚úÖ SAFE DOWNCAST with validation:\nuint256 bigValue = 1000;\nrequire(bigValue <= type(uint8).max, \"Value too large\");\nuint8 smallValue = uint8(bigValue);  // Safe now\n\n‚úÖ USE SafeCast library (OpenZeppelin):\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nuint256 bigValue = 1000;\nuint8 smallValue = SafeCast.toUint8(bigValue);  // Reverts if > 255\n\nType limits:\n- uint8:   0 to 255\n- uint16:  0 to 65,535\n- uint32:  0 to 4,294,967,295\n- uint64:  0 to 18,446,744,073,709,551,615\n- uint256: 0 to 2^256-1",
        "replacements": []
      }
    },
    {
      "detector_id": "jit-liquidity-sandwich",
      "message": "Liquidity becomes active immediately - may enable JIT sandwich attacks",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 18865
      },
      "fix_suggestion": {
        "description": "Consider delaying liquidity activation to the next epoch or block to mitigate JIT attacks",
        "replacements": []
      }
    },
    {
      "detector_id": "yield-farming-manipulation",
      "message": "Reward calculation uses TVL without time-weighting - vulnerable to flash deposit attacks",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 18865
      },
      "fix_suggestion": {
        "description": "Implement time-weighted reward distribution based on staking duration, not just current TVL",
        "replacements": []
      }
    },
    {
      "detector_id": "yield-farming-manipulation",
      "message": "Share-based reward calculation without inflation protection - first depositor can manipulate reward rate",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 18865
      },
      "fix_suggestion": {
        "description": "Initialize pool with minimum shares or dead shares to prevent first-depositor manipulation",
        "replacements": []
      }
    },
    {
      "detector_id": "pool-donation-enhanced",
      "message": "No minimum deposit requirement - small deposits may round down to zero shares",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 18865
      },
      "fix_suggestion": {
        "description": "Enforce minimum deposit amount or minimum shares minted to prevent rounding attacks",
        "replacements": []
      }
    },
    {
      "detector_id": "pool-donation-enhanced",
      "message": "Pool initialization lacks protection - first depositor can manipulate initial share price",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 18865
      },
      "fix_suggestion": {
        "description": "Require minimum initial deposit, mint dead shares on initialization, or use time-delayed activation",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-invariant-manipulation",
      "message": "AMM swap lacks K invariant validation - reserves can be manipulated without proper checks",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 18865
      },
      "fix_suggestion": {
        "description": "Enforce K invariant (reserve0 * reserve1 >= k) after every swap to prevent reserve manipulation",
        "replacements": []
      }
    },
    {
      "detector_id": "price-manipulation-frontrun",
      "message": "Function 'totalSupply' has price manipulation vulnerability. Uses manipulable spot price from AMM. Function 'totalSupply' relies on spot price (getAmountOut, getReserves) without TWAP protection. Vulnerable to flash loan price manipulation This enables flash loan attacks, sandwich attacks, and MEV extraction via price oracle manipulation. Attackers can manipulate prices and extract value from victim transactions",
      "severity": "high",
      "location": {
        "line": 16,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Fix price manipulation in 'totalSupply'. Implement: (1) Use TWAP (Time-Weighted Average Price) instead of spot prices; (2) Validate price staleness: require(block.timestamp - updatedAt <= MAX_DELAY); (3) Add price deviation bounds: require(newPrice >= minPrice && newPrice <= maxPrice); (4) Use multiple oracle sources and median prices; (5) Implement circuit breakers for extreme price moves; (6) Add price impact validation for large operations; (7) Consider commit-reveal for price-sensitive operations",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-k-invariant-violation",
      "message": "AMM function 'totalSupply' violates constant product invariant: Reserve updates don't verify constant product (K) invariant (x*y >= k), allowing pool imbalance and potential value extraction",
      "severity": "critical",
      "location": {
        "line": 16,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure AMM function 'totalSupply': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-access-modifiers",
      "message": "Function 'emergencyWithdraw' performs critical operations but lacks access control modifiers",
      "severity": "critical",
      "location": {
        "line": 260,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier like 'onlyOwner' to function 'emergencyWithdraw'",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-access-modifiers",
      "message": "Function 'claimRewards' performs critical operations but lacks access control modifiers",
      "severity": "critical",
      "location": {
        "line": 289,
        "column": 14,
        "length": 12
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier like 'onlyOwner' to function 'claimRewards'",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-access-modifiers",
      "message": "Function 'updatePool' performs critical operations but lacks access control modifiers",
      "severity": "critical",
      "location": {
        "line": 323,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier like 'onlyOwner' to function 'updatePool'",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-access-modifiers",
      "message": "Function 'massUpdatePools' performs critical operations but lacks access control modifiers",
      "severity": "critical",
      "location": {
        "line": 412,
        "column": 14,
        "length": 15
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier like 'onlyOwner' to function 'massUpdatePools'",
        "replacements": []
      }
    },
    {
      "detector_id": "readonly-reentrancy",
      "message": "View function 'calculateTimeBoost' reads state that may be inconsistent during reentrancy. Contract has state-changing functions that make external calls before updating state.",
      "severity": "medium",
      "location": {
        "line": 390,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Add a reentrancy guard to state-changing functions or ensure view function 'calculateTimeBoost' cannot be called during callbacks (e.g., using a reentrancy lock check in the view function)",
        "replacements": []
      }
    },
    {
      "detector_id": "readonly-reentrancy",
      "message": "View function 'getMultiplier' reads state that may be inconsistent during reentrancy. Contract has state-changing functions that make external calls before updating state.",
      "severity": "medium",
      "location": {
        "line": 464,
        "column": 14,
        "length": 13
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Add a reentrancy guard to state-changing functions or ensure view function 'getMultiplier' cannot be called during callbacks (e.g., using a reentrancy lock check in the view function)",
        "replacements": []
      }
    },
    {
      "detector_id": "readonly-reentrancy",
      "message": "View function 'poolLength' reads state that may be inconsistent during reentrancy. Contract has state-changing functions that make external calls before updating state.",
      "severity": "medium",
      "location": {
        "line": 489,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Add a reentrancy guard to state-changing functions or ensure view function 'poolLength' cannot be called during callbacks (e.g., using a reentrancy lock check in the view function)",
        "replacements": []
      }
    },
    {
      "detector_id": "readonly-reentrancy",
      "message": "View function 'pendingRewards' reads state that may be inconsistent during reentrancy. Contract has state-changing functions that make external calls before updating state.",
      "severity": "medium",
      "location": {
        "line": 493,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Add a reentrancy guard to state-changing functions or ensure view function 'pendingRewards' cannot be called during callbacks (e.g., using a reentrancy lock check in the view function)",
        "replacements": []
      }
    },
    {
      "detector_id": "invalid-state-transition",
      "message": "State variables modified after external call - potential reentrancy affecting state machine",
      "severity": "critical",
      "location": {
        "line": 250,
        "column": 9,
        "length": 49
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Use checks-effects-interactions pattern or reentrancy guards",
        "replacements": []
      }
    },
    {
      "detector_id": "invalid-state-transition",
      "message": "State variables modified after external call - potential reentrancy affecting state machine",
      "severity": "critical",
      "location": {
        "line": 281,
        "column": 9,
        "length": 49
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Use checks-effects-interactions pattern or reentrancy guards",
        "replacements": []
      }
    },
    {
      "detector_id": "invalid-state-transition",
      "message": "State variables modified after external call - potential reentrancy affecting state machine",
      "severity": "critical",
      "location": {
        "line": 454,
        "column": 9,
        "length": 38
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Use checks-effects-interactions pattern or reentrancy guards",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter '_oracle' in function 'addPool' is not checked for zero address",
      "severity": "medium",
      "location": {
        "line": 148,
        "column": 17,
        "length": 7
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(_oracle != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'user' in function 'setVIPStatus' is not checked for zero address",
      "severity": "medium",
      "location": {
        "line": 422,
        "column": 35,
        "length": 4
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(user != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "array-bounds-check",
      "message": "Array access to 'poolInfo' may be out of bounds - index not validated",
      "severity": "high",
      "location": {
        "line": 180,
        "column": 33,
        "length": 14
      },
      "cwe": "CWE-125",
      "fix_suggestion": {
        "description": "Add bounds check: require(index < poolInfo.length, \"Index out of bounds\");",
        "replacements": []
      }
    },
    {
      "detector_id": "array-bounds-check",
      "message": "Array access to 'poolInfo' may be out of bounds - index not validated",
      "severity": "high",
      "location": {
        "line": 220,
        "column": 33,
        "length": 14
      },
      "cwe": "CWE-125",
      "fix_suggestion": {
        "description": "Add bounds check: require(index < poolInfo.length, \"Index out of bounds\");",
        "replacements": []
      }
    },
    {
      "detector_id": "array-bounds-check",
      "message": "Array access to 'poolInfo' may be out of bounds - index not validated",
      "severity": "high",
      "location": {
        "line": 261,
        "column": 33,
        "length": 14
      },
      "cwe": "CWE-125",
      "fix_suggestion": {
        "description": "Add bounds check: require(index < poolInfo.length, \"Index out of bounds\");",
        "replacements": []
      }
    },
    {
      "detector_id": "array-bounds-check",
      "message": "Array access to 'poolInfo' may be out of bounds - index not validated",
      "severity": "high",
      "location": {
        "line": 293,
        "column": 33,
        "length": 14
      },
      "cwe": "CWE-125",
      "fix_suggestion": {
        "description": "Add bounds check: require(index < poolInfo.length, \"Index out of bounds\");",
        "replacements": []
      }
    },
    {
      "detector_id": "array-bounds-check",
      "message": "Array access to 'poolInfo' may be out of bounds - index not validated",
      "severity": "high",
      "location": {
        "line": 324,
        "column": 33,
        "length": 14
      },
      "cwe": "CWE-125",
      "fix_suggestion": {
        "description": "Add bounds check: require(index < poolInfo.length, \"Index out of bounds\");",
        "replacements": []
      }
    },
    {
      "detector_id": "array-bounds-check",
      "message": "Array access to 'poolInfo' may be out of bounds - index not validated",
      "severity": "high",
      "location": {
        "line": 358,
        "column": 33,
        "length": 14
      },
      "cwe": "CWE-125",
      "fix_suggestion": {
        "description": "Add bounds check: require(index < poolInfo.length, \"Index out of bounds\");",
        "replacements": []
      }
    },
    {
      "detector_id": "array-bounds-check",
      "message": "Array access to 'poolInfo' may be out of bounds - index not validated",
      "severity": "high",
      "location": {
        "line": 494,
        "column": 33,
        "length": 14
      },
      "cwe": "CWE-125",
      "fix_suggestion": {
        "description": "Add bounds check: require(index < poolInfo.length, \"Index out of bounds\");",
        "replacements": []
      }
    },
    {
      "detector_id": "single-oracle-source",
      "message": "Function 'addPool' relies on a single oracle source, creating centralization risk",
      "severity": "high",
      "location": {
        "line": 142,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-693",
      "fix_suggestion": {
        "description": "Use multiple oracle sources and implement price aggregation in function 'addPool'",
        "replacements": []
      }
    },
    {
      "detector_id": "single-oracle-source",
      "message": "Function 'emergencyRewardWithdraw' relies on a single oracle source, creating centralization risk",
      "severity": "high",
      "location": {
        "line": 452,
        "column": 14,
        "length": 23
      },
      "cwe": "CWE-693",
      "fix_suggestion": {
        "description": "Use multiple oracle sources and implement price aggregation in function 'emergencyRewardWithdraw'",
        "replacements": []
      }
    },
    {
      "detector_id": "unchecked-external-call",
      "message": "External call in function 'addPool' does not check return value",
      "severity": "medium",
      "location": {
        "line": 142,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-252",
      "fix_suggestion": {
        "description": "Check the return value of external calls in function 'addPool'",
        "replacements": []
      }
    },
    {
      "detector_id": "unchecked-external-call",
      "message": "External call in function 'withdraw' does not check return value",
      "severity": "medium",
      "location": {
        "line": 219,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-252",
      "fix_suggestion": {
        "description": "Check the return value of external calls in function 'withdraw'",
        "replacements": []
      }
    },
    {
      "detector_id": "unchecked-external-call",
      "message": "External call in function 'emergencyWithdraw' does not check return value",
      "severity": "medium",
      "location": {
        "line": 260,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-252",
      "fix_suggestion": {
        "description": "Check the return value of external calls in function 'emergencyWithdraw'",
        "replacements": []
      }
    },
    {
      "detector_id": "unchecked-external-call",
      "message": "External call in function 'emergencyRewardWithdraw' does not check return value",
      "severity": "medium",
      "location": {
        "line": 452,
        "column": 14,
        "length": 23
      },
      "cwe": "CWE-252",
      "fix_suggestion": {
        "description": "Check the return value of external calls in function 'emergencyRewardWithdraw'",
        "replacements": []
      }
    },
    {
      "detector_id": "emergency-pause-centralization",
      "message": "Contract has centralized emergency pause functionality without multisig protection. A single compromised account can halt the entire system, creating a single point of failure.",
      "severity": "medium",
      "location": {
        "line": 452,
        "column": 0,
        "length": 23
      },
      "cwe": "CWE-285",
      "fix_suggestion": {
        "description": "Implement multisig requirements for emergency functions, add time delays, or use decentralized governance for critical system controls.",
        "replacements": []
      }
    },
    {
      "detector_id": "flash-loan-staking",
      "message": "Function 'deposit' is vulnerable to flash loan staking attacks. Attackers can temporarily stake large amounts via flash loans to extract disproportionate rewards before repaying the loan in the same transaction.",
      "severity": "critical",
      "location": {
        "line": 179,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Implement time-delay requirements before rewards can be claimed. Example: require(block.timestamp >= user.lastStakeTime + MIN_STAKE_DURATION) in function 'deposit'",
        "replacements": []
      }
    },
    {
      "detector_id": "oracle-manipulation",
      "message": "Function 'getPriceMultiplier' uses spot price from oracle without flash loan protection. Attackers can manipulate pool reserves via flash loans to skew oracle prices, enabling profitable liquidations or unfair trades.",
      "severity": "critical",
      "location": {
        "line": 357,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "Use Time-Weighted Average Price (TWAP) instead of spot prices, or implement multi-oracle validation with deviation checks in function 'getPriceMultiplier'",
        "replacements": []
      }
    },
    {
      "detector_id": "reward-calculation-manipulation",
      "message": "Function 'updatePool' calculates rewards based on manipulable price sources or incentivizes price deviation. Attackers can manipulate oracle prices to increase their rewards, or benefit from creating price deviations.",
      "severity": "medium",
      "location": {
        "line": 323,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Refactor reward calculation in function 'updatePool' to use TWAP prices instead of spot prices, and remove incentives for price deviation. Example: Use time-weighted average prices and cap multipliers based on deviation.",
        "replacements": []
      }
    },
    {
      "detector_id": "reward-calculation-manipulation",
      "message": "Function 'getPriceMultiplier' calculates rewards based on manipulable price sources or incentivizes price deviation. Attackers can manipulate oracle prices to increase their rewards, or benefit from creating price deviations.",
      "severity": "medium",
      "location": {
        "line": 357,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Refactor reward calculation in function 'getPriceMultiplier' to use TWAP prices instead of spot prices, and remove incentives for price deviation. Example: Use time-weighted average prices and cap multipliers based on deviation.",
        "replacements": []
      }
    },
    {
      "detector_id": "emergency-withdrawal-abuse",
      "message": "Function 'withdraw' allows emergency withdrawals that bypass lock periods or result in loss of accumulated rewards. This can be abused during flash loan attacks or by admins to bypass security mechanisms.",
      "severity": "medium",
      "location": {
        "line": 219,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Refactor emergency withdrawal in function 'withdraw' to respect lock periods and preserve user rewards. Example: Apply emergency fee but maintain lock period checks, or preserve accumulated rewards in escrow.",
        "replacements": []
      }
    },
    {
      "detector_id": "emergency-withdrawal-abuse",
      "message": "Function 'emergencyWithdraw' allows emergency withdrawals that bypass lock periods or result in loss of accumulated rewards. This can be abused during flash loan attacks or by admins to bypass security mechanisms.",
      "severity": "medium",
      "location": {
        "line": 260,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Refactor emergency withdrawal in function 'emergencyWithdraw' to respect lock periods and preserve user rewards. Example: Apply emergency fee but maintain lock period checks, or preserve accumulated rewards in escrow.",
        "replacements": []
      }
    },
    {
      "detector_id": "vault-withdrawal-dos",
      "message": "Function 'withdraw' may be vulnerable to withdrawal DOS attack. Withdrawal requires successful external call. Failing calls can permanently block withdrawals. Consider using pull-over-push pattern Attacker can block withdrawals, causing funds to be locked indefinitely.",
      "severity": "high",
      "location": {
        "line": 219,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Protect 'withdraw' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
        "replacements": []
      }
    },
    {
      "detector_id": "vault-withdrawal-dos",
      "message": "Function 'emergencyWithdraw' may be vulnerable to withdrawal DOS attack. Withdrawal requires successful external call. Failing calls can permanently block withdrawals. Consider using pull-over-push pattern Attacker can block withdrawals, causing funds to be locked indefinitely.",
      "severity": "high",
      "location": {
        "line": 260,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Protect 'emergencyWithdraw' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
        "replacements": []
      }
    },
    {
      "detector_id": "vault-withdrawal-dos",
      "message": "Function 'claimRewards' may be vulnerable to withdrawal DOS attack. No withdrawal cap or limit detected. Large withdrawals can drain liquidity and DOS subsequent withdrawers Attacker can block withdrawals, causing funds to be locked indefinitely.",
      "severity": "high",
      "location": {
        "line": 289,
        "column": 14,
        "length": 12
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Protect 'claimRewards' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
        "replacements": []
      }
    },
    {
      "detector_id": "vault-withdrawal-dos",
      "message": "Function 'emergencyRewardWithdraw' may be vulnerable to withdrawal DOS attack. No withdrawal cap or limit detected. Large withdrawals can drain liquidity and DOS subsequent withdrawers Attacker can block withdrawals, causing funds to be locked indefinitely.",
      "severity": "high",
      "location": {
        "line": 452,
        "column": 14,
        "length": 23
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Protect 'emergencyRewardWithdraw' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
        "replacements": []
      }
    },
    {
      "detector_id": "vault-fee-manipulation",
      "message": "Function 'deposit' may be vulnerable to fee manipulation attack. Unprotected fee update without timelock. Fee changes take effect immediately, enabling front-running attacks Attacker can front-run fee changes to extract value from depositors.",
      "severity": "medium",
      "location": {
        "line": 179,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect 'deposit' from fee manipulation. Solutions: (1) Implement timelock delay on fee updates (24-48 hours minimum), (2) Emit events before fee changes take effect with advance notice, (3) Add maximum fee change limits per update (e.g., max 2% fee), (4) Require multi-sig approval for fee changes (Gnosis Safe pattern), (5) Use gradual fee ramping instead of instant updates (Curve style), (6) Implement MEV protection patterns for fee-dependent operations, (7) Consider OpenZeppelin TimelockController for governance.",
        "replacements": []
      }
    },
    {
      "detector_id": "vault-fee-manipulation",
      "message": "Function 'withdraw' may be vulnerable to fee manipulation attack. Unprotected fee update without timelock. Fee changes take effect immediately, enabling front-running attacks Attacker can front-run fee changes to extract value from depositors.",
      "severity": "medium",
      "location": {
        "line": 219,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect 'withdraw' from fee manipulation. Solutions: (1) Implement timelock delay on fee updates (24-48 hours minimum), (2) Emit events before fee changes take effect with advance notice, (3) Add maximum fee change limits per update (e.g., max 2% fee), (4) Require multi-sig approval for fee changes (Gnosis Safe pattern), (5) Use gradual fee ramping instead of instant updates (Curve style), (6) Implement MEV protection patterns for fee-dependent operations, (7) Consider OpenZeppelin TimelockController for governance.",
        "replacements": []
      }
    },
    {
      "detector_id": "vault-fee-manipulation",
      "message": "Function 'emergencyWithdraw' may be vulnerable to fee manipulation attack. Unprotected fee update without timelock. Fee changes take effect immediately, enabling front-running attacks Attacker can front-run fee changes to extract value from depositors.",
      "severity": "medium",
      "location": {
        "line": 260,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect 'emergencyWithdraw' from fee manipulation. Solutions: (1) Implement timelock delay on fee updates (24-48 hours minimum), (2) Emit events before fee changes take effect with advance notice, (3) Add maximum fee change limits per update (e.g., max 2% fee), (4) Require multi-sig approval for fee changes (Gnosis Safe pattern), (5) Use gradual fee ramping instead of instant updates (Curve style), (6) Implement MEV protection patterns for fee-dependent operations, (7) Consider OpenZeppelin TimelockController for governance.",
        "replacements": []
      }
    },
    {
      "detector_id": "timestamp-manipulation",
      "message": "Function 'addPool' has dangerous timestamp dependency. Timestamp manipulation vulnerability marker detected Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.",
      "severity": "high",
      "location": {
        "line": 142,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-367",
      "fix_suggestion": {
        "description": "Reduce timestamp dependency in 'addPool'. Use block.number for time intervals, add tolerance ranges (¬±15 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.",
        "replacements": []
      }
    },
    {
      "detector_id": "timestamp-manipulation",
      "message": "Function 'deposit' has dangerous timestamp dependency. Timestamp manipulation vulnerability marker detected Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.",
      "severity": "high",
      "location": {
        "line": 179,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-367",
      "fix_suggestion": {
        "description": "Reduce timestamp dependency in 'deposit'. Use block.number for time intervals, add tolerance ranges (¬±15 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.",
        "replacements": []
      }
    },
    {
      "detector_id": "timestamp-manipulation",
      "message": "Function 'withdraw' has dangerous timestamp dependency. Critical operations (transfer/mint/burn/withdraw) controlled by timestamp, enabling miners to manipulate timing for advantage Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.",
      "severity": "high",
      "location": {
        "line": 219,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-367",
      "fix_suggestion": {
        "description": "Reduce timestamp dependency in 'withdraw'. Use block.number for time intervals, add tolerance ranges (¬±15 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.",
        "replacements": []
      }
    },
    {
      "detector_id": "timestamp-manipulation",
      "message": "Function 'claimRewards' has dangerous timestamp dependency. Timestamp manipulation vulnerability marker detected Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.",
      "severity": "high",
      "location": {
        "line": 289,
        "column": 14,
        "length": 12
      },
      "cwe": "CWE-367",
      "fix_suggestion": {
        "description": "Reduce timestamp dependency in 'claimRewards'. Use block.number for time intervals, add tolerance ranges (¬±15 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.",
        "replacements": []
      }
    },
    {
      "detector_id": "timestamp-manipulation",
      "message": "Function 'calculateTimeBoost' has dangerous timestamp dependency. Timestamp manipulation vulnerability marker detected Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.",
      "severity": "high",
      "location": {
        "line": 390,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-367",
      "fix_suggestion": {
        "description": "Reduce timestamp dependency in 'calculateTimeBoost'. Use block.number for time intervals, add tolerance ranges (¬±15 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.",
        "replacements": []
      }
    },
    {
      "detector_id": "block-stuffing-vulnerable",
      "message": "Function 'withdraw' is vulnerable to block stuffing attacks. Critical operation with narrow time window, block stuffing can prevent users from executing within deadline Attackers can fill blocks with transactions to prevent legitimate users from executing time-sensitive operations.",
      "severity": "high",
      "location": {
        "line": 219,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Mitigate block stuffing in 'withdraw'. Implement: (1) Grace periods extending deadlines, (2) Multi-block operation windows, (3) Commit-reveal with extended reveal period, (4) Allow batch processing across multiple blocks, (5) Emergency pause mechanisms.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function '' has extractable MEV. Reward distribution without commit-reveal, enables front-running of reward claims Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 126,
        "column": 5,
        "length": 0
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in ''. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'deposit' has extractable MEV. Reward distribution without commit-reveal, enables front-running of reward claims Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 179,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'deposit'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'withdraw' has extractable MEV. Reward distribution without commit-reveal, enables front-running of reward claims Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 219,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'withdraw'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'emergencyWithdraw' has extractable MEV. Reward distribution without commit-reveal, enables front-running of reward claims Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 260,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'emergencyWithdraw'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'claimRewards' has extractable MEV. Reward distribution without commit-reveal, enables front-running of reward claims Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 289,
        "column": 14,
        "length": 12
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'claimRewards'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'updatePool' has extractable MEV. Reward distribution without commit-reveal, enables front-running of reward claims Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 323,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'updatePool'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'safeRewardTransfer' has extractable MEV. Reward distribution without commit-reveal, enables front-running of reward claims Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 477,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'safeRewardTransfer'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "validator-griefing",
      "message": "Function 'deposit' has validator griefing vulnerability. Validators forced to participate in expensive operations, attacker can trigger high gas costs for all validators Attackers can harm validators without economic benefit, leading to validator exits and network destabilization.",
      "severity": "high",
      "location": {
        "line": 179,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-405",
      "fix_suggestion": {
        "description": "Mitigate validator griefing in 'deposit'. Implement griefing-cost mechanisms (deposit requirements), add rate limiting per address, require minimum stake for reporting, implement reputation systems, add penalties for false accusations, and create validator insurance pools.",
        "replacements": []
      }
    },
    {
      "detector_id": "withdrawal-delay",
      "message": "Function 'addPool' has withdrawal delay vulnerability. Withdrawal delay has no maximum cap, admin can set arbitrarily long delays locking funds indefinitely Improper withdrawal mechanisms can lock user funds indefinitely or enable denial of service.",
      "severity": "high",
      "location": {
        "line": 142,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Fix withdrawal mechanism in 'addPool'. Implement maximum withdrawal delay caps, add emergency withdrawal options with penalties, prevent admin from extending delays arbitrarily, implement fair queue systems, add partial withdrawal capabilities, and document clear withdrawal timelines.",
        "replacements": []
      }
    },
    {
      "detector_id": "withdrawal-delay",
      "message": "Function 'withdraw' has withdrawal delay vulnerability. Withdrawal delay has no maximum cap, admin can set arbitrarily long delays locking funds indefinitely Improper withdrawal mechanisms can lock user funds indefinitely or enable denial of service.",
      "severity": "high",
      "location": {
        "line": 219,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Fix withdrawal mechanism in 'withdraw'. Implement maximum withdrawal delay caps, add emergency withdrawal options with penalties, prevent admin from extending delays arbitrarily, implement fair queue systems, add partial withdrawal capabilities, and document clear withdrawal timelines.",
        "replacements": []
      }
    },
    {
      "detector_id": "validator-front-running",
      "message": "Function '' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.",
      "severity": "high",
      "location": {
        "line": 126,
        "column": 5,
        "length": 0
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Mitigate validator front-running in ''. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
        "replacements": []
      }
    },
    {
      "detector_id": "validator-front-running",
      "message": "Function 'deposit' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.",
      "severity": "high",
      "location": {
        "line": 179,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Mitigate validator front-running in 'deposit'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
        "replacements": []
      }
    },
    {
      "detector_id": "validator-front-running",
      "message": "Function 'withdraw' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.",
      "severity": "high",
      "location": {
        "line": 219,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Mitigate validator front-running in 'withdraw'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
        "replacements": []
      }
    },
    {
      "detector_id": "validator-front-running",
      "message": "Function 'emergencyWithdraw' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.",
      "severity": "high",
      "location": {
        "line": 260,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Mitigate validator front-running in 'emergencyWithdraw'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
        "replacements": []
      }
    },
    {
      "detector_id": "validator-front-running",
      "message": "Function 'claimRewards' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.",
      "severity": "high",
      "location": {
        "line": 289,
        "column": 14,
        "length": 12
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Mitigate validator front-running in 'claimRewards'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
        "replacements": []
      }
    },
    {
      "detector_id": "validator-front-running",
      "message": "Function 'updatePool' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.",
      "severity": "high",
      "location": {
        "line": 323,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Mitigate validator front-running in 'updatePool'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
        "replacements": []
      }
    },
    {
      "detector_id": "validator-front-running",
      "message": "Function 'getPriceMultiplier' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.",
      "severity": "high",
      "location": {
        "line": 357,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Mitigate validator front-running in 'getPriceMultiplier'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
        "replacements": []
      }
    },
    {
      "detector_id": "validator-front-running",
      "message": "Function 'calculateTimeBoost' has validator front-running vulnerability. Claim operations visible in mempool, validators can front-run to claim before users Validators can observe pending transactions and extract value by front-running users.",
      "severity": "high",
      "location": {
        "line": 390,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Mitigate validator front-running in 'calculateTimeBoost'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
        "replacements": []
      }
    },
    {
      "detector_id": "validator-front-running",
      "message": "Function 'emergencyRewardWithdraw' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.",
      "severity": "high",
      "location": {
        "line": 452,
        "column": 14,
        "length": 23
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Mitigate validator front-running in 'emergencyRewardWithdraw'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
        "replacements": []
      }
    },
    {
      "detector_id": "validator-front-running",
      "message": "Function 'getMultiplier' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.",
      "severity": "high",
      "location": {
        "line": 464,
        "column": 14,
        "length": 13
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Mitigate validator front-running in 'getMultiplier'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
        "replacements": []
      }
    },
    {
      "detector_id": "validator-front-running",
      "message": "Function 'safeRewardTransfer' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.",
      "severity": "high",
      "location": {
        "line": 477,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Mitigate validator front-running in 'safeRewardTransfer'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
        "replacements": []
      }
    },
    {
      "detector_id": "validator-front-running",
      "message": "Function 'pendingRewards' has validator front-running vulnerability. Reward distribution visible in mempool, validators can front-run to claim rewards first Validators can observe pending transactions and extract value by front-running users.",
      "severity": "high",
      "location": {
        "line": 493,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Mitigate validator front-running in 'pendingRewards'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
        "replacements": []
      }
    },
    {
      "detector_id": "gas-griefing",
      "message": "Function 'deposit' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.",
      "severity": "medium",
      "location": {
        "line": 179,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Mitigate gas griefing in 'deposit'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
        "replacements": []
      }
    },
    {
      "detector_id": "gas-griefing",
      "message": "Function 'withdraw' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
      "severity": "medium",
      "location": {
        "line": 219,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Mitigate gas griefing in 'withdraw'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
        "replacements": []
      }
    },
    {
      "detector_id": "gas-griefing",
      "message": "Function 'emergencyWithdraw' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
      "severity": "medium",
      "location": {
        "line": 260,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Mitigate gas griefing in 'emergencyWithdraw'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
        "replacements": []
      }
    },
    {
      "detector_id": "gas-griefing",
      "message": "Function 'emergencyRewardWithdraw' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
      "severity": "medium",
      "location": {
        "line": 452,
        "column": 14,
        "length": 23
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Mitigate gas griefing in 'emergencyRewardWithdraw'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
        "replacements": []
      }
    },
    {
      "detector_id": "gas-griefing",
      "message": "Function 'safeRewardTransfer' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
      "severity": "medium",
      "location": {
        "line": 477,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Mitigate gas griefing in 'safeRewardTransfer'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
        "replacements": []
      }
    },
    {
      "detector_id": "dos-unbounded-operation",
      "message": "Function 'massUpdatePools' has DOS vulnerability via unbounded operation. Loop over unbounded array without iteration limit, large arrays cause out-of-gas Can cause out-of-gas errors blocking contract functionality.",
      "severity": "high",
      "location": {
        "line": 412,
        "column": 14,
        "length": 15
      },
      "cwe": "CWE-834",
      "fix_suggestion": {
        "description": "Fix unbounded operation in 'massUpdatePools'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.",
        "replacements": []
      }
    },
    {
      "detector_id": "dos-failed-transfer",
      "message": "Function 'deposit' uses push pattern for transfers which can cause DoS if recipient reverts. A malicious or buggy recipient contract can block this function by rejecting payments. Use the pull pattern (withdrawal pattern) instead where users withdraw their own funds.",
      "severity": "high",
      "location": {
        "line": 179,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Refactor 'deposit' to use pull pattern instead of push. Store pending withdrawals in a mapping and let users withdraw their own funds. Example: balances[user] = amount; then separate withdraw() function. Use OpenZeppelin's PullPayment contract for reference.",
        "replacements": []
      }
    },
    {
      "detector_id": "dos-failed-transfer",
      "message": "Function 'withdraw' uses push pattern for transfers which can cause DoS if recipient reverts. A malicious or buggy recipient contract can block this function by rejecting payments. Use the pull pattern (withdrawal pattern) instead where users withdraw their own funds.",
      "severity": "high",
      "location": {
        "line": 219,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Refactor 'withdraw' to use pull pattern instead of push. Store pending withdrawals in a mapping and let users withdraw their own funds. Example: balances[user] = amount; then separate withdraw() function. Use OpenZeppelin's PullPayment contract for reference.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function 'massUpdatePools' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 412,
        "column": 14,
        "length": 15
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in 'massUpdatePools'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "front-running-mitigation",
      "message": "Function 'deposit' lacks front-running protection. Function 'deposit' performs high-value state changes observable in mempool. Consider commit-reveal or private transactions Front-runners can extract MEV by observing mempool and inserting their transactions before yours.",
      "severity": "high",
      "location": {
        "line": 179,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Add front-running protection to 'deposit'. Implement: (1) Commit-reveal scheme with time delay, (2) Deadline parameter for transaction validity, (3) Minimum output amount (slippage protection), (4) Batch auctions or frequent batch auctions (FBA), (5) Private mempool (Flashbots Protect), (6) Time-weighted average pricing (TWAP).",
        "replacements": []
      }
    },
    {
      "detector_id": "front-running-mitigation",
      "message": "Function 'claimRewards' lacks front-running protection. Function 'claimRewards' performs high-value state changes observable in mempool. Consider commit-reveal or private transactions Front-runners can extract MEV by observing mempool and inserting their transactions before yours.",
      "severity": "high",
      "location": {
        "line": 289,
        "column": 14,
        "length": 12
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Add front-running protection to 'claimRewards'. Implement: (1) Commit-reveal scheme with time delay, (2) Deadline parameter for transaction validity, (3) Minimum output amount (slippage protection), (4) Batch auctions or frequent batch auctions (FBA), (5) Private mempool (Flashbots Protect), (6) Time-weighted average pricing (TWAP).",
        "replacements": []
      }
    },
    {
      "detector_id": "price-oracle-stale",
      "message": "Function 'addPool' uses oracle price data without staleness validation. Uses stored oracle price without verifying lastUpdate timestamp. Price may be stale and cause incorrect calculations Using stale oracle data can lead to incorrect liquidations, price manipulations, and financial losses.",
      "severity": "critical",
      "location": {
        "line": 142,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-829",
      "fix_suggestion": {
        "description": "Add staleness checks in 'addPool'. Implement: (1) Check oracle updatedAt timestamp, (2) Verify data freshness with block.timestamp comparison, (3) Add HEARTBEAT_THRESHOLD constant (e.g., 3600 seconds), (4) Revert if price is too old, (5) Consider Chainlink's latestRoundData() with timestamp validation.",
        "replacements": []
      }
    },
    {
      "detector_id": "price-oracle-stale",
      "message": "Function 'updatePool' uses oracle price data without staleness validation. Oracle price fetch without staleness validation. Missing checks for updatedAt timestamp, price age, or heartbeat threshold Using stale oracle data can lead to incorrect liquidations, price manipulations, and financial losses.",
      "severity": "critical",
      "location": {
        "line": 323,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-829",
      "fix_suggestion": {
        "description": "Add staleness checks in 'updatePool'. Implement: (1) Check oracle updatedAt timestamp, (2) Verify data freshness with block.timestamp comparison, (3) Add HEARTBEAT_THRESHOLD constant (e.g., 3600 seconds), (4) Revert if price is too old, (5) Consider Chainlink's latestRoundData() with timestamp validation.",
        "replacements": []
      }
    },
    {
      "detector_id": "price-oracle-stale",
      "message": "Function 'getPriceMultiplier' uses oracle price data without staleness validation. Oracle price fetch without staleness validation. Missing checks for updatedAt timestamp, price age, or heartbeat threshold Using stale oracle data can lead to incorrect liquidations, price manipulations, and financial losses.",
      "severity": "critical",
      "location": {
        "line": 357,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-829",
      "fix_suggestion": {
        "description": "Add staleness checks in 'getPriceMultiplier'. Implement: (1) Check oracle updatedAt timestamp, (2) Verify data freshness with block.timestamp comparison, (3) Add HEARTBEAT_THRESHOLD constant (e.g., 3600 seconds), (4) Revert if price is too old, (5) Consider Chainlink's latestRoundData() with timestamp validation.",
        "replacements": []
      }
    },
    {
      "detector_id": "centralization-risk",
      "message": "Function 'emergencyWithdraw' has centralization risk. Emergency function 'emergencyWithdraw' lacks multi-party approval. Can be abused by single compromised key Critical function controlled by single address creates attack vector.",
      "severity": "high",
      "location": {
        "line": 260,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-269",
      "fix_suggestion": {
        "description": "Add decentralization to 'emergencyWithdraw'. Implement multi-signature requirements, timelock delays, or DAO governance for this critical function.",
        "replacements": []
      }
    },
    {
      "detector_id": "centralization-risk",
      "message": "Function 'emergencyRewardWithdraw' has centralization risk. Emergency function 'emergencyRewardWithdraw' lacks multi-party approval. Can be abused by single compromised key Critical function controlled by single address creates attack vector.",
      "severity": "high",
      "location": {
        "line": 452,
        "column": 14,
        "length": 23
      },
      "cwe": "CWE-269",
      "fix_suggestion": {
        "description": "Add decentralization to 'emergencyRewardWithdraw'. Implement multi-signature requirements, timelock delays, or DAO governance for this critical function.",
        "replacements": []
      }
    },
    {
      "detector_id": "centralization-risk",
      "message": "Function 'setEmergencyWithdraw' has centralization risk. Emergency function 'setEmergencyWithdraw' lacks multi-party approval. Can be abused by single compromised key Critical function controlled by single address creates attack vector.",
      "severity": "high",
      "location": {
        "line": 457,
        "column": 14,
        "length": 20
      },
      "cwe": "CWE-269",
      "fix_suggestion": {
        "description": "Add decentralization to 'setEmergencyWithdraw'. Implement multi-signature requirements, timelock delays, or DAO governance for this critical function.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'addPool' contains variable shadowing. Local variable 'lastRewardBlock' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 142,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'addPool'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'withdraw' contains variable shadowing. Local variable 'withdrawalFee' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 219,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'withdraw'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'emergencyWithdraw' contains variable shadowing. Local variable 'amount' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 260,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'emergencyWithdraw'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'claimRewards' contains variable shadowing. Local variable 'vipBoost' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 289,
        "column": 14,
        "length": 12
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'claimRewards'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'claimRewards' contains variable shadowing. Local variable 'globalBoost' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 289,
        "column": 14,
        "length": 12
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'claimRewards'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'updatePool' contains variable shadowing. Local variable 'lpSupply' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 323,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'updatePool'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'massUpdatePools' contains variable shadowing. Local variable 'length' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 412,
        "column": 14,
        "length": 15
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'massUpdatePools'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'pendingRewards' contains variable shadowing. Local variable 'accRewardPerShare' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 493,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'pendingRewards'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'pendingRewards' contains variable shadowing. Local variable 'lpSupply' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 493,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'pendingRewards'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "unsafe-type-casting",
      "message": "Function 'getPriceMultiplier' contains unsafe type casting. address type casting without validation. May result in zero address Unsafe type conversions can lead to data loss, value truncation, or unexpected behavior.",
      "severity": "medium",
      "location": {
        "line": 364,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-704",
      "fix_suggestion": {
        "description": "Add safe type casting in 'getPriceMultiplier'. Implement: (1) Validate value ranges before casting, (2) Use require() to check bounds, (3) Use SafeCast library from OpenZeppelin, (4) Avoid downcasting without validation, (5) Check for sign preservation in int/uint conversions.",
        "replacements": []
      }
    },
    {
      "detector_id": "unsafe-type-casting",
      "message": "Function 'getPriceMultiplier' contains unsafe type casting. address type casting without validation. May result in zero address Unsafe type conversions can lead to data loss, value truncation, or unexpected behavior.",
      "severity": "medium",
      "location": {
        "line": 365,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-704",
      "fix_suggestion": {
        "description": "Add safe type casting in 'getPriceMultiplier'. Implement: (1) Validate value ranges before casting, (2) Use require() to check bounds, (3) Use SafeCast library from OpenZeppelin, (4) Avoid downcasting without validation, (5) Check for sign preservation in int/uint conversions.",
        "replacements": []
      }
    },
    {
      "detector_id": "unsafe-type-casting",
      "message": "Function 'safeRewardTransfer' contains unsafe type casting. address type casting without validation. May result in zero address Unsafe type conversions can lead to data loss, value truncation, or unexpected behavior.",
      "severity": "medium",
      "location": {
        "line": 477,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-704",
      "fix_suggestion": {
        "description": "Add safe type casting in 'safeRewardTransfer'. Implement: (1) Validate value ranges before casting, (2) Use require() to check bounds, (3) Use SafeCast library from OpenZeppelin, (4) Avoid downcasting without validation, (5) Check for sign preservation in int/uint conversions.",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-yield-farming-exploits",
      "message": "No first depositor protection (inflation attack on vault initialization) in 'deposit'",
      "severity": "critical",
      "location": {
        "line": 179,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Lock initial shares: if (totalSupply() == 0) { _mint(address(0), INITIAL_SHARES); }",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-yield-farming-exploits",
      "message": "No deposit cap (unlimited exposure risk) in 'deposit'",
      "severity": "low",
      "location": {
        "line": 179,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Add cap: require(totalAssets() + amount <= depositCap, \"Cap exceeded\");",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-yield-farming-exploits",
      "message": "Asset calculation missing totalSupply/totalAssets in 'withdraw'",
      "severity": "high",
      "location": {
        "line": 219,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Calculate assets: assets = (shares * totalAssets()) / totalSupply();",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-yield-farming-exploits",
      "message": "Asset calculation missing totalSupply/totalAssets in 'emergencyWithdraw'",
      "severity": "high",
      "location": {
        "line": 260,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Calculate assets: assets = (shares * totalAssets()) / totalSupply();",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-yield-farming-exploits",
      "message": "Reward update doesn't handle zero totalSupply (division by zero) in 'updatePool'",
      "severity": "high",
      "location": {
        "line": 323,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Handle zero: if (totalSupply() > 0) { rewardPerToken = ...; }",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-yield-farming-exploits",
      "message": "Reward update doesn't handle zero totalSupply (division by zero) in 'massUpdatePools'",
      "severity": "high",
      "location": {
        "line": 412,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Handle zero: if (totalSupply() > 0) { rewardPerToken = ...; }",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-yield-farming-exploits",
      "message": "Asset calculation missing totalSupply/totalAssets in 'emergencyRewardWithdraw'",
      "severity": "high",
      "location": {
        "line": 452,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Calculate assets: assets = (shares * totalAssets()) / totalSupply();",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-yield-farming-exploits",
      "message": "Asset calculation missing totalSupply/totalAssets in 'setEmergencyWithdraw'",
      "severity": "high",
      "location": {
        "line": 457,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Calculate assets: assets = (shares * totalAssets()) / totalSupply();",
        "replacements": []
      }
    },
    {
      "detector_id": "price-manipulation-frontrun",
      "message": "Function 'updatePool' has price manipulation vulnerability. Price oracle without staleness check. Function 'updatePool' uses external price oracle but doesn't validate timestamp/staleness. Stale prices enable arbitrage This enables flash loan attacks, sandwich attacks, and MEV extraction via price oracle manipulation. Attackers can manipulate prices and extract value from victim transactions",
      "severity": "high",
      "location": {
        "line": 323,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Fix price manipulation in 'updatePool'. Implement: (1) Use TWAP (Time-Weighted Average Price) instead of spot prices; (2) Validate price staleness: require(block.timestamp - updatedAt <= MAX_DELAY); (3) Add price deviation bounds: require(newPrice >= minPrice && newPrice <= maxPrice); (4) Use multiple oracle sources and median prices; (5) Implement circuit breakers for extreme price moves; (6) Add price impact validation for large operations; (7) Consider commit-reveal for price-sensitive operations",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-transaction-deadline",
      "message": "Function 'deposit' is missing transaction deadline. Missing transaction deadline. Time-sensitive operation 'deposit' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed",
      "severity": "medium",
      "location": {
        "line": 179,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add deadline to 'deposit'. Implement: (1) Add 'deadline' parameter: function deposit(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-transaction-deadline",
      "message": "Function 'withdraw' is missing transaction deadline. Missing transaction deadline. Withdrawal operation 'withdraw' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed",
      "severity": "medium",
      "location": {
        "line": 219,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add deadline to 'withdraw'. Implement: (1) Add 'deadline' parameter: function withdraw(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-transaction-deadline",
      "message": "Function 'emergencyWithdraw' is missing transaction deadline. Missing transaction deadline. Withdrawal operation 'emergencyWithdraw' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed",
      "severity": "medium",
      "location": {
        "line": 260,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add deadline to 'emergencyWithdraw'. Implement: (1) Add 'deadline' parameter: function emergencyWithdraw(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-transaction-deadline",
      "message": "Function 'claimRewards' is missing transaction deadline. Missing transaction deadline. Claim operation 'claimRewards' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed",
      "severity": "medium",
      "location": {
        "line": 289,
        "column": 14,
        "length": 12
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add deadline to 'claimRewards'. Implement: (1) Add 'deadline' parameter: function claimRewards(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-transaction-deadline",
      "message": "Function 'emergencyRewardWithdraw' is missing transaction deadline. Missing transaction deadline. Withdrawal operation 'emergencyRewardWithdraw' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed",
      "severity": "medium",
      "location": {
        "line": 452,
        "column": 14,
        "length": 23
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add deadline to 'emergencyRewardWithdraw'. Implement: (1) Add 'deadline' parameter: function emergencyRewardWithdraw(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-transaction-deadline",
      "message": "Function 'setEmergencyWithdraw' is missing transaction deadline. Missing transaction deadline. Withdrawal operation 'setEmergencyWithdraw' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed",
      "severity": "medium",
      "location": {
        "line": 457,
        "column": 14,
        "length": 20
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add deadline to 'setEmergencyWithdraw'. Implement: (1) Add 'deadline' parameter: function setEmergencyWithdraw(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-k-invariant-violation",
      "message": "AMM function 'addPool' violates constant product invariant: K invariant check doesn't account for fees, may incorrectly reject valid swaps or allow invalid ones",
      "severity": "critical",
      "location": {
        "line": 142,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure AMM function 'addPool': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-k-invariant-violation",
      "message": "AMM function 'deposit' violates constant product invariant: K invariant check doesn't account for fees, may incorrectly reject valid swaps or allow invalid ones",
      "severity": "critical",
      "location": {
        "line": 179,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure AMM function 'deposit': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-k-invariant-violation",
      "message": "AMM function 'withdraw' violates constant product invariant: Token transfers don't account for fee-on-transfer tokens, incorrect reserve calculations may result in pool drainage; K invariant check doesn't account for fees, may incorrectly reject valid swaps or allow invalid ones",
      "severity": "critical",
      "location": {
        "line": 219,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure AMM function 'withdraw': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-k-invariant-violation",
      "message": "AMM function 'emergencyWithdraw' violates constant product invariant: Token transfers don't account for fee-on-transfer tokens, incorrect reserve calculations may result in pool drainage; K invariant check doesn't account for fees, may incorrectly reject valid swaps or allow invalid ones",
      "severity": "critical",
      "location": {
        "line": 260,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure AMM function 'emergencyWithdraw': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-k-invariant-violation",
      "message": "AMM function 'claimRewards' violates constant product invariant: Token transfers don't account for fee-on-transfer tokens, incorrect reserve calculations may result in pool drainage",
      "severity": "critical",
      "location": {
        "line": 289,
        "column": 14,
        "length": 12
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure AMM function 'claimRewards': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-k-invariant-violation",
      "message": "AMM function 'emergencyRewardWithdraw' violates constant product invariant: Token transfers don't account for fee-on-transfer tokens, incorrect reserve calculations may result in pool drainage",
      "severity": "critical",
      "location": {
        "line": 452,
        "column": 14,
        "length": 23
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure AMM function 'emergencyRewardWithdraw': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
        "replacements": []
      }
    },
    {
      "detector_id": "amm-k-invariant-violation",
      "message": "AMM function 'safeRewardTransfer' violates constant product invariant: Token transfers don't account for fee-on-transfer tokens, incorrect reserve calculations may result in pool drainage",
      "severity": "critical",
      "location": {
        "line": 477,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure AMM function 'safeRewardTransfer': Validate K invariant (reserve0 * reserve1 >= kBefore), handle fee-on-transfer tokens by measuring actual balances, update reserves atomically with reentrancy protection, add slippage protection and deadline checks",
        "replacements": []
      }
    },
    {
      "detector_id": "lending-borrow-bypass",
      "message": "Lending protocol function 'emergencyRewardWithdraw' has borrow bypass vulnerabilities: Collateral withdrawal doesn't validate health factor after removal, may allow withdrawal that causes undercollateralization",
      "severity": "critical",
      "location": {
        "line": 452,
        "column": 14,
        "length": 23
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure lending function 'emergencyRewardWithdraw': Calculate and validate health factor before borrow, enforce collateral factor (LTV) limits, add reentrancy guards, implement same-block borrow restrictions for flash loans, update state before external calls (checks-effects-interactions pattern)",
        "replacements": []
      }
    },
    {
      "detector_id": "lending-borrow-bypass",
      "message": "Lending protocol function 'setEmergencyWithdraw' has borrow bypass vulnerabilities: Collateral withdrawal doesn't validate health factor after removal, may allow withdrawal that causes undercollateralization",
      "severity": "critical",
      "location": {
        "line": 457,
        "column": 14,
        "length": 20
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure lending function 'setEmergencyWithdraw': Calculate and validate health factor before borrow, enforce collateral factor (LTV) limits, add reentrancy guards, implement same-block borrow restrictions for flash loans, update state before external calls (checks-effects-interactions pattern)",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'deposit' calculates fees without proper bounds. No maximum fee bound. Should define MAX_FEE constant and enforce: require(fee <= MAX_FEE) Unbounded fees can lead to excessive charges or economic DoS attacks.",
      "severity": "medium",
      "location": {
        "line": 179,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add fee bounds to 'deposit': (1) Define MIN_FEE and MAX_FEE constants, (2) Implement require(fee >= MIN_FEE && fee <= MAX_FEE), (3) Add overflow protection in fee calculations, (4) Consider using safe math library, (5) Implement fee caps per transaction type.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'deposit' updates fees without proper protections. No access control on fee updates. Anyone can modify fees leading to manipulation Vulnerable fee updates can be front-run or manipulated to extract value.",
      "severity": "medium",
      "location": {
        "line": 179,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect fee updates in 'deposit': (1) Implement time-delayed fee changes with announcement period, (2) Add governance or multi-sig control for fee updates, (3) Limit rate of fee changes (e.g., max 10% per day), (4) Emit events before fee changes take effect, (5) Consider using commit-reveal scheme for fee updates.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'deposit' updates fees without proper protections. No rate limiting on fee updates. Fees could be changed too frequently causing instability Vulnerable fee updates can be front-run or manipulated to extract value.",
      "severity": "medium",
      "location": {
        "line": 179,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect fee updates in 'deposit': (1) Implement time-delayed fee changes with announcement period, (2) Add governance or multi-sig control for fee updates, (3) Limit rate of fee changes (e.g., max 10% per day), (4) Emit events before fee changes take effect, (5) Consider using commit-reveal scheme for fee updates.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'withdraw' updates fees without proper protections. No access control on fee updates. Anyone can modify fees leading to manipulation Vulnerable fee updates can be front-run or manipulated to extract value.",
      "severity": "medium",
      "location": {
        "line": 219,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect fee updates in 'withdraw': (1) Implement time-delayed fee changes with announcement period, (2) Add governance or multi-sig control for fee updates, (3) Limit rate of fee changes (e.g., max 10% per day), (4) Emit events before fee changes take effect, (5) Consider using commit-reveal scheme for fee updates.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'withdraw' updates fees without proper protections. No rate limiting on fee updates. Fees could be changed too frequently causing instability Vulnerable fee updates can be front-run or manipulated to extract value.",
      "severity": "medium",
      "location": {
        "line": 219,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect fee updates in 'withdraw': (1) Implement time-delayed fee changes with announcement period, (2) Add governance or multi-sig control for fee updates, (3) Limit rate of fee changes (e.g., max 10% per day), (4) Emit events before fee changes take effect, (5) Consider using commit-reveal scheme for fee updates.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'emergencyWithdraw' updates fees without proper protections. No access control on fee updates. Anyone can modify fees leading to manipulation Vulnerable fee updates can be front-run or manipulated to extract value.",
      "severity": "medium",
      "location": {
        "line": 260,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect fee updates in 'emergencyWithdraw': (1) Implement time-delayed fee changes with announcement period, (2) Add governance or multi-sig control for fee updates, (3) Limit rate of fee changes (e.g., max 10% per day), (4) Emit events before fee changes take effect, (5) Consider using commit-reveal scheme for fee updates.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'emergencyWithdraw' updates fees without proper protections. Fee updates take immediate effect. Should implement time delay to prevent front-running Vulnerable fee updates can be front-run or manipulated to extract value.",
      "severity": "medium",
      "location": {
        "line": 260,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect fee updates in 'emergencyWithdraw': (1) Implement time-delayed fee changes with announcement period, (2) Add governance or multi-sig control for fee updates, (3) Limit rate of fee changes (e.g., max 10% per day), (4) Emit events before fee changes take effect, (5) Consider using commit-reveal scheme for fee updates.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'emergencyWithdraw' updates fees without proper protections. No rate limiting on fee updates. Fees could be changed too frequently causing instability Vulnerable fee updates can be front-run or manipulated to extract value.",
      "severity": "medium",
      "location": {
        "line": 260,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect fee updates in 'emergencyWithdraw': (1) Implement time-delayed fee changes with announcement period, (2) Add governance or multi-sig control for fee updates, (3) Limit rate of fee changes (e.g., max 10% per day), (4) Emit events before fee changes take effect, (5) Consider using commit-reveal scheme for fee updates.",
        "replacements": []
      }
    },
    {
      "detector_id": "transient-storage-reentrancy",
      "message": "Vulnerable to transient storage reentrancy in 'withdraw' - transfer()/send() no longer safe with EIP-1153",
      "severity": "critical",
      "location": {
        "line": 219,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "EIP-1153 breaks transfer()/send() safety assumption:\n\nCRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within\nthe 2300 gas stipend of transfer() and send().\n\nFix 1: Use checks-effects-interactions pattern\nfunction withdraw() public {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\n// ‚úÖ Update state BEFORE external call\nbalances[msg.sender] = 0;\n\npayable(msg.sender).transfer(amount);\n}\n\nFix 2: Use ReentrancyGuard\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nfunction withdraw() public nonReentrant {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\nbalances[msg.sender] = 0;\npayable(msg.sender).transfer(amount);\n}\n\nReference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)",
        "replacements": []
      }
    },
    {
      "detector_id": "transient-storage-reentrancy",
      "message": "Vulnerable to transient storage reentrancy in 'emergencyWithdraw' - transfer()/send() no longer safe with EIP-1153",
      "severity": "critical",
      "location": {
        "line": 260,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "EIP-1153 breaks transfer()/send() safety assumption:\n\nCRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within\nthe 2300 gas stipend of transfer() and send().\n\nFix 1: Use checks-effects-interactions pattern\nfunction withdraw() public {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\n// ‚úÖ Update state BEFORE external call\nbalances[msg.sender] = 0;\n\npayable(msg.sender).transfer(amount);\n}\n\nFix 2: Use ReentrancyGuard\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nfunction withdraw() public nonReentrant {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\nbalances[msg.sender] = 0;\npayable(msg.sender).transfer(amount);\n}\n\nReference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)",
        "replacements": []
      }
    },
    {
      "detector_id": "transient-storage-reentrancy",
      "message": "Classic reentrancy pattern with transient storage risk in 'safeRewardTransfer'",
      "severity": "critical",
      "location": {
        "line": 477,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "State update after external call is vulnerable to reentrancy:\n\nCurrent pattern (VULNERABLE):\n1. Read balance\n2. Call transfer() ‚Üê attacker can reenter here with transient storage!\n3. Update balance to 0\n\nSecure pattern:\n1. Read balance\n2. Update balance to 0 ‚Üê do this FIRST\n3. Call transfer()\n\nWith EIP-1153, even 2300 gas is enough to modify transient state and re-enter.",
        "replacements": []
      }
    }
  ],
  "metadata": {
    "tool_name": "SolidityDefend",
    "tool_version": "1.3.6",
    "scan_type": "static_analysis",
    "language": "solidity",
    "rules_version": "1.3.6",
    "branding": {
      "name": "BlockSecOps",
      "url": "https://BlockSecOps.com",
      "description": "Enterprise-Grade DevSecOps Platform for Smart Contracts"
    }
  },
  "statistics": {
    "total_findings": 164,
    "severity_counts": {
      "low": 9,
      "critical": 28,
      "info": 0,
      "high": 67,
      "medium": 60
    },
    "unique_detectors": 51
  }
}