{
  "version": "1.3.6",
  "timestamp": "2025-11-17T22:55:13.404203Z",
  "findings": [
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 64,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "centralization-risk",
      "message": "Contract has centralization risk. Critical operations (withdraw/pause/upgrade) lack timelock delays. Malicious owner can drain funds or brick contract instantly Single point of failure can lead to fund loss, governance attacks, or complete system compromise.",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-269",
      "fix_suggestion": {
        "description": "Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.",
        "replacements": []
      }
    },
    {
      "detector_id": "guardian-role-centralization",
      "message": "Guardian role lacks explicit revocation mechanism - may be irremovable if compromised",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 8721
      },
      "fix_suggestion": {
        "description": "Implement guardian revocation function callable by DAO/owner for emergency scenarios",
        "replacements": []
      }
    },
    {
      "detector_id": "flash-loan-price-manipulation-advanced",
      "message": "Multiple swaps (3) detected in flash loan callback - multi-protocol price manipulation pattern",
      "severity": "critical",
      "location": {
        "line": 1,
        "column": 1,
        "length": 8721
      },
      "fix_suggestion": {
        "description": "Limit number of swaps per transaction or use MEV-resistant execution (Flashbots, private mempool)",
        "replacements": []
      }
    },
    {
      "detector_id": "erc20-transfer-return-bomb",
      "message": "Token transfer lacks return data size validation - vulnerable to return bomb DOS",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 8721
      },
      "fix_suggestion": {
        "description": "Check returndatasize() and reject if excessive (>64 bytes): require(returndatasize() <= 64)",
        "replacements": []
      }
    },
    {
      "detector_id": "token-decimal-confusion",
      "message": "Token price/exchange calculation without decimal normalization - incorrect conversions",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 8721
      },
      "fix_suggestion": {
        "description": "Normalize decimals: amount * 10**token1.decimals() / 10**token2.decimals()",
        "replacements": []
      }
    },
    {
      "detector_id": "token-decimal-confusion",
      "message": "Multiple tokens (7) without decimal tracking - calculation errors likely",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 8721
      },
      "fix_suggestion": {
        "description": "Store decimals per token: mapping(address => uint8) public tokenDecimals",
        "replacements": []
      }
    },
    {
      "detector_id": "token-decimal-confusion",
      "message": "Decimal-sensitive math operations without validation - verify decimal assumptions",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 8721
      },
      "fix_suggestion": {
        "description": "Validate expected decimals: require(token.decimals() == EXPECTED_DECIMALS)",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-priority-gas-auction",
      "message": "Public arbitrage function - creates PGA as bots compete for profit",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 8721
      },
      "fix_suggestion": {
        "description": "Capture MEV for protocol via auction mechanism or restrict to specific keepers",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-toxic-flow-exposure",
      "message": "Static fees on AMM - no protection against toxic flow from informed traders",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 8721
      },
      "fix_suggestion": {
        "description": "Implement dynamic fees that increase with volatility or trade size to discourage toxic flow",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-toxic-flow-exposure",
      "message": "No trade size limits - large informed trades can extract maximum value from LPs",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 8721
      },
      "fix_suggestion": {
        "description": "Add maximum trade size as percentage of reserves: require(amountIn < reserves * maxBps / 10000)",
        "replacements": []
      }
    },
    {
      "detector_id": "floating-pragma",
      "message": "Floating pragma detected: pragma solidity ^0.8.20;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.",
      "severity": "low",
      "location": {
        "line": 2,
        "column": 0,
        "length": 24
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Lock pragma to specific version: 'pragma solidity 0.8.20;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.",
        "replacements": []
      }
    },
    {
      "detector_id": "eip7702-storage-collision",
      "message": "EIP-7702 delegate uses storage - verify no collision with EOA state",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Use EIP-7201 namespaced storage to avoid collisions:\n\nbytes32 private constant STORAGE_LOCATION = \nkeccak256(\"myprotocol.delegate.storage\");\n\nstruct DelegateStorage {\naddress owner;\nmapping(address => uint256) balances;\n}\n\nfunction _getStorage() private pure returns (DelegateStorage storage $) {\nassembly { $.slot := STORAGE_LOCATION }\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "eip7702-sweeper-detection",
      "message": "MALICIOUS SWEEPER DETECTED (score: 4/10) - Batch token operations, Approve + transferFrom pattern (token drainage)",
      "severity": "critical",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "üö® CRITICAL: This appears to be a malicious sweeper contract!\n\nRisk indicators detected:\n1. Batch token operations\n2. Approve + transferFrom pattern (token drainage)\n\nSweeper contracts are responsible for 97% of malicious EIP-7702 delegations\nin 2025, causing $12M+ in losses.\n\nTypical sweeper behavior:\n1. Accepts EIP-7702 delegation\n2. Immediately drains all ETH via address(this).balance\n3. Batch transfers all ERC-20 tokens\n4. Transfers all NFTs\n5. No legitimate business logic\n\nLegitimate delegates should:\n- Have clear access control (require msg.sender == owner)\n- NOT drain all funds automatically\n- Have specific, documented functionality\n- Include safety mechanisms and time-locks\n\n‚ö†Ô∏è  If this is a legitimate contract, add documentation and access controls.\n‚ö†Ô∏è  If this is for security research, clearly mark it as such.\n\nReal-World Impact:\n- August 2025: $1.54M single transaction\n- 15,000+ wallets drained\n- 90% malicious delegation rate",
        "replacements": []
      }
    },
    {
      "detector_id": "private-variable-exposure",
      "message": "Sensitive data 'private' in 'private' variable - all blockchain storage is publicly readable",
      "severity": "high",
      "location": {
        "line": 59,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "CRITICAL: 'private' visibility does NOT encrypt data!\n\nAll blockchain storage is publicly readable via:\n- eth_getStorageAt RPC call\n- Block explorers\n- Archive nodes\n\n‚ùå This is INSECURE:\nstring private password = \"mysecret123\";\n\n‚úÖ Correct approaches:\n\n1. NEVER store secrets on-chain\n2. Store hashes instead:\nbytes32 public passwordHash = keccak256(\"password\");\n\n3. Use commit-reveal for sensitive values:\nbytes32 public commitment = keccak256(abi.encode(value, salt));\n\n4. For truly private data, use off-chain storage or ZK proofs",
        "replacements": []
      }
    },
    {
      "detector_id": "private-variable-exposure",
      "message": "Sensitive data 'private' in 'private' variable - all blockchain storage is publicly readable",
      "severity": "high",
      "location": {
        "line": 60,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "CRITICAL: 'private' visibility does NOT encrypt data!\n\nAll blockchain storage is publicly readable via:\n- eth_getStorageAt RPC call\n- Block explorers\n- Archive nodes\n\n‚ùå This is INSECURE:\nstring private password = \"mysecret123\";\n\n‚úÖ Correct approaches:\n\n1. NEVER store secrets on-chain\n2. Store hashes instead:\nbytes32 public passwordHash = keccak256(\"password\");\n\n3. Use commit-reveal for sensitive values:\nbytes32 public commitment = keccak256(abi.encode(value, salt));\n\n4. For truly private data, use off-chain storage or ZK proofs",
        "replacements": []
      }
    },
    {
      "detector_id": "private-variable-exposure",
      "message": "Sensitive data 'private' in 'private' variable - all blockchain storage is publicly readable",
      "severity": "high",
      "location": {
        "line": 64,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "CRITICAL: 'private' visibility does NOT encrypt data!\n\nAll blockchain storage is publicly readable via:\n- eth_getStorageAt RPC call\n- Block explorers\n- Archive nodes\n\n‚ùå This is INSECURE:\nstring private password = \"mysecret123\";\n\n‚úÖ Correct approaches:\n\n1. NEVER store secrets on-chain\n2. Store hashes instead:\nbytes32 public passwordHash = keccak256(\"password\");\n\n3. Use commit-reveal for sensitive values:\nbytes32 public commitment = keccak256(abi.encode(value, salt));\n\n4. For truly private data, use off-chain storage or ZK proofs",
        "replacements": []
      }
    },
    {
      "detector_id": "private-variable-exposure",
      "message": "Sensitive data 'private' in 'private' variable - all blockchain storage is publicly readable",
      "severity": "high",
      "location": {
        "line": 160,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "CRITICAL: 'private' visibility does NOT encrypt data!\n\nAll blockchain storage is publicly readable via:\n- eth_getStorageAt RPC call\n- Block explorers\n- Archive nodes\n\n‚ùå This is INSECURE:\nstring private password = \"mysecret123\";\n\n‚úÖ Correct approaches:\n\n1. NEVER store secrets on-chain\n2. Store hashes instead:\nbytes32 public passwordHash = keccak256(\"password\");\n\n3. Use commit-reveal for sensitive values:\nbytes32 public commitment = keccak256(abi.encode(value, salt));\n\n4. For truly private data, use off-chain storage or ZK proofs",
        "replacements": []
      }
    },
    {
      "detector_id": "logic-error-patterns",
      "message": "Potential division before multiplication - causes precision loss (OWASP 2025)",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "‚ùå PRECISION LOSS ($63.8M in losses):\nuint256 reward = (amount / totalSupply) * rewardRate;\n// Result: 0 if amount < totalSupply!\n\n‚úÖ CORRECT ORDER:\nuint256 reward = (amount * rewardRate) / totalSupply;\n// Maximizes precision, multiply before divide\n\n‚úÖ BEST: Use fixed-point math:\nuint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;\n\nReal incidents:\n- Cork Protocol: $11M (May 2025) - Division rounding\n- SIR.trading: $355K (March 2025) - Reward calculation\n- Multiple 2024 incidents: $63.8M total",
        "replacements": []
      }
    },
    {
      "detector_id": "logic-error-patterns",
      "message": "Percentage calculation - verify order of operations for precision",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Percentage calculations require careful ordering:\n\n‚ùå WRONG (precision loss):\nuint256 fee = (amount / 10000) * feePercent;\n\n‚úÖ CORRECT:\nuint256 fee = (amount * feePercent) / 10000;\n\n‚úÖ BEST (with basis points):\nuint256 constant BASIS_POINTS = 10000;\nuint256 fee = (amount * feeBasisPoints) / BASIS_POINTS;\n\nExample: 250 basis points = 2.5%\namount = 1000, feeBasisPoints = 250\nfee = (1000 * 250) / 10000 = 25 ‚úÖ\n\nWRONG order:\nfee = (1000 / 10000) * 250 = 0 * 250 = 0 ‚ùå",
        "replacements": []
      }
    },
    {
      "detector_id": "enhanced-input-validation",
      "message": "Array access without length validation - can cause out-of-bounds access",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "‚ùå MISSING ARRAY VALIDATION (OWASP 2025 - $14.6M impact):\nfunction process(uint256[] calldata ids) external {\nfor (uint256 i = 0; i < ids.length; i++) {\n// What if ids is empty? Or too large?\n}\n}\n\n‚úÖ VALIDATE ARRAY LENGTH:\nfunction process(uint256[] calldata ids) external {\n// Check minimum length\nrequire(ids.length > 0, \"Empty array\");\n\n// Check maximum length (prevent DoS)\nrequire(ids.length <= MAX_BATCH_SIZE, \"Batch too large\");\n\nfor (uint256 i = 0; i < ids.length; i++) {\n// Safe to access ids[i]\n}\n}\n\n‚úÖ VALIDATE ARRAY MATCHING:\nfunction batchTransfer(\naddress[] calldata recipients,\nuint256[] calldata amounts\n) external {\n// Arrays must match in length\nrequire(\nrecipients.length == amounts.length,\n\"Length mismatch\"\n);\nrequire(recipients.length > 0, \"Empty arrays\");\nrequire(recipients.length <= MAX_BATCH, \"Too many\");\n\nfor (uint256 i = 0; i < recipients.length; i++) {\n// Safe parallel access\n}\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "enhanced-input-validation",
      "message": "Transfer function without zero-value check - validate non-zero amounts",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "‚ùå MISSING ZERO-VALUE CHECK:\nfunction transfer(address to, uint256 amount) external {\n_transfer(msg.sender, to, amount);\n// What if amount is 0? Wastes gas, may break accounting\n}\n\n‚úÖ VALIDATE NON-ZERO:\nfunction transfer(address to, uint256 amount) external {\nrequire(amount > 0, \"Zero amount\");\nrequire(to != address(0), \"Zero address\");\n_transfer(msg.sender, to, amount);\n}\n\n‚úÖ COMPLETE VALIDATION:\nfunction deposit(uint256 amount) external payable {\n// For ERC20 deposits\nrequire(amount > 0, \"Zero amount\");\nrequire(amount <= MAX_DEPOSIT, \"Exceeds maximum\");\n\n// For native ETH deposits\nif (msg.value > 0) {\nrequire(msg.value == amount, \"Value mismatch\");\n}\n\n// Proceed with deposit\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "enhanced-input-validation",
      "message": "Address parameter without zero-address validation",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "‚ùå MISSING ADDRESS VALIDATION:\nfunction setOwner(address newOwner) external {\nowner = newOwner;  // What if newOwner is address(0)?\n}\n\n‚úÖ VALIDATE ADDRESS:\nfunction setOwner(address newOwner) external onlyOwner {\nrequire(newOwner != address(0), \"Zero address\");\nrequire(newOwner != owner, \"Same address\");\nowner = newOwner;\n}\n\n‚úÖ VALIDATE MULTIPLE ADDRESSES:\nfunction initialize(\naddress _token,\naddress _oracle,\naddress _treasury\n) external {\nrequire(_token != address(0), \"Zero token\");\nrequire(_oracle != address(0), \"Zero oracle\");\nrequire(_treasury != address(0), \"Zero treasury\");\n\n// Check for duplicates if needed\nrequire(_token != _oracle, \"Token == oracle\");\nrequire(_token != _treasury, \"Token == treasury\");\n\ntoken = _token;\noracle = _oracle;\ntreasury = _treasury;\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "enhanced-input-validation",
      "message": "Percentage/fee parameter without bounds validation",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "‚ùå UNBOUNDED PERCENTAGE:\nfunction setFee(uint256 newFee) external {\nfee = newFee;  // Could be set to 100% or higher!\n}\n\n‚úÖ VALIDATE PERCENTAGE BOUNDS:\nuint256 public constant MAX_FEE = 1000;  // 10% in basis points\nuint256 public constant BASIS_POINTS = 10000;  // 100%\n\nfunction setFee(uint256 newFee) external onlyOwner {\nrequire(newFee <= MAX_FEE, \"Fee too high\");\nfee = newFee;\n}\n\n‚úÖ COMPREHENSIVE RATIO VALIDATION:\nfunction setCollateralRatio(uint256 ratio) external {\n// Must be between 110% and 200%\nuint256 MIN_RATIO = 11000;  // 110%\nuint256 MAX_RATIO = 20000;  // 200%\n\nrequire(ratio >= MIN_RATIO, \"Ratio too low\");\nrequire(ratio <= MAX_RATIO, \"Ratio too high\");\ncollateralRatio = ratio;\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "flashmint-token-inflation",
      "message": "No flash mint fee - free flash mints enable spam",
      "severity": "medium",
      "location": {
        "line": 14,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Add flash mint fee (e.g., 0.05% like MakerDAO)",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-access-modifiers",
      "message": "Function 'withdrawProfits' performs critical operations but lacks access control modifiers",
      "severity": "critical",
      "location": {
        "line": 213,
        "column": 14,
        "length": 15
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier like 'onlyOwner' to function 'withdrawProfits'",
        "replacements": []
      }
    },
    {
      "detector_id": "readonly-reentrancy",
      "message": "View function 'calculatePotentialProfit' reads state that may be inconsistent during reentrancy. Contract has state-changing functions that make external calls before updating state.",
      "severity": "medium",
      "location": {
        "line": 145,
        "column": 14,
        "length": 24
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Add a reentrancy guard to state-changing functions or ensure view function 'calculatePotentialProfit' cannot be called during callbacks (e.g., using a reentrancy lock check in the view function)",
        "replacements": []
      }
    },
    {
      "detector_id": "readonly-reentrancy",
      "message": "View function 'getPriceFromDEX' reads state that may be inconsistent during reentrancy. Contract has state-changing functions that make external calls before updating state.",
      "severity": "medium",
      "location": {
        "line": 195,
        "column": 14,
        "length": 15
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Add a reentrancy guard to state-changing functions or ensure view function 'getPriceFromDEX' cannot be called during callbacks (e.g., using a reentrancy lock check in the view function)",
        "replacements": []
      }
    },
    {
      "detector_id": "readonly-reentrancy",
      "message": "View function 'isInFlashLoan' reads state that may be inconsistent during reentrancy. Contract has state-changing functions that make external calls before updating state.",
      "severity": "medium",
      "location": {
        "line": 247,
        "column": 14,
        "length": 13
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Add a reentrancy guard to state-changing functions or ensure view function 'isInFlashLoan' cannot be called during callbacks (e.g., using a reentrancy lock check in the view function)",
        "replacements": []
      }
    },
    {
      "detector_id": "invalid-state-transition",
      "message": "State variables modified after external call - potential reentrancy affecting state machine",
      "severity": "critical",
      "location": {
        "line": 134,
        "column": 9,
        "length": 47
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Use checks-effects-interactions pattern or reentrancy guards",
        "replacements": []
      }
    },
    {
      "detector_id": "invalid-state-transition",
      "message": "State variables modified after external call - potential reentrancy affecting state machine",
      "severity": "critical",
      "location": {
        "line": 219,
        "column": 9,
        "length": 42
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Use checks-effects-interactions pattern or reentrancy guards",
        "replacements": []
      }
    },
    {
      "detector_id": "invalid-state-transition",
      "message": "State variables modified after external call - potential reentrancy affecting state machine",
      "severity": "critical",
      "location": {
        "line": 227,
        "column": 9,
        "length": 39
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Use checks-effects-interactions pattern or reentrancy guards",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'asset' in function 'onFlashLoan' is not checked for zero address",
      "severity": "medium",
      "location": {
        "line": 105,
        "column": 17,
        "length": 5
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(asset != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'token' in function 'withdrawProfits' is not checked for zero address",
      "severity": "high",
      "location": {
        "line": 213,
        "column": 38,
        "length": 5
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(token != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'token' in function 'emergencyWithdraw' is not checked for zero address",
      "severity": "high",
      "location": {
        "line": 225,
        "column": 40,
        "length": 5
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(token != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'caller' in function 'setAuthorizedCaller' is not checked for zero address",
      "severity": "medium",
      "location": {
        "line": 233,
        "column": 42,
        "length": 6
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(caller != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "unchecked-external-call",
      "message": "External call in function 'onFlashLoan' does not check return value",
      "severity": "medium",
      "location": {
        "line": 104,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-252",
      "fix_suggestion": {
        "description": "Check the return value of external calls in function 'onFlashLoan'",
        "replacements": []
      }
    },
    {
      "detector_id": "unchecked-external-call",
      "message": "External call in function 'withdrawProfits' does not check return value",
      "severity": "medium",
      "location": {
        "line": 213,
        "column": 14,
        "length": 15
      },
      "cwe": "CWE-252",
      "fix_suggestion": {
        "description": "Check the return value of external calls in function 'withdrawProfits'",
        "replacements": []
      }
    },
    {
      "detector_id": "unchecked-external-call",
      "message": "External call in function 'emergencyWithdraw' does not check return value",
      "severity": "medium",
      "location": {
        "line": 225,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-252",
      "fix_suggestion": {
        "description": "Check the return value of external calls in function 'emergencyWithdraw'",
        "replacements": []
      }
    },
    {
      "detector_id": "sandwich-attack",
      "message": "Function '_executeArbitrageTrades' may be vulnerable to sandwich attacks due to predictable execution order",
      "severity": "medium",
      "location": {
        "line": 160,
        "column": 14,
        "length": 23
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Consider implementing commit-reveal schemes or using a decentralized oracle in function '_executeArbitrageTrades'",
        "replacements": []
      }
    },
    {
      "detector_id": "test-governance",
      "message": "Function 'executeArbitrage' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.",
      "severity": "medium",
      "location": {
        "line": 86,
        "column": 0,
        "length": 16
      },
      "cwe": "CWE-662",
      "fix_suggestion": {
        "description": "Implement time-delayed voting rights requiring minimum holding periods.",
        "replacements": []
      }
    },
    {
      "detector_id": "test-governance",
      "message": "Function '_executeArbitrageTrades' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.",
      "severity": "medium",
      "location": {
        "line": 160,
        "column": 0,
        "length": 23
      },
      "cwe": "CWE-662",
      "fix_suggestion": {
        "description": "Implement time-delayed voting rights requiring minimum holding periods.",
        "replacements": []
      }
    },
    {
      "detector_id": "emergency-pause-centralization",
      "message": "Contract has centralized emergency pause functionality without multisig protection. A single compromised account can halt the entire system, creating a single point of failure.",
      "severity": "medium",
      "location": {
        "line": 225,
        "column": 0,
        "length": 17
      },
      "cwe": "CWE-285",
      "fix_suggestion": {
        "description": "Implement multisig requirements for emergency functions, add time delays, or use decentralized governance for critical system controls.",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-slippage-protection",
      "message": "Function '_executeArbitrageTrades' executes DEX swap without slippage protection (amountOutMin = 0). This allows MEV bots to sandwich the transaction, extracting value through front-running and back-running attacks.",
      "severity": "high",
      "location": {
        "line": 168,
        "column": 0,
        "length": 23
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "Calculate minimum acceptable output amount based on current price and acceptable slippage (e.g., 0.5-1%). Example: uint256 minOut = expectedAmount * 99 / 100; Then use minOut instead of 0 in swap call in function '_executeArbitrageTrades'",
        "replacements": []
      }
    },
    {
      "detector_id": "vault-withdrawal-dos",
      "message": "Function 'withdrawProfits' may be vulnerable to withdrawal DOS attack. Withdrawal requires successful external call. Failing calls can permanently block withdrawals. Consider using pull-over-push pattern Attacker can block withdrawals, causing funds to be locked indefinitely.",
      "severity": "high",
      "location": {
        "line": 213,
        "column": 14,
        "length": 15
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Protect 'withdrawProfits' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
        "replacements": []
      }
    },
    {
      "detector_id": "vault-withdrawal-dos",
      "message": "Function 'emergencyWithdraw' may be vulnerable to withdrawal DOS attack. No withdrawal cap or limit detected. Large withdrawals can drain liquidity and DOS subsequent withdrawers Attacker can block withdrawals, causing funds to be locked indefinitely.",
      "severity": "high",
      "location": {
        "line": 225,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Protect 'emergencyWithdraw' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
        "replacements": []
      }
    },
    {
      "detector_id": "price-impact-manipulation",
      "message": "Function '_executeArbitrageTrades' vulnerable to price impact manipulation. No maximum trade size limit enforced, allowing trades of any size that can cause extreme price impact and drain pool liquidity Large trades without size limits or impact checks can drain liquidity, manipulate prices, and cause excessive slippage for other users.",
      "severity": "high",
      "location": {
        "line": 160,
        "column": 14,
        "length": 23
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add price impact protection to '_executeArbitrageTrades'. Implement maximum trade size limits (e.g., max 10% of pool), calculate and validate price impact percentage, enforce minimum output amounts with slippage tolerance, or split large trades across multiple blocks.",
        "replacements": []
      }
    },
    {
      "detector_id": "sandwich-resistant-swap",
      "message": "Function 'onFlashLoan' lacks sandwich attack protection. No minimum output amount (amountOutMin) parameter for slippage protection, leaving swap vulnerable to sandwich attacks MEV bots can front-run user swaps, manipulate price, then back-run to profit from the price difference at user's expense.",
      "severity": "high",
      "location": {
        "line": 104,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Add sandwich attack protection to 'onFlashLoan'. Implement: (1) Slippage tolerance with amountOutMin parameter, (2) Commit-reveal scheme for swap parameters, (3) Private mempool submission, (4) MEV-resistant AMM curve, (5) Batch auctions instead of continuous trading.",
        "replacements": []
      }
    },
    {
      "detector_id": "sandwich-resistant-swap",
      "message": "Function 'calculatePotentialProfit' lacks sandwich attack protection. No minimum output amount (amountOutMin) parameter for slippage protection, leaving swap vulnerable to sandwich attacks MEV bots can front-run user swaps, manipulate price, then back-run to profit from the price difference at user's expense.",
      "severity": "high",
      "location": {
        "line": 145,
        "column": 14,
        "length": 24
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Add sandwich attack protection to 'calculatePotentialProfit'. Implement: (1) Slippage tolerance with amountOutMin parameter, (2) Commit-reveal scheme for swap parameters, (3) Private mempool submission, (4) MEV-resistant AMM curve, (5) Batch auctions instead of continuous trading.",
        "replacements": []
      }
    },
    {
      "detector_id": "sandwich-resistant-swap",
      "message": "Function 'getPriceFromDEX' lacks sandwich attack protection. No minimum output amount (amountOutMin) parameter for slippage protection, leaving swap vulnerable to sandwich attacks MEV bots can front-run user swaps, manipulate price, then back-run to profit from the price difference at user's expense.",
      "severity": "high",
      "location": {
        "line": 195,
        "column": 14,
        "length": 15
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Add sandwich attack protection to 'getPriceFromDEX'. Implement: (1) Slippage tolerance with amountOutMin parameter, (2) Commit-reveal scheme for swap parameters, (3) Private mempool submission, (4) MEV-resistant AMM curve, (5) Batch auctions instead of continuous trading.",
        "replacements": []
      }
    },
    {
      "detector_id": "timestamp-manipulation",
      "message": "Function 'executeArbitrage' has dangerous timestamp dependency. Uses timestamp-based deadline without block.number as fallback, vulnerable to timestamp manipulation for deadline extensions Miners can manipulate block.timestamp by ~15 seconds, enabling manipulation of time-sensitive logic.",
      "severity": "high",
      "location": {
        "line": 86,
        "column": 14,
        "length": 16
      },
      "cwe": "CWE-367",
      "fix_suggestion": {
        "description": "Reduce timestamp dependency in 'executeArbitrage'. Use block.number for time intervals, add tolerance ranges (¬±15 seconds), implement commit-reveal schemes for time-sensitive operations, or use oracle-based time sources for critical logic.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'onFlashLoan' has extractable MEV. MEV extractable value vulnerability marker detected Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 104,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'onFlashLoan'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'withdrawProfits' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 213,
        "column": 14,
        "length": 15
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'withdrawProfits'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "deadline-manipulation",
      "message": "Function 'executeArbitrage' has deadline manipulation risk. Deadline parameter exists but is not validated against current time, allowing expired transactions to execute Validators can hold transactions and execute them at times that benefit MEV extraction or harm users.",
      "severity": "medium",
      "location": {
        "line": 86,
        "column": 14,
        "length": 16
      },
      "cwe": "CWE-367",
      "fix_suggestion": {
        "description": "Improve deadline handling in 'executeArbitrage'. Use reasonable default deadlines (e.g., block.timestamp + 15 minutes), validate deadline parameters, add minimum deadline checks, or implement deadline extensions for failed transactions.",
        "replacements": []
      }
    },
    {
      "detector_id": "deadline-manipulation",
      "message": "Function '_executeArbitrageTrades' has deadline manipulation risk. Deadline parameter exists but is not validated against current time, allowing expired transactions to execute Validators can hold transactions and execute them at times that benefit MEV extraction or harm users.",
      "severity": "medium",
      "location": {
        "line": 160,
        "column": 14,
        "length": 23
      },
      "cwe": "CWE-367",
      "fix_suggestion": {
        "description": "Improve deadline handling in '_executeArbitrageTrades'. Use reasonable default deadlines (e.g., block.timestamp + 15 minutes), validate deadline parameters, add minimum deadline checks, or implement deadline extensions for failed transactions.",
        "replacements": []
      }
    },
    {
      "detector_id": "validator-front-running",
      "message": "Function '_executeArbitrageTrades' has validator front-running vulnerability. Price-sensitive operations without fair sequencing, validators can reorder transactions for MEV extraction Validators can observe pending transactions and extract value by front-running users.",
      "severity": "high",
      "location": {
        "line": 160,
        "column": 14,
        "length": 23
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Mitigate validator front-running in '_executeArbitrageTrades'. Implement commit-reveal schemes, use threshold encryption, add validator rotation, implement fair sequencing service integration, use batch auctions instead of continuous, and add MEV redistribution mechanisms.",
        "replacements": []
      }
    },
    {
      "detector_id": "gas-griefing",
      "message": "Function 'executeArbitrage' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.",
      "severity": "medium",
      "location": {
        "line": 86,
        "column": 14,
        "length": 16
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Mitigate gas griefing in 'executeArbitrage'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
        "replacements": []
      }
    },
    {
      "detector_id": "gas-griefing",
      "message": "Function 'onFlashLoan' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
      "severity": "medium",
      "location": {
        "line": 104,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Mitigate gas griefing in 'onFlashLoan'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
        "replacements": []
      }
    },
    {
      "detector_id": "gas-griefing",
      "message": "Function 'withdrawProfits' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
      "severity": "medium",
      "location": {
        "line": 213,
        "column": 14,
        "length": 15
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Mitigate gas griefing in 'withdrawProfits'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
        "replacements": []
      }
    },
    {
      "detector_id": "gas-griefing",
      "message": "Function 'emergencyWithdraw' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
      "severity": "medium",
      "location": {
        "line": 225,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Mitigate gas griefing in 'emergencyWithdraw'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
        "replacements": []
      }
    },
    {
      "detector_id": "dos-failed-transfer",
      "message": "Function 'onFlashLoan' uses push pattern for transfers which can cause DoS if recipient reverts. A malicious or buggy recipient contract can block this function by rejecting payments. Use the pull pattern (withdrawal pattern) instead where users withdraw their own funds.",
      "severity": "high",
      "location": {
        "line": 104,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Refactor 'onFlashLoan' to use pull pattern instead of push. Store pending withdrawals in a mapping and let users withdraw their own funds. Example: balances[user] = amount; then separate withdraw() function. Use OpenZeppelin's PullPayment contract for reference.",
        "replacements": []
      }
    },
    {
      "detector_id": "front-running-mitigation",
      "message": "Function '_executeArbitrageTrades' lacks front-running protection. Function '_executeArbitrageTrades' performs high-value state changes observable in mempool. Consider commit-reveal or private transactions Front-runners can extract MEV by observing mempool and inserting their transactions before yours.",
      "severity": "high",
      "location": {
        "line": 160,
        "column": 14,
        "length": 23
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Add front-running protection to '_executeArbitrageTrades'. Implement: (1) Commit-reveal scheme with time delay, (2) Deadline parameter for transaction validity, (3) Minimum output amount (slippage protection), (4) Batch auctions or frequent batch auctions (FBA), (5) Private mempool (Flashbots Protect), (6) Time-weighted average pricing (TWAP).",
        "replacements": []
      }
    },
    {
      "detector_id": "price-oracle-stale",
      "message": "Function 'onFlashLoan' uses oracle price data without staleness validation. Oracle price fetch without staleness validation. Missing checks for updatedAt timestamp, price age, or heartbeat threshold Using stale oracle data can lead to incorrect liquidations, price manipulations, and financial losses.",
      "severity": "critical",
      "location": {
        "line": 104,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-829",
      "fix_suggestion": {
        "description": "Add staleness checks in 'onFlashLoan'. Implement: (1) Check oracle updatedAt timestamp, (2) Verify data freshness with block.timestamp comparison, (3) Add HEARTBEAT_THRESHOLD constant (e.g., 3600 seconds), (4) Revert if price is too old, (5) Consider Chainlink's latestRoundData() with timestamp validation.",
        "replacements": []
      }
    },
    {
      "detector_id": "price-oracle-stale",
      "message": "Function 'calculatePotentialProfit' uses oracle price data without staleness validation. Oracle price fetch without staleness validation. Missing checks for updatedAt timestamp, price age, or heartbeat threshold Using stale oracle data can lead to incorrect liquidations, price manipulations, and financial losses.",
      "severity": "critical",
      "location": {
        "line": 145,
        "column": 14,
        "length": 24
      },
      "cwe": "CWE-829",
      "fix_suggestion": {
        "description": "Add staleness checks in 'calculatePotentialProfit'. Implement: (1) Check oracle updatedAt timestamp, (2) Verify data freshness with block.timestamp comparison, (3) Add HEARTBEAT_THRESHOLD constant (e.g., 3600 seconds), (4) Revert if price is too old, (5) Consider Chainlink's latestRoundData() with timestamp validation.",
        "replacements": []
      }
    },
    {
      "detector_id": "centralization-risk",
      "message": "Function 'emergencyWithdraw' has centralization risk. Emergency function 'emergencyWithdraw' lacks multi-party approval. Can be abused by single compromised key Critical function controlled by single address creates attack vector.",
      "severity": "high",
      "location": {
        "line": 225,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-269",
      "fix_suggestion": {
        "description": "Add decentralization to 'emergencyWithdraw'. Implement multi-signature requirements, timelock delays, or DAO governance for this critical function.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'onFlashLoan' contains variable shadowing. Local variable 'repayAmount' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 104,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'onFlashLoan'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'onFlashLoan' contains variable shadowing. Local variable 'profit' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 104,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'onFlashLoan'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function '_executeArbitrageTrades' contains variable shadowing. Local variable 'tokenBAmount' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 160,
        "column": 14,
        "length": 23
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in '_executeArbitrageTrades'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'withdrawProfits' contains variable shadowing. Parameter 'profit' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 213,
        "column": 14,
        "length": 15
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'withdrawProfits'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'withdrawProfits' contains variable shadowing. Local variable 'profit' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 213,
        "column": 14,
        "length": 15
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'withdrawProfits'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "unsafe-type-casting",
      "message": "Function 'onFlashLoan' contains unsafe type casting. address type casting without validation. May result in zero address Unsafe type conversions can lead to data loss, value truncation, or unexpected behavior.",
      "severity": "medium",
      "location": {
        "line": 122,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-704",
      "fix_suggestion": {
        "description": "Add safe type casting in 'onFlashLoan'. Implement: (1) Validate value ranges before casting, (2) Use require() to check bounds, (3) Use SafeCast library from OpenZeppelin, (4) Avoid downcasting without validation, (5) Check for sign preservation in int/uint conversions.",
        "replacements": []
      }
    },
    {
      "detector_id": "flashloan-price-oracle-manipulation",
      "message": "'getPriceFromDEX' uses spot price oracle - vulnerable to flash loan manipulation (Polter Finance $7M exploit)",
      "severity": "critical",
      "location": {
        "line": 195,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Use TWAP oracle (Uniswap V3 observe()) or Chainlink with 30-minute average",
        "replacements": []
      }
    },
    {
      "detector_id": "flashmint-token-inflation",
      "message": "No flash mint fee - free flash mints enable spam",
      "severity": "medium",
      "location": {
        "line": 240,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Add flash mint fee (e.g., 0.05% like MakerDAO)",
        "replacements": []
      }
    },
    {
      "detector_id": "flashmint-token-inflation",
      "message": "No flash mint fee - free flash mints enable spam",
      "severity": "medium",
      "location": {
        "line": 247,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Add flash mint fee (e.g., 0.05% like MakerDAO)",
        "replacements": []
      }
    },
    {
      "detector_id": "price-manipulation-frontrun",
      "message": "Function 'onFlashLoan' has price manipulation vulnerability. Price oracle without staleness check. Function 'onFlashLoan' uses external price oracle but doesn't validate timestamp/staleness. Stale prices enable arbitrage This enables flash loan attacks, sandwich attacks, and MEV extraction via price oracle manipulation. Attackers can manipulate prices and extract value from victim transactions",
      "severity": "high",
      "location": {
        "line": 104,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Fix price manipulation in 'onFlashLoan'. Implement: (1) Use TWAP (Time-Weighted Average Price) instead of spot prices; (2) Validate price staleness: require(block.timestamp - updatedAt <= MAX_DELAY); (3) Add price deviation bounds: require(newPrice >= minPrice && newPrice <= maxPrice); (4) Use multiple oracle sources and median prices; (5) Implement circuit breakers for extreme price moves; (6) Add price impact validation for large operations; (7) Consider commit-reveal for price-sensitive operations",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-transaction-deadline",
      "message": "Function 'withdrawProfits' is missing transaction deadline. Missing transaction deadline. Withdrawal operation 'withdrawProfits' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed",
      "severity": "medium",
      "location": {
        "line": 213,
        "column": 14,
        "length": 15
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add deadline to 'withdrawProfits'. Implement: (1) Add 'deadline' parameter: function withdrawProfits(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-transaction-deadline",
      "message": "Function 'emergencyWithdraw' is missing transaction deadline. Missing transaction deadline. Withdrawal operation 'emergencyWithdraw' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed",
      "severity": "medium",
      "location": {
        "line": 225,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add deadline to 'emergencyWithdraw'. Implement: (1) Add 'deadline' parameter: function emergencyWithdraw(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users",
        "replacements": []
      }
    },
    {
      "detector_id": "lending-borrow-bypass",
      "message": "Lending protocol function 'emergencyWithdraw' has borrow bypass vulnerabilities: Collateral withdrawal doesn't validate health factor after removal, may allow withdrawal that causes undercollateralization",
      "severity": "critical",
      "location": {
        "line": 225,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure lending function 'emergencyWithdraw': Calculate and validate health factor before borrow, enforce collateral factor (LTV) limits, add reentrancy guards, implement same-block borrow restrictions for flash loans, update state before external calls (checks-effects-interactions pattern)",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'onFlashLoan' updates fees without proper protections. No access control on fee updates. Anyone can modify fees leading to manipulation Vulnerable fee updates can be front-run or manipulated to extract value.",
      "severity": "medium",
      "location": {
        "line": 104,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect fee updates in 'onFlashLoan': (1) Implement time-delayed fee changes with announcement period, (2) Add governance or multi-sig control for fee updates, (3) Limit rate of fee changes (e.g., max 10% per day), (4) Emit events before fee changes take effect, (5) Consider using commit-reveal scheme for fee updates.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'onFlashLoan' updates fees without proper protections. Fee updates take immediate effect. Should implement time delay to prevent front-running Vulnerable fee updates can be front-run or manipulated to extract value.",
      "severity": "medium",
      "location": {
        "line": 104,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect fee updates in 'onFlashLoan': (1) Implement time-delayed fee changes with announcement period, (2) Add governance or multi-sig control for fee updates, (3) Limit rate of fee changes (e.g., max 10% per day), (4) Emit events before fee changes take effect, (5) Consider using commit-reveal scheme for fee updates.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-fee-manipulation",
      "message": "Function 'onFlashLoan' updates fees without proper protections. No rate limiting on fee updates. Fees could be changed too frequently causing instability Vulnerable fee updates can be front-run or manipulated to extract value.",
      "severity": "medium",
      "location": {
        "line": 104,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Protect fee updates in 'onFlashLoan': (1) Implement time-delayed fee changes with announcement period, (2) Add governance or multi-sig control for fee updates, (3) Limit rate of fee changes (e.g., max 10% per day), (4) Emit events before fee changes take effect, (5) Consider using commit-reveal scheme for fee updates.",
        "replacements": []
      }
    },
    {
      "detector_id": "transient-storage-reentrancy",
      "message": "Classic reentrancy pattern with transient storage risk in 'onFlashLoan'",
      "severity": "critical",
      "location": {
        "line": 104,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "State update after external call is vulnerable to reentrancy:\n\nCurrent pattern (VULNERABLE):\n1. Read balance\n2. Call transfer() ‚Üê attacker can reenter here with transient storage!\n3. Update balance to 0\n\nSecure pattern:\n1. Read balance\n2. Update balance to 0 ‚Üê do this FIRST\n3. Call transfer()\n\nWith EIP-1153, even 2300 gas is enough to modify transient state and re-enter.",
        "replacements": []
      }
    },
    {
      "detector_id": "transient-storage-reentrancy",
      "message": "Vulnerable to transient storage reentrancy in 'withdrawProfits' - transfer()/send() no longer safe with EIP-1153",
      "severity": "critical",
      "location": {
        "line": 213,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "EIP-1153 breaks transfer()/send() safety assumption:\n\nCRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within\nthe 2300 gas stipend of transfer() and send().\n\nFix 1: Use checks-effects-interactions pattern\nfunction withdraw() public {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\n// ‚úÖ Update state BEFORE external call\nbalances[msg.sender] = 0;\n\npayable(msg.sender).transfer(amount);\n}\n\nFix 2: Use ReentrancyGuard\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nfunction withdraw() public nonReentrant {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\nbalances[msg.sender] = 0;\npayable(msg.sender).transfer(amount);\n}\n\nReference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)",
        "replacements": []
      }
    }
  ],
  "metadata": {
    "tool_name": "SolidityDefend",
    "tool_version": "1.3.6",
    "scan_type": "static_analysis",
    "language": "solidity",
    "rules_version": "1.3.6",
    "branding": {
      "name": "BlockSecOps",
      "url": "https://BlockSecOps.com",
      "description": "Enterprise-Grade DevSecOps Platform for Smart Contracts"
    }
  },
  "statistics": {
    "total_findings": 83,
    "severity_counts": {
      "critical": 12,
      "info": 0,
      "high": 26,
      "medium": 43,
      "low": 2
    },
    "unique_detectors": 43
  }
}