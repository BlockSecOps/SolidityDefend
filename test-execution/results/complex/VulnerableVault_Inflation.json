{
  "version": "1.3.6",
  "timestamp": "2025-11-17T22:55:22.672553Z",
  "findings": [
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Function 'deposit' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 51,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Function 'redeem' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 77,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "erc20-transfer-return-bomb",
      "message": "Token transfer lacks return data size validation - vulnerable to return bomb DOS",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 4107
      },
      "fix_suggestion": {
        "description": "Check returndatasize() and reject if excessive (>64 bytes): require(returndatasize() <= 64)",
        "replacements": []
      }
    },
    {
      "detector_id": "token-decimal-confusion",
      "message": "Token price/exchange calculation without decimal normalization - incorrect conversions",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 4107
      },
      "fix_suggestion": {
        "description": "Normalize decimals: amount * 10**token1.decimals() / 10**token2.decimals()",
        "replacements": []
      }
    },
    {
      "detector_id": "token-decimal-confusion",
      "message": "Multiple tokens (3) without decimal tracking - calculation errors likely",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 4107
      },
      "fix_suggestion": {
        "description": "Store decimals per token: mapping(address => uint8) public tokenDecimals",
        "replacements": []
      }
    },
    {
      "detector_id": "token-decimal-confusion",
      "message": "Decimal-sensitive math operations without validation - verify decimal assumptions",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 4107
      },
      "fix_suggestion": {
        "description": "Validate expected decimals: require(token.decimals() == EXPECTED_DECIMALS)",
        "replacements": []
      }
    },
    {
      "detector_id": "floating-pragma",
      "message": "Floating pragma detected: pragma solidity ^0.8.0;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.",
      "severity": "low",
      "location": {
        "line": 2,
        "column": 0,
        "length": 23
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Lock pragma to specific version: 'pragma solidity 0.8.0;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.",
        "replacements": []
      }
    },
    {
      "detector_id": "logic-error-patterns",
      "message": "Potential division before multiplication - causes precision loss (OWASP 2025)",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "❌ PRECISION LOSS ($63.8M in losses):\nuint256 reward = (amount / totalSupply) * rewardRate;\n// Result: 0 if amount < totalSupply!\n\n✅ CORRECT ORDER:\nuint256 reward = (amount * rewardRate) / totalSupply;\n// Maximizes precision, multiply before divide\n\n✅ BEST: Use fixed-point math:\nuint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;\n\nReal incidents:\n- Cork Protocol: $11M (May 2025) - Division rounding\n- SIR.trading: $355K (March 2025) - Reward calculation\n- Multiple 2024 incidents: $63.8M total",
        "replacements": []
      }
    },
    {
      "detector_id": "oracle-time-window-attack",
      "message": "Oracle price usage without time-weighted average - consider TWAP",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Single-block price oracles are manipulable:\n\n❌ Vulnerable patterns:\n- Using spot price from DEX\n- Single block price snapshot\n- No time-weighting\n- No price deviation checks\n\n✅ Recommended solutions:\n\n1. Use Uniswap V3 TWAP (30+ minute window)\n2. Use Chainlink Price Feeds (aggregated off-chain)\n3. Combine multiple oracle sources\n4. Implement price deviation bounds:\nrequire(abs(newPrice - lastPrice) < maxDelta);\n5. Use time-weighted moving average:\npriceSum += currentPrice;\npriceCount++;\navgPrice = priceSum / priceCount;\n\nMinimum TWAP window: 30 minutes (longer is better)\nMaximum price deviation: 2-5% from last update",
        "replacements": []
      }
    },
    {
      "detector_id": "enhanced-input-validation",
      "message": "Array access without length validation - can cause out-of-bounds access",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "❌ MISSING ARRAY VALIDATION (OWASP 2025 - $14.6M impact):\nfunction process(uint256[] calldata ids) external {\nfor (uint256 i = 0; i < ids.length; i++) {\n// What if ids is empty? Or too large?\n}\n}\n\n✅ VALIDATE ARRAY LENGTH:\nfunction process(uint256[] calldata ids) external {\n// Check minimum length\nrequire(ids.length > 0, \"Empty array\");\n\n// Check maximum length (prevent DoS)\nrequire(ids.length <= MAX_BATCH_SIZE, \"Batch too large\");\n\nfor (uint256 i = 0; i < ids.length; i++) {\n// Safe to access ids[i]\n}\n}\n\n✅ VALIDATE ARRAY MATCHING:\nfunction batchTransfer(\naddress[] calldata recipients,\nuint256[] calldata amounts\n) external {\n// Arrays must match in length\nrequire(\nrecipients.length == amounts.length,\n\"Length mismatch\"\n);\nrequire(recipients.length > 0, \"Empty arrays\");\nrequire(recipients.length <= MAX_BATCH, \"Too many\");\n\nfor (uint256 i = 0; i < recipients.length; i++) {\n// Safe parallel access\n}\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "enhanced-input-validation",
      "message": "Transfer function without zero-value check - validate non-zero amounts",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "❌ MISSING ZERO-VALUE CHECK:\nfunction transfer(address to, uint256 amount) external {\n_transfer(msg.sender, to, amount);\n// What if amount is 0? Wastes gas, may break accounting\n}\n\n✅ VALIDATE NON-ZERO:\nfunction transfer(address to, uint256 amount) external {\nrequire(amount > 0, \"Zero amount\");\nrequire(to != address(0), \"Zero address\");\n_transfer(msg.sender, to, amount);\n}\n\n✅ COMPLETE VALIDATION:\nfunction deposit(uint256 amount) external payable {\n// For ERC20 deposits\nrequire(amount > 0, \"Zero amount\");\nrequire(amount <= MAX_DEPOSIT, \"Exceeds maximum\");\n\n// For native ETH deposits\nif (msg.value > 0) {\nrequire(msg.value == amount, \"Value mismatch\");\n}\n\n// Proceed with deposit\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "enhanced-input-validation",
      "message": "Address parameter without zero-address validation",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "❌ MISSING ADDRESS VALIDATION:\nfunction setOwner(address newOwner) external {\nowner = newOwner;  // What if newOwner is address(0)?\n}\n\n✅ VALIDATE ADDRESS:\nfunction setOwner(address newOwner) external onlyOwner {\nrequire(newOwner != address(0), \"Zero address\");\nrequire(newOwner != owner, \"Same address\");\nowner = newOwner;\n}\n\n✅ VALIDATE MULTIPLE ADDRESSES:\nfunction initialize(\naddress _token,\naddress _oracle,\naddress _treasury\n) external {\nrequire(_token != address(0), \"Zero token\");\nrequire(_oracle != address(0), \"Zero oracle\");\nrequire(_treasury != address(0), \"Zero treasury\");\n\n// Check for duplicates if needed\nrequire(_token != _oracle, \"Token == oracle\");\nrequire(_token != _treasury, \"Token == treasury\");\n\ntoken = _token;\noracle = _oracle;\ntreasury = _treasury;\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "enhanced-input-validation",
      "message": "Percentage/fee parameter without bounds validation",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "❌ UNBOUNDED PERCENTAGE:\nfunction setFee(uint256 newFee) external {\nfee = newFee;  // Could be set to 100% or higher!\n}\n\n✅ VALIDATE PERCENTAGE BOUNDS:\nuint256 public constant MAX_FEE = 1000;  // 10% in basis points\nuint256 public constant BASIS_POINTS = 10000;  // 100%\n\nfunction setFee(uint256 newFee) external onlyOwner {\nrequire(newFee <= MAX_FEE, \"Fee too high\");\nfee = newFee;\n}\n\n✅ COMPREHENSIVE RATIO VALIDATION:\nfunction setCollateralRatio(uint256 ratio) external {\n// Must be between 110% and 200%\nuint256 MIN_RATIO = 11000;  // 110%\nuint256 MAX_RATIO = 20000;  // 200%\n\nrequire(ratio >= MIN_RATIO, \"Ratio too low\");\nrequire(ratio <= MAX_RATIO, \"Ratio too high\");\ncollateralRatio = ratio;\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "pool-donation-enhanced",
      "message": "ERC-4626 vault lacks initial share protection - vulnerable to share inflation attack",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 4107
      },
      "fix_suggestion": {
        "description": "Mint initial dead shares or use virtual shares/assets in share calculation to prevent first-depositor manipulation",
        "replacements": []
      }
    },
    {
      "detector_id": "pool-donation-enhanced",
      "message": "Share calculation uses contract balance directly - vulnerable to donation attack via direct transfer",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 4107
      },
      "fix_suggestion": {
        "description": "Track balances internally instead of using balanceOf(), or use virtual assets/shares in calculations",
        "replacements": []
      }
    },
    {
      "detector_id": "pool-donation-enhanced",
      "message": "Pool initialization lacks protection - first depositor can manipulate initial share price",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 4107
      },
      "fix_suggestion": {
        "description": "Require minimum initial deposit, mint dead shares on initialization, or use time-delayed activation",
        "replacements": []
      }
    },
    {
      "detector_id": "pool-donation-enhanced",
      "message": "Preview functions use manipulable balance - can be exploited for front-running attacks",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 4107
      },
      "fix_suggestion": {
        "description": "Document that preview functions are manipulable via donations, or use stored balances instead",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'receiver' in function 'deposit' is not checked for zero address",
      "severity": "high",
      "location": {
        "line": 51,
        "column": 46,
        "length": 8
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(receiver != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'receiver' in function 'redeem' is not checked for zero address",
      "severity": "medium",
      "location": {
        "line": 77,
        "column": 45,
        "length": 8
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(receiver != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'owner' in function 'redeem' is not checked for zero address",
      "severity": "high",
      "location": {
        "line": 77,
        "column": 63,
        "length": 5
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(owner != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "vault-share-inflation",
      "message": "Function 'deposit' may be vulnerable to vault share inflation attack. Share calculation vulnerable to inflation: uses assets * totalSupply / totalAssets without virtual shares/assets offset protection First depositor can manipulate share price by depositing 1 wei, donating assets directly to vault, causing rounding errors that steal from subsequent depositors.",
      "severity": "critical",
      "location": {
        "line": 51,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Protect 'deposit' from share inflation attack. Solutions: (1) Mint initial shares to zero address on deployment (dead shares - Uniswap V2 pattern), (2) Implement virtual shares/assets (OpenZeppelin ERC4626 with decimalsOffset), (3) Enforce minimum first deposit amount (>= 1e6 recommended), (4) Use higher precision decimals (1e18 instead of 1e6), (5) Track assets internally instead of using balanceOf, (6) Consider EigenLayer delegation pattern for restaking vaults.",
        "replacements": []
      }
    },
    {
      "detector_id": "vault-share-inflation",
      "message": "Function 'previewDeposit' may be vulnerable to vault share inflation attack. No minimum deposit amount enforced, allowing 1 wei deposit that can be used for share price manipulation First depositor can manipulate share price by depositing 1 wei, donating assets directly to vault, causing rounding errors that steal from subsequent depositors.",
      "severity": "critical",
      "location": {
        "line": 103,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Protect 'previewDeposit' from share inflation attack. Solutions: (1) Mint initial shares to zero address on deployment (dead shares - Uniswap V2 pattern), (2) Implement virtual shares/assets (OpenZeppelin ERC4626 with decimalsOffset), (3) Enforce minimum first deposit amount (>= 1e6 recommended), (4) Use higher precision decimals (1e18 instead of 1e6), (5) Track assets internally instead of using balanceOf, (6) Consider EigenLayer delegation pattern for restaking vaults.",
        "replacements": []
      }
    },
    {
      "detector_id": "vault-donation-attack",
      "message": "Function 'deposit' may be vulnerable to vault donation attack. Uses balanceOf(address(this)) for share price calculation without internal balance tracking. Vulnerable to direct token donation manipulation Attacker can manipulate share price by directly transferring tokens to vault, causing rounding errors that steal from depositors.",
      "severity": "high",
      "location": {
        "line": 51,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Protect 'deposit' from donation attack. Solutions: (1) Track assets internally instead of using balanceOf, (2) Implement donation guards that track expected vs actual balance, (3) Use virtual shares/assets to make donations economically infeasible (OpenZeppelin ERC4626), (4) Require minimum initial deposits, (5) Use dead shares pattern (Uniswap V2 style), (6) Consider EigenLayer delegation pattern for restaking protocols.",
        "replacements": []
      }
    },
    {
      "detector_id": "vault-donation-attack",
      "message": "Function 'totalAssets' may be vulnerable to vault donation attack. Uses balanceOf(address(this)) for share price calculation without internal balance tracking. Vulnerable to direct token donation manipulation Attacker can manipulate share price by directly transferring tokens to vault, causing rounding errors that steal from depositors.",
      "severity": "high",
      "location": {
        "line": 94,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Protect 'totalAssets' from donation attack. Solutions: (1) Track assets internally instead of using balanceOf, (2) Implement donation guards that track expected vs actual balance, (3) Use virtual shares/assets to make donations economically infeasible (OpenZeppelin ERC4626), (4) Require minimum initial deposits, (5) Use dead shares pattern (Uniswap V2 style), (6) Consider EigenLayer delegation pattern for restaking protocols.",
        "replacements": []
      }
    },
    {
      "detector_id": "vault-withdrawal-dos",
      "message": "Function 'redeem' may be vulnerable to withdrawal DOS attack. No circuit breaker or emergency withdrawal mechanism. Vault cannot be paused during attacks or emergencies Attacker can block withdrawals, causing funds to be locked indefinitely.",
      "severity": "high",
      "location": {
        "line": 77,
        "column": 14,
        "length": 6
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Protect 'redeem' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
        "replacements": []
      }
    },
    {
      "detector_id": "gas-griefing",
      "message": "Function 'deposit' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.",
      "severity": "medium",
      "location": {
        "line": 51,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Mitigate gas griefing in 'deposit'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
        "replacements": []
      }
    },
    {
      "detector_id": "gas-griefing",
      "message": "Function 'redeem' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
      "severity": "medium",
      "location": {
        "line": 77,
        "column": 14,
        "length": 6
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Mitigate gas griefing in 'redeem'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
        "replacements": []
      }
    },
    {
      "detector_id": "gas-griefing",
      "message": "Function 'totalAssets' has gas griefing vulnerability. Push pattern for mass distribution, single failing recipient can grief entire distribution Attackers can force users to waste gas or cause transactions to fail.",
      "severity": "medium",
      "location": {
        "line": 94,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Mitigate gas griefing in 'totalAssets'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function 'deposit' contains excessive gas usage pattern. Multiple storage reads detected (6). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 51,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in 'deposit'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function 'redeem' contains excessive gas usage pattern. Multiple storage reads detected (8). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 77,
        "column": 14,
        "length": 6
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in 'redeem'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'deposit' contains variable shadowing. Parameter 'totalSupply' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 51,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'deposit'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'previewDeposit' contains variable shadowing. Parameter 'totalSupply' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 103,
        "column": 14,
        "length": 14
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'previewDeposit'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-yield-farming-exploits",
      "message": "No deposit cap (unlimited exposure risk) in 'deposit'",
      "severity": "low",
      "location": {
        "line": 51,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Add cap: require(totalAssets() + amount <= depositCap, \"Cap exceeded\");",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-yield-farming-exploits",
      "message": "No withdrawal fee accounting (fee bypass risk) in 'redeem'",
      "severity": "medium",
      "location": {
        "line": 77,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Calculate fee: uint256 fee = (amount * withdrawalFee) / FEE_DENOMINATOR; uint256 amountAfterFee = amount - fee;",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-yield-farming-exploits",
      "message": "No validation for zero assets on withdrawal in 'redeem'",
      "severity": "medium",
      "location": {
        "line": 77,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Validate assets: require(assets > 0, \"Assets must be non-zero\");",
        "replacements": []
      }
    },
    {
      "detector_id": "defi-yield-farming-exploits",
      "message": "No deposit cap (unlimited exposure risk) in 'previewDeposit'",
      "severity": "low",
      "location": {
        "line": 103,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Add cap: require(totalAssets() + amount <= depositCap, \"Cap exceeded\");",
        "replacements": []
      }
    },
    {
      "detector_id": "price-manipulation-frontrun",
      "message": "Function 'totalAssets' has price manipulation vulnerability. Uses balanceOf for price calculation. Function 'totalAssets' calculates prices using token balances which can be manipulated via flash loans or large trades This enables flash loan attacks, sandwich attacks, and MEV extraction via price oracle manipulation. Attackers can manipulate prices and extract value from victim transactions",
      "severity": "high",
      "location": {
        "line": 94,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Fix price manipulation in 'totalAssets'. Implement: (1) Use TWAP (Time-Weighted Average Price) instead of spot prices; (2) Validate price staleness: require(block.timestamp - updatedAt <= MAX_DELAY); (3) Add price deviation bounds: require(newPrice >= minPrice && newPrice <= maxPrice); (4) Use multiple oracle sources and median prices; (5) Implement circuit breakers for extreme price moves; (6) Add price impact validation for large operations; (7) Consider commit-reveal for price-sensitive operations",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-transaction-deadline",
      "message": "Function 'deposit' is missing transaction deadline. Missing transaction deadline. Time-sensitive operation 'deposit' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed",
      "severity": "medium",
      "location": {
        "line": 51,
        "column": 14,
        "length": 7
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add deadline to 'deposit'. Implement: (1) Add 'deadline' parameter: function deposit(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-transaction-deadline",
      "message": "Function 'redeem' is missing transaction deadline. Missing transaction deadline. Redemption operation 'redeem' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed",
      "severity": "medium",
      "location": {
        "line": 77,
        "column": 14,
        "length": 6
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add deadline to 'redeem'. Implement: (1) Add 'deadline' parameter: function redeem(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users",
        "replacements": []
      }
    },
    {
      "detector_id": "transient-storage-reentrancy",
      "message": "Classic reentrancy pattern with transient storage risk in 'redeem'",
      "severity": "critical",
      "location": {
        "line": 77,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "State update after external call is vulnerable to reentrancy:\n\nCurrent pattern (VULNERABLE):\n1. Read balance\n2. Call transfer() ← attacker can reenter here with transient storage!\n3. Update balance to 0\n\nSecure pattern:\n1. Read balance\n2. Update balance to 0 ← do this FIRST\n3. Call transfer()\n\nWith EIP-1153, even 2300 gas is enough to modify transient state and re-enter.",
        "replacements": []
      }
    }
  ],
  "metadata": {
    "tool_name": "SolidityDefend",
    "tool_version": "1.3.6",
    "scan_type": "static_analysis",
    "language": "solidity",
    "rules_version": "1.3.6",
    "branding": {
      "name": "BlockSecOps",
      "url": "https://BlockSecOps.com",
      "description": "Enterprise-Grade DevSecOps Platform for Smart Contracts"
    }
  },
  "statistics": {
    "total_findings": 40,
    "severity_counts": {
      "medium": 16,
      "low": 7,
      "info": 0,
      "high": 14,
      "critical": 3
    },
    "unique_detectors": 19
  }
}