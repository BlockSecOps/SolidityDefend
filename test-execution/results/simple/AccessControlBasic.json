{
  "version": "1.3.6",
  "timestamp": "2025-11-17T22:52:00.527866Z",
  "findings": [
    {
      "detector_id": "missing-access-modifiers",
      "message": "Function 'initialize' performs critical operations but lacks access control modifiers",
      "severity": "critical",
      "location": {
        "line": 25,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier like 'onlyOwner' to function 'initialize'",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-access-modifiers",
      "message": "Function 'emergencyWithdraw' performs critical operations but lacks access control modifiers",
      "severity": "critical",
      "location": {
        "line": 41,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier like 'onlyOwner' to function 'emergencyWithdraw'",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-access-modifiers",
      "message": "Function 'changeOwner' performs critical operations but lacks access control modifiers",
      "severity": "critical",
      "location": {
        "line": 47,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier like 'onlyOwner' to function 'changeOwner'",
        "replacements": []
      }
    },
    {
      "detector_id": "unprotected-initializer",
      "message": "Initializer function 'initialize' lacks access control and can be called by anyone",
      "severity": "high",
      "location": {
        "line": 25,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier to 'initialize' or ensure it can only be called once during deployment",
        "replacements": []
      }
    },
    {
      "detector_id": "invalid-state-transition",
      "message": "State variable 'initialized' is modified without proper validation or state checks",
      "severity": "high",
      "location": {
        "line": 28,
        "column": 9,
        "length": 18
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "Add proper validation before modifying state variables",
        "replacements": []
      }
    },
    {
      "detector_id": "invalid-state-transition",
      "message": "State variables modified after external call - potential reentrancy affecting state machine",
      "severity": "critical",
      "location": {
        "line": 36,
        "column": 9,
        "length": 36
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Use checks-effects-interactions pattern or reentrancy guards",
        "replacements": []
      }
    },
    {
      "detector_id": "invalid-state-transition",
      "message": "State variables modified after external call - potential reentrancy affecting state machine",
      "severity": "critical",
      "location": {
        "line": 42,
        "column": 9,
        "length": 51
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Use checks-effects-interactions pattern or reentrancy guards",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter '_owner' in function 'initialize' is not checked for zero address",
      "severity": "high",
      "location": {
        "line": 25,
        "column": 33,
        "length": 6
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(_owner != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'newOwner' in function 'changeOwner' is not checked for zero address",
      "severity": "high",
      "location": {
        "line": 47,
        "column": 34,
        "length": 8
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(newOwner != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter '_owner' of type 'address' may need validation",
      "severity": "high",
      "location": {
        "line": 25,
        "column": 33,
        "length": 6
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(_owner != address(0), \"Invalid address\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'newOwner' of type 'address' may need validation",
      "severity": "high",
      "location": {
        "line": 47,
        "column": 34,
        "length": 8
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(newOwner != address(0), \"Invalid address\");",
        "replacements": []
      }
    },
    {
      "detector_id": "unchecked-external-call",
      "message": "External call in function 'withdraw' does not check return value",
      "severity": "medium",
      "location": {
        "line": 33,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-252",
      "fix_suggestion": {
        "description": "Check the return value of external calls in function 'withdraw'",
        "replacements": []
      }
    },
    {
      "detector_id": "unchecked-external-call",
      "message": "External call in function 'emergencyWithdraw' does not check return value",
      "severity": "medium",
      "location": {
        "line": 41,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-252",
      "fix_suggestion": {
        "description": "Check the return value of external calls in function 'emergencyWithdraw'",
        "replacements": []
      }
    },
    {
      "detector_id": "vault-withdrawal-dos",
      "message": "Function 'withdraw' may be vulnerable to withdrawal DOS attack. Withdrawal requires successful external call. Failing calls can permanently block withdrawals. Consider using pull-over-push pattern Attacker can block withdrawals, causing funds to be locked indefinitely.",
      "severity": "high",
      "location": {
        "line": 33,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Protect 'withdraw' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
        "replacements": []
      }
    },
    {
      "detector_id": "vault-withdrawal-dos",
      "message": "Function 'emergencyWithdraw' may be vulnerable to withdrawal DOS attack. No circuit breaker or emergency withdrawal mechanism. Vault cannot be paused during attacks or emergencies Attacker can block withdrawals, causing funds to be locked indefinitely.",
      "severity": "high",
      "location": {
        "line": 41,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Protect 'emergencyWithdraw' from withdrawal DOS. Solutions: (1) Implement withdrawal limits/caps per transaction (e.g., maxWithdrawal), (2) Add circuit breakers for emergency withdrawals (OpenZeppelin Pausable), (3) Avoid unbounded loops in withdrawal queue processing (add MAX_ITERATIONS), (4) Implement partial withdrawal support for queue processing, (5) Use pull-over-push pattern for failed withdrawals (mapping-based claims), (6) Consider EigenLayer-style withdrawal queue with delay mechanisms, (7) Add emergency pause mechanism for DOS situations, (8) Implement timelock for critical parameter changes.",
        "replacements": []
      }
    },
    {
      "detector_id": "vault-hook-reentrancy",
      "message": "Function 'withdraw' may be vulnerable to hook reentrancy attack. Uses raw transfer() instead of SafeERC20. No protection against malicious token implementations with callback hooks ERC-777/ERC-1363 token callbacks can re-enter and manipulate vault state.",
      "severity": "high",
      "location": {
        "line": 33,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Protect 'withdraw' from hook reentrancy. Solutions: (1) Add nonReentrant modifier from OpenZeppelin ReentrancyGuard, (2) Follow checks-effects-interactions (CEI) pattern strictly, (3) Update state BEFORE external calls with callbacks, (4) Validate token doesn't implement hooks (ERC-777/ERC-1363/callbacks), (5) Use reentrancy guard on all vault entry points, (6) Consider EIP-1153 transient storage for gas-efficient protection (Solidity 0.8.24+), (7) Use SafeERC20 wrapper library for token operations.",
        "replacements": []
      }
    },
    {
      "detector_id": "vault-hook-reentrancy",
      "message": "Function 'emergencyWithdraw' may be vulnerable to hook reentrancy attack. Uses raw transfer() instead of SafeERC20. No protection against malicious token implementations with callback hooks ERC-777/ERC-1363 token callbacks can re-enter and manipulate vault state.",
      "severity": "high",
      "location": {
        "line": 41,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Protect 'emergencyWithdraw' from hook reentrancy. Solutions: (1) Add nonReentrant modifier from OpenZeppelin ReentrancyGuard, (2) Follow checks-effects-interactions (CEI) pattern strictly, (3) Update state BEFORE external calls with callbacks, (4) Validate token doesn't implement hooks (ERC-777/ERC-1363/callbacks), (5) Use reentrancy guard on all vault entry points, (6) Consider EIP-1153 transient storage for gas-efficient protection (Solidity 0.8.24+), (7) Use SafeERC20 wrapper library for token operations.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'emergencyWithdraw' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 41,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'emergencyWithdraw'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function '' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 55,
        "column": 5,
        "length": 0
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in ''. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "gas-griefing",
      "message": "Function 'withdraw' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
      "severity": "medium",
      "location": {
        "line": 33,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Mitigate gas griefing in 'withdraw'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
        "replacements": []
      }
    },
    {
      "detector_id": "gas-griefing",
      "message": "Function 'emergencyWithdraw' has gas griefing vulnerability. Transfer without gas stipend, recipient can grief by consuming gas in fallback Attackers can force users to waste gas or cause transactions to fail.",
      "severity": "medium",
      "location": {
        "line": 41,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Mitigate gas griefing in 'emergencyWithdraw'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function 'initialize' contains excessive gas usage pattern. Multiple storage reads detected (5). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 25,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in 'initialize'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function 'withdraw' contains excessive gas usage pattern. Multiple storage reads detected (5). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 33,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in 'withdraw'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 21,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Function 'initialize' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 25,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Function 'withdraw' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 33,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "centralization-risk",
      "message": "Contract has centralization risk. Contract uses single owner without multi-signature protection. Single private key compromise leads to total contract control Single point of failure can lead to fund loss, governance attacks, or complete system compromise.",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-269",
      "fix_suggestion": {
        "description": "Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.",
        "replacements": []
      }
    },
    {
      "detector_id": "centralization-risk",
      "message": "Function 'emergencyWithdraw' has centralization risk. Emergency function 'emergencyWithdraw' lacks multi-party approval. Can be abused by single compromised key Critical function controlled by single address creates attack vector.",
      "severity": "high",
      "location": {
        "line": 41,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-269",
      "fix_suggestion": {
        "description": "Add decentralization to 'emergencyWithdraw'. Implement multi-signature requirements, timelock delays, or DAO governance for this critical function.",
        "replacements": []
      }
    },
    {
      "detector_id": "aa-initialization-vulnerability",
      "message": "Account abstraction initialization lacks signature verification. Initialization function lacks signature verification Missing signature verification allows anyone to initialize the account with arbitrary parameters, leading to account takeover.",
      "severity": "high",
      "location": {
        "line": 25,
        "column": 0,
        "length": 40
      },
      "cwe": "CWE-306",
      "fix_suggestion": {
        "description": "Implement secure initialization: (1) Add initWithSig function requiring user signature, (2) Verify signature matches expected owner, (3) Use nonce to prevent replay attacks, (4) Implement one-time initialization flag, (5) Consider ERC-4337 EntryPoint-only initialization.",
        "replacements": []
      }
    },
    {
      "detector_id": "aa-initialization-vulnerability",
      "message": "Initialization sets owner without validation. Owner assignment without address(0) check or signature verification Unvalidated owner parameter allows initialization with attacker-controlled address.",
      "severity": "high",
      "location": {
        "line": 48,
        "column": 0,
        "length": 40
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "Validate owner parameter: (1) Require owner != address(0), (2) Verify signature from owner address, (3) Emit OwnerSet event, (4) Consider two-step ownership transfer, (5) Validate owner in constructor or initWithSig.",
        "replacements": []
      }
    },
    {
      "detector_id": "guardian-role-centralization",
      "message": "Guardian role lacks explicit revocation mechanism - may be irremovable if compromised",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 1910
      },
      "fix_suggestion": {
        "description": "Implement guardian revocation function callable by DAO/owner for emergency scenarios",
        "replacements": []
      }
    },
    {
      "detector_id": "erc20-transfer-return-bomb",
      "message": "Token transfer lacks return data size validation - vulnerable to return bomb DOS",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 1910
      },
      "fix_suggestion": {
        "description": "Check returndatasize() and reject if excessive (>64 bytes): require(returndatasize() <= 64)",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-transaction-deadline",
      "message": "Function 'withdraw' is missing transaction deadline. Missing transaction deadline. Withdrawal operation 'withdraw' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed",
      "severity": "medium",
      "location": {
        "line": 33,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add deadline to 'withdraw'. Implement: (1) Add 'deadline' parameter: function withdraw(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-transaction-deadline",
      "message": "Function 'emergencyWithdraw' is missing transaction deadline. Missing transaction deadline. Withdrawal operation 'emergencyWithdraw' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed",
      "severity": "medium",
      "location": {
        "line": 41,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add deadline to 'emergencyWithdraw'. Implement: (1) Add 'deadline' parameter: function emergencyWithdraw(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users",
        "replacements": []
      }
    },
    {
      "detector_id": "lending-borrow-bypass",
      "message": "Lending protocol function 'emergencyWithdraw' has borrow bypass vulnerabilities: Collateral withdrawal doesn't validate health factor after removal, may allow withdrawal that causes undercollateralization",
      "severity": "critical",
      "location": {
        "line": 41,
        "column": 14,
        "length": 17
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Secure lending function 'emergencyWithdraw': Calculate and validate health factor before borrow, enforce collateral factor (LTV) limits, add reentrancy guards, implement same-block borrow restrictions for flash loans, update state before external calls (checks-effects-interactions pattern)",
        "replacements": []
      }
    },
    {
      "detector_id": "floating-pragma",
      "message": "Floating pragma detected: pragma solidity ^0.8.19;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.",
      "severity": "low",
      "location": {
        "line": 2,
        "column": 0,
        "length": 24
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Lock pragma to specific version: 'pragma solidity 0.8.19;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.",
        "replacements": []
      }
    },
    {
      "detector_id": "storage-layout-upgrade",
      "message": "Upgradeable contract missing storage gap (future upgrade will corrupt state)",
      "severity": "critical",
      "location": {
        "line": 0,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-1321",
      "fix_suggestion": {
        "description": "Add storage gap: uint256[50] private __gap; Reserve slots for future variables. This allows adding new state variables in future versions without corrupting storage layout.",
        "replacements": []
      }
    },
    {
      "detector_id": "storage-layout-upgrade",
      "message": "Initializer with state variables but no storage gap (upgrade blocker)",
      "severity": "critical",
      "location": {
        "line": 0,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-1321",
      "fix_suggestion": {
        "description": "Critical: Adding state variables in upgraded implementation will change storage layout. Add gap: uint256[50] private __gap; Reduce gap when adding new variables.",
        "replacements": []
      }
    },
    {
      "detector_id": "transient-storage-reentrancy",
      "message": "Classic reentrancy pattern with transient storage risk in 'withdraw'",
      "severity": "critical",
      "location": {
        "line": 33,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "State update after external call is vulnerable to reentrancy:\n\nCurrent pattern (VULNERABLE):\n1. Read balance\n2. Call transfer() ← attacker can reenter here with transient storage!\n3. Update balance to 0\n\nSecure pattern:\n1. Read balance\n2. Update balance to 0 ← do this FIRST\n3. Call transfer()\n\nWith EIP-1153, even 2300 gas is enough to modify transient state and re-enter.",
        "replacements": []
      }
    },
    {
      "detector_id": "transient-storage-reentrancy",
      "message": "Classic reentrancy pattern with transient storage risk in 'emergencyWithdraw'",
      "severity": "critical",
      "location": {
        "line": 41,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "State update after external call is vulnerable to reentrancy:\n\nCurrent pattern (VULNERABLE):\n1. Read balance\n2. Call transfer() ← attacker can reenter here with transient storage!\n3. Update balance to 0\n\nSecure pattern:\n1. Read balance\n2. Update balance to 0 ← do this FIRST\n3. Call transfer()\n\nWith EIP-1153, even 2300 gas is enough to modify transient state and re-enter.",
        "replacements": []
      }
    },
    {
      "detector_id": "logic-error-patterns",
      "message": "Potential division before multiplication - causes precision loss (OWASP 2025)",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "❌ PRECISION LOSS ($63.8M in losses):\nuint256 reward = (amount / totalSupply) * rewardRate;\n// Result: 0 if amount < totalSupply!\n\n✅ CORRECT ORDER:\nuint256 reward = (amount * rewardRate) / totalSupply;\n// Maximizes precision, multiply before divide\n\n✅ BEST: Use fixed-point math:\nuint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;\n\nReal incidents:\n- Cork Protocol: $11M (May 2025) - Division rounding\n- SIR.trading: $355K (March 2025) - Reward calculation\n- Multiple 2024 incidents: $63.8M total",
        "replacements": []
      }
    },
    {
      "detector_id": "enhanced-input-validation",
      "message": "Array access without length validation - can cause out-of-bounds access",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "❌ MISSING ARRAY VALIDATION (OWASP 2025 - $14.6M impact):\nfunction process(uint256[] calldata ids) external {\nfor (uint256 i = 0; i < ids.length; i++) {\n// What if ids is empty? Or too large?\n}\n}\n\n✅ VALIDATE ARRAY LENGTH:\nfunction process(uint256[] calldata ids) external {\n// Check minimum length\nrequire(ids.length > 0, \"Empty array\");\n\n// Check maximum length (prevent DoS)\nrequire(ids.length <= MAX_BATCH_SIZE, \"Batch too large\");\n\nfor (uint256 i = 0; i < ids.length; i++) {\n// Safe to access ids[i]\n}\n}\n\n✅ VALIDATE ARRAY MATCHING:\nfunction batchTransfer(\naddress[] calldata recipients,\nuint256[] calldata amounts\n) external {\n// Arrays must match in length\nrequire(\nrecipients.length == amounts.length,\n\"Length mismatch\"\n);\nrequire(recipients.length > 0, \"Empty arrays\");\nrequire(recipients.length <= MAX_BATCH, \"Too many\");\n\nfor (uint256 i = 0; i < recipients.length; i++) {\n// Safe parallel access\n}\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "enhanced-input-validation",
      "message": "Transfer function without zero-value check - validate non-zero amounts",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "❌ MISSING ZERO-VALUE CHECK:\nfunction transfer(address to, uint256 amount) external {\n_transfer(msg.sender, to, amount);\n// What if amount is 0? Wastes gas, may break accounting\n}\n\n✅ VALIDATE NON-ZERO:\nfunction transfer(address to, uint256 amount) external {\nrequire(amount > 0, \"Zero amount\");\nrequire(to != address(0), \"Zero address\");\n_transfer(msg.sender, to, amount);\n}\n\n✅ COMPLETE VALIDATION:\nfunction deposit(uint256 amount) external payable {\n// For ERC20 deposits\nrequire(amount > 0, \"Zero amount\");\nrequire(amount <= MAX_DEPOSIT, \"Exceeds maximum\");\n\n// For native ETH deposits\nif (msg.value > 0) {\nrequire(msg.value == amount, \"Value mismatch\");\n}\n\n// Proceed with deposit\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "enhanced-input-validation",
      "message": "Address parameter without zero-address validation",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "❌ MISSING ADDRESS VALIDATION:\nfunction setOwner(address newOwner) external {\nowner = newOwner;  // What if newOwner is address(0)?\n}\n\n✅ VALIDATE ADDRESS:\nfunction setOwner(address newOwner) external onlyOwner {\nrequire(newOwner != address(0), \"Zero address\");\nrequire(newOwner != owner, \"Same address\");\nowner = newOwner;\n}\n\n✅ VALIDATE MULTIPLE ADDRESSES:\nfunction initialize(\naddress _token,\naddress _oracle,\naddress _treasury\n) external {\nrequire(_token != address(0), \"Zero token\");\nrequire(_oracle != address(0), \"Zero oracle\");\nrequire(_treasury != address(0), \"Zero treasury\");\n\n// Check for duplicates if needed\nrequire(_token != _oracle, \"Token == oracle\");\nrequire(_token != _treasury, \"Token == treasury\");\n\ntoken = _token;\noracle = _oracle;\ntreasury = _treasury;\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "enhanced-access-control",
      "message": "Role-based access without admin role - who can grant/revoke roles?",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Every role should have a clear admin hierarchy:\n\n✅ DEFINE ROLE HIERARCHY:\nbytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\nbytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\nbytes32 public constant PAUSER_ROLE = keccak256(\"PAUSER_ROLE\");\nbytes32 public constant UPGRADER_ROLE = keccak256(\"UPGRADER_ROLE\");\n\nmapping(bytes32 => bytes32) private roleAdmin;\n\nconstructor() {\n// Set up role hierarchy\n_setRoleAdmin(MINTER_ROLE, DEFAULT_ADMIN_ROLE);\n_setRoleAdmin(PAUSER_ROLE, DEFAULT_ADMIN_ROLE);\n_setRoleAdmin(UPGRADER_ROLE, DEFAULT_ADMIN_ROLE);\n\n// Grant admin to deployer\n_grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n}\n\nfunction grantRole(bytes32 role, address account) public {\n// Only role admin can grant this role\nrequire(\nhasRole(roleAdmin[role], msg.sender),\n\"Not role admin\"\n);\n_grantRole(role, account);\n}\n\n✅ BEST PRACTICE - Document role hierarchy:\n/**\n* Role Hierarchy:\n* - DEFAULT_ADMIN_ROLE (0x00)\n*   └─ Can grant/revoke all roles\n*   └─ Should be multi-sig or governance\n* \n* - MINTER_ROLE\n*   └─ Can mint tokens\n*   └─ Granted to: Staking contract, Rewards contract\n* \n* - PAUSER_ROLE\n*   └─ Can pause/unpause contract\n*   └─ Granted to: Emergency multi-sig\n*/",
        "replacements": []
      }
    },
    {
      "detector_id": "jit-liquidity-sandwich",
      "message": "Liquidity removal without time-lock protection - vulnerable to JIT attacks",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 1910
      },
      "fix_suggestion": {
        "description": "Add a minimum lock time for liquidity positions (e.g., 1 block or epoch-based system) to prevent JIT liquidity attacks",
        "replacements": []
      }
    },
    {
      "detector_id": "jit-liquidity-sandwich",
      "message": "Liquidity becomes active immediately - may enable JIT sandwich attacks",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 1910
      },
      "fix_suggestion": {
        "description": "Consider delaying liquidity activation to the next epoch or block to mitigate JIT attacks",
        "replacements": []
      }
    },
    {
      "detector_id": "pool-donation-enhanced",
      "message": "No minimum deposit requirement - small deposits may round down to zero shares",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 1910
      },
      "fix_suggestion": {
        "description": "Enforce minimum deposit amount or minimum shares minted to prevent rounding attacks",
        "replacements": []
      }
    }
  ],
  "metadata": {
    "tool_name": "SolidityDefend",
    "tool_version": "1.3.6",
    "scan_type": "static_analysis",
    "language": "solidity",
    "rules_version": "1.3.6",
    "branding": {
      "name": "BlockSecOps",
      "url": "https://BlockSecOps.com",
      "description": "Enterprise-Grade DevSecOps Platform for Smart Contracts"
    }
  },
  "statistics": {
    "total_findings": 48,
    "severity_counts": {
      "critical": 10,
      "low": 6,
      "high": 20,
      "medium": 12,
      "info": 0
    },
    "unique_detectors": 26
  }
}