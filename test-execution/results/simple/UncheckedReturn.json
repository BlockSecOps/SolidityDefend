{
  "version": "1.3.6",
  "timestamp": "2025-11-17T22:52:09.126258Z",
  "findings": [
    {
      "detector_id": "missing-access-modifiers",
      "message": "Function 'distribute' performs critical operations but lacks access control modifiers",
      "severity": "critical",
      "location": {
        "line": 40,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier like 'onlyOwner' to function 'distribute'",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-access-modifiers",
      "message": "Function 'transferToken' performs critical operations but lacks access control modifiers",
      "severity": "critical",
      "location": {
        "line": 49,
        "column": 14,
        "length": 13
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier like 'onlyOwner' to function 'transferToken'",
        "replacements": []
      }
    },
    {
      "detector_id": "invalid-state-transition",
      "message": "State variables modified after external call - potential reentrancy affecting state machine",
      "severity": "critical",
      "location": {
        "line": 35,
        "column": 9,
        "length": 25
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Use checks-effects-interactions pattern or reentrancy guards",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'target' in function 'executeCode' is not checked for zero address",
      "severity": "high",
      "location": {
        "line": 33,
        "column": 34,
        "length": 6
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(target != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'token' in function 'transferToken' is not checked for zero address",
      "severity": "high",
      "location": {
        "line": 49,
        "column": 36,
        "length": 5
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(token != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'to' in function 'transferToken' is not checked for zero address",
      "severity": "high",
      "location": {
        "line": 49,
        "column": 51,
        "length": 2
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(to != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'target' of type 'address' may need validation",
      "severity": "low",
      "location": {
        "line": 33,
        "column": 34,
        "length": 6
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(target != address(0), \"Invalid address\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'recipients' of type 'array' may need validation",
      "severity": "medium",
      "location": {
        "line": 40,
        "column": 42,
        "length": 10
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(recipients.length > 0, \"Array cannot be empty\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'amount' of type 'uint' may need validation",
      "severity": "low",
      "location": {
        "line": 40,
        "column": 62,
        "length": 6
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(amount > 0, \"Amount must be positive\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'token' of type 'address' may need validation",
      "severity": "high",
      "location": {
        "line": 49,
        "column": 36,
        "length": 5
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(token != address(0), \"Invalid address\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'to' of type 'address' may need validation",
      "severity": "high",
      "location": {
        "line": 49,
        "column": 51,
        "length": 2
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(to != address(0), \"Invalid address\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'amount' of type 'uint' may need validation",
      "severity": "low",
      "location": {
        "line": 49,
        "column": 63,
        "length": 6
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(amount > 0, \"Amount must be positive\");",
        "replacements": []
      }
    },
    {
      "detector_id": "single-oracle-source",
      "message": "Function 'executeCode' relies on a single oracle source, creating centralization risk",
      "severity": "high",
      "location": {
        "line": 33,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-693",
      "fix_suggestion": {
        "description": "Use multiple oracle sources and implement price aggregation in function 'executeCode'",
        "replacements": []
      }
    },
    {
      "detector_id": "unchecked-external-call",
      "message": "External call in function 'executeCode' does not check return value",
      "severity": "medium",
      "location": {
        "line": 33,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-252",
      "fix_suggestion": {
        "description": "Check the return value of external calls in function 'executeCode'",
        "replacements": []
      }
    },
    {
      "detector_id": "test-governance",
      "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
      "severity": "high",
      "location": {
        "line": 23,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
        "replacements": []
      }
    },
    {
      "detector_id": "test-governance",
      "message": "Function 'executeCode' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.",
      "severity": "medium",
      "location": {
        "line": 33,
        "column": 0,
        "length": 11
      },
      "cwe": "CWE-662",
      "fix_suggestion": {
        "description": "Implement time-delayed voting rights requiring minimum holding periods.",
        "replacements": []
      }
    },
    {
      "detector_id": "external-calls-loop",
      "message": "Function 'distribute' contains external calls within loops. This can lead to DoS attacks if any external call fails or consumes excessive gas, and can be exploited in governance systems to block proposal execution.",
      "severity": "high",
      "location": {
        "line": 40,
        "column": 0,
        "length": 10
      },
      "cwe": "CWE-834",
      "fix_suggestion": {
        "description": "Avoid external calls in loops. Consider using a withdrawal pattern, batch processing, or fail-safe mechanisms for critical operations.",
        "replacements": []
      }
    },
    {
      "detector_id": "storage-collision",
      "message": "Function 'executeCode' uses delegatecall which can cause storage collision. Delegatecall to variable target without storage layout verification Delegatecall executes code in the context of the calling contract's storage, and mismatched storage layouts can corrupt state.",
      "severity": "critical",
      "location": {
        "line": 33,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-662",
      "fix_suggestion": {
        "description": "Ensure storage layout compatibility in 'executeCode'. Verify that delegatecall targets have identical storage layout, use storage slots explicitly, or implement storage layout versioning.",
        "replacements": []
      }
    },
    {
      "detector_id": "dangerous-delegatecall",
      "message": "Function 'executeCode' contains dangerous delegatecall pattern. Delegatecall target is controlled by function parameters or user input, allowing arbitrary code execution Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.",
      "severity": "critical",
      "location": {
        "line": 33,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-829",
      "fix_suggestion": {
        "description": "Restrict delegatecall target in 'executeCode'. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], \"Unauthorized target\");",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'distribute' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 40,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'distribute'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'transferToken' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 49,
        "column": 14,
        "length": 13
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'transferToken'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function '' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 61,
        "column": 5,
        "length": 0
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in ''. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "upgradeable-proxy-issues",
      "message": "Function 'executeCode' has upgradeable proxy vulnerability. Delegatecall without validating implementation address, can delegate to non-contract or malicious code Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.",
      "severity": "critical",
      "location": {
        "line": 33,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-665",
      "fix_suggestion": {
        "description": "Fix proxy implementation in 'executeCode'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.",
        "replacements": []
      }
    },
    {
      "detector_id": "circular-dependency",
      "message": "Function 'executeCode' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.",
      "severity": "high",
      "location": {
        "line": 33,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-674",
      "fix_suggestion": {
        "description": "Break circular dependency in 'executeCode'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.",
        "replacements": []
      }
    },
    {
      "detector_id": "circular-dependency",
      "message": "Function 'transferToken' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.",
      "severity": "high",
      "location": {
        "line": 49,
        "column": 14,
        "length": 13
      },
      "cwe": "CWE-674",
      "fix_suggestion": {
        "description": "Break circular dependency in 'transferToken'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.",
        "replacements": []
      }
    },
    {
      "detector_id": "gas-griefing",
      "message": "Function 'distribute' has gas griefing vulnerability. External call in loop without gas limit, attacker can grief by consuming all gas Attackers can force users to waste gas or cause transactions to fail.",
      "severity": "medium",
      "location": {
        "line": 40,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Mitigate gas griefing in 'distribute'. Use pull pattern for transfers, limit array sizes, add gas stipends, implement gas-efficient loops, avoid unbounded operations, use OpenZeppelin SafeERC20.",
        "replacements": []
      }
    },
    {
      "detector_id": "dos-unbounded-operation",
      "message": "Function 'distribute' has DOS vulnerability via unbounded operation. Loop over unbounded array without iteration limit, large arrays cause out-of-gas Can cause out-of-gas errors blocking contract functionality.",
      "severity": "high",
      "location": {
        "line": 40,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-834",
      "fix_suggestion": {
        "description": "Fix unbounded operation in 'distribute'. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.",
        "replacements": []
      }
    },
    {
      "detector_id": "dos-failed-transfer",
      "message": "Function 'distribute' uses push pattern for transfers which can cause DoS if recipient reverts. A malicious or buggy recipient contract can block this function by rejecting payments. Use the pull pattern (withdrawal pattern) instead where users withdraw their own funds.",
      "severity": "high",
      "location": {
        "line": 40,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-841",
      "fix_suggestion": {
        "description": "Refactor 'distribute' to use pull pattern instead of push. Store pending withdrawals in a mapping and let users withdraw their own funds. Example: balances[user] = amount; then separate withdraw() function. Use OpenZeppelin's PullPayment contract for reference.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function 'sendFunds' contains excessive gas usage pattern. Multiple storage reads detected (5). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 23,
        "column": 14,
        "length": 9
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in 'sendFunds'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function 'distribute' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 40,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in 'distribute'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Function 'sendFunds' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 23,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-input-validation",
      "message": "Function 'transferToken' missing input validation. Transfer/withdraw function lacks amount validation Missing validation can lead to unexpected behavior, zero address transfers, or invalid state.",
      "severity": "medium",
      "location": {
        "line": 49,
        "column": 14,
        "length": 13
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "Add input validation to 'transferToken'. Implement: (1) Zero address checks for address parameters, (2) Bounds validation for numeric inputs, (3) Array length validation, (4) require() statements at function start, (5) OpenZeppelin Address library for address validation.",
        "replacements": []
      }
    },
    {
      "detector_id": "hardware-wallet-delegation",
      "message": "Delegation contract missing recovery mechanism. No recovery mechanism found - users cannot undo delegation Without recovery, hardware wallet users lose access if delegation target is compromised or becomes incompatible.",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 40
      },
      "cwe": "CWE-672",
      "fix_suggestion": {
        "description": "Implement delegation recovery: (1) Add removeDelegation function, (2) Allow switching delegation targets, (3) Implement emergency mode fallback, (4) Support direct EOA transactions, (5) Require hardware wallet signature for changes.",
        "replacements": []
      }
    },
    {
      "detector_id": "hardware-wallet-delegation",
      "message": "Delegation gives full control over all EOA assets. Delegation allows unrestricted asset transfers without limits Unrestricted delegation allows malicious code to drain all ETH and tokens from hardware wallet.",
      "severity": "high",
      "location": {
        "line": 11,
        "column": 0,
        "length": 40
      },
      "cwe": "CWE-269",
      "fix_suggestion": {
        "description": "Limit delegation scope: (1) Implement per-asset spending limits, (2) Add transaction value restrictions, (3) Whitelist approved operations only, (4) Require two-step approval for large transfers, (5) Use time-locked withdrawal mechanisms.",
        "replacements": []
      }
    },
    {
      "detector_id": "hardware-wallet-delegation",
      "message": "Delegation target not validated for interface compatibility. Missing interface validation can cause hardware wallet to delegate to incompatible code, bricking the account.",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 40
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "Validate delegation target: (1) Check supportsInterface for EIP-165, (2) Verify required functions exist, (3) Test delegation in simulation first, (4) Implement delegation preview/confirmation, (5) Maintain whitelist of verified delegation targets.",
        "replacements": []
      }
    },
    {
      "detector_id": "erc20-transfer-return-bomb",
      "message": "Token transfer lacks return data size validation - vulnerable to return bomb DOS",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 2280
      },
      "fix_suggestion": {
        "description": "Check returndatasize() and reject if excessive (>64 bytes): require(returndatasize() <= 64)",
        "replacements": []
      }
    },
    {
      "detector_id": "erc20-transfer-return-bomb",
      "message": "Low-level call to token without gas limit - return bomb can exhaust all gas",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 2280
      },
      "fix_suggestion": {
        "description": "Specify gas limit for calls: token.call{gas: 100000}(abi.encodeWithSelector(...))",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-transaction-deadline",
      "message": "Function 'executeCode' is missing transaction deadline. Missing transaction deadline. Order execution operation 'executeCode' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed",
      "severity": "medium",
      "location": {
        "line": 33,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add deadline to 'executeCode'. Implement: (1) Add 'deadline' parameter: function executeCode(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users",
        "replacements": []
      }
    },
    {
      "detector_id": "floating-pragma",
      "message": "Floating pragma detected: pragma solidity ^0.8.19;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.",
      "severity": "low",
      "location": {
        "line": 2,
        "column": 0,
        "length": 24
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Lock pragma to specific version: 'pragma solidity 0.8.19;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.",
        "replacements": []
      }
    },
    {
      "detector_id": "proxy-storage-collision",
      "message": "Contract 'UncheckedReturn' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.",
      "severity": "high",
      "location": {
        "line": 18,
        "column": 10,
        "length": 15
      },
      "cwe": "CWE-1321",
      "fix_suggestion": {
        "description": "Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.",
        "replacements": []
      }
    },
    {
      "detector_id": "delegatecall-user-controlled",
      "message": "Function 'executeCode' performs delegatecall with user-controlled target. Delegatecall target is derived from function parameters or user input, allowing callers to specify arbitrary code to execute. This allows arbitrary code execution in the contract's storage context, enabling complete takeover and fund theft.",
      "severity": "critical",
      "location": {
        "line": 33,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-829",
      "fix_suggestion": {
        "description": "Remove user control over delegatecall target in 'executeCode'. Use a whitelist of approved addresses: mapping(address => bool) approvedTargets; Or avoid delegatecall entirely and use regular external calls.",
        "replacements": []
      }
    },
    {
      "detector_id": "delegatecall-return-ignored",
      "message": "Delegatecall in function 'executeCode' does not properly check return value. Delegatecall used as statement without capturing return value. Always capture: (bool success, bytes memory data) = target.delegatecall(...) Real-world impact: Silent failures can lead to state corruption, failed upgrades, and fund loss. Similar to issues in proxy contracts where failed initializations went undetected.",
      "severity": "high",
      "location": {
        "line": 33,
        "column": 14,
        "length": 11
      },
      "cwe": "CWE-252"
    },
    {
      "detector_id": "transient-storage-reentrancy",
      "message": "Vulnerable to transient storage reentrancy in 'distribute' - transfer()/send() no longer safe with EIP-1153",
      "severity": "critical",
      "location": {
        "line": 40,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "EIP-1153 breaks transfer()/send() safety assumption:\n\nCRITICAL: Transient storage (100 gas per TSTORE) allows reentrancy within\nthe 2300 gas stipend of transfer() and send().\n\nFix 1: Use checks-effects-interactions pattern\nfunction withdraw() public {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\n// ✅ Update state BEFORE external call\nbalances[msg.sender] = 0;\n\npayable(msg.sender).transfer(amount);\n}\n\nFix 2: Use ReentrancyGuard\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nfunction withdraw() public nonReentrant {\nuint256 amount = balances[msg.sender];\nrequire(amount > 0);\n\nbalances[msg.sender] = 0;\npayable(msg.sender).transfer(amount);\n}\n\nReference: ChainSecurity TSTORE Low Gas Reentrancy research (2024)",
        "replacements": []
      }
    },
    {
      "detector_id": "eip7702-delegate-access-control",
      "message": "Missing access control in 'executeCode' - allows arbitrary execution",
      "severity": "critical",
      "location": {
        "line": 33,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Fix: Add owner/authorization check:\n\naddress public owner;\n\nfunction execute(address target, bytes calldata data) external payable {\nrequire(msg.sender == owner, \"Not authorized\");\n(bool success, ) = target.call{value: msg.value}(data);\nrequire(success, \"Call failed\");\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "eip7702-storage-collision",
      "message": "EIP-7702 delegate uses storage - verify no collision with EOA state",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Use EIP-7201 namespaced storage to avoid collisions:\n\nbytes32 private constant STORAGE_LOCATION = \nkeccak256(\"myprotocol.delegate.storage\");\n\nstruct DelegateStorage {\naddress owner;\nmapping(address => uint256) balances;\n}\n\nfunction _getStorage() private pure returns (DelegateStorage storage $) {\nassembly { $.slot := STORAGE_LOCATION }\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "logic-error-patterns",
      "message": "Potential division before multiplication - causes precision loss (OWASP 2025)",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "❌ PRECISION LOSS ($63.8M in losses):\nuint256 reward = (amount / totalSupply) * rewardRate;\n// Result: 0 if amount < totalSupply!\n\n✅ CORRECT ORDER:\nuint256 reward = (amount * rewardRate) / totalSupply;\n// Maximizes precision, multiply before divide\n\n✅ BEST: Use fixed-point math:\nuint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;\n\nReal incidents:\n- Cork Protocol: $11M (May 2025) - Division rounding\n- SIR.trading: $355K (March 2025) - Reward calculation\n- Multiple 2024 incidents: $63.8M total",
        "replacements": []
      }
    },
    {
      "detector_id": "enhanced-input-validation",
      "message": "Transfer function without zero-value check - validate non-zero amounts",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "❌ MISSING ZERO-VALUE CHECK:\nfunction transfer(address to, uint256 amount) external {\n_transfer(msg.sender, to, amount);\n// What if amount is 0? Wastes gas, may break accounting\n}\n\n✅ VALIDATE NON-ZERO:\nfunction transfer(address to, uint256 amount) external {\nrequire(amount > 0, \"Zero amount\");\nrequire(to != address(0), \"Zero address\");\n_transfer(msg.sender, to, amount);\n}\n\n✅ COMPLETE VALIDATION:\nfunction deposit(uint256 amount) external payable {\n// For ERC20 deposits\nrequire(amount > 0, \"Zero amount\");\nrequire(amount <= MAX_DEPOSIT, \"Exceeds maximum\");\n\n// For native ETH deposits\nif (msg.value > 0) {\nrequire(msg.value == amount, \"Value mismatch\");\n}\n\n// Proceed with deposit\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "enhanced-input-validation",
      "message": "Address parameter without zero-address validation",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "❌ MISSING ADDRESS VALIDATION:\nfunction setOwner(address newOwner) external {\nowner = newOwner;  // What if newOwner is address(0)?\n}\n\n✅ VALIDATE ADDRESS:\nfunction setOwner(address newOwner) external onlyOwner {\nrequire(newOwner != address(0), \"Zero address\");\nrequire(newOwner != owner, \"Same address\");\nowner = newOwner;\n}\n\n✅ VALIDATE MULTIPLE ADDRESSES:\nfunction initialize(\naddress _token,\naddress _oracle,\naddress _treasury\n) external {\nrequire(_token != address(0), \"Zero token\");\nrequire(_oracle != address(0), \"Zero oracle\");\nrequire(_treasury != address(0), \"Zero treasury\");\n\n// Check for duplicates if needed\nrequire(_token != _oracle, \"Token == oracle\");\nrequire(_token != _treasury, \"Token == treasury\");\n\ntoken = _token;\noracle = _oracle;\ntreasury = _treasury;\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "post-080-overflow",
      "message": "Unchecked block found - overflows/underflows won't revert (OWASP 2025)",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "⚠️ UNCHECKED BLOCKS BYPASS SOLIDITY 0.8.0+ PROTECTION!\n\nSolidity 0.8.0+ has automatic overflow/underflow checks,\nbut 'unchecked' blocks disable this protection.\n\n❌ DANGEROUS if user input involved:\nunchecked {\nbalance += amount;  // Can overflow!\ntotal = a * b;      // Can overflow!\n}\n\n✅ SAFE usage (loop counters only):\nfor (uint256 i = 0; i < items.length;) {\n// Process items[i]\n\nunchecked {\n++i;  // Safe: loop counter can't realistically overflow\n}\n}\n\n✅ SAFE usage (guaranteed no overflow):\nunchecked {\n// Safe: subtraction after comparison\nif (a >= b) {\nresult = a - b;  // No underflow possible\n}\n}\n\n❌ NEVER use unchecked for:\n- User-supplied values\n- Token amounts\n- Financial calculations\n- Multiplication of arbitrary values\n\nOnly use unchecked when:\n1. Loop counters (i++, ++i)\n2. Mathematically proven safe\n3. Gas optimization with careful review",
        "replacements": []
      }
    },
    {
      "detector_id": "jit-liquidity-sandwich",
      "message": "Liquidity becomes active immediately - may enable JIT sandwich attacks",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 2280
      },
      "fix_suggestion": {
        "description": "Consider delaying liquidity activation to the next epoch or block to mitigate JIT attacks",
        "replacements": []
      }
    },
    {
      "detector_id": "pool-donation-enhanced",
      "message": "No minimum deposit requirement - small deposits may round down to zero shares",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 2280
      },
      "fix_suggestion": {
        "description": "Enforce minimum deposit amount or minimum shares minted to prevent rounding attacks",
        "replacements": []
      }
    }
  ],
  "metadata": {
    "tool_name": "SolidityDefend",
    "tool_version": "1.3.6",
    "scan_type": "static_analysis",
    "language": "solidity",
    "rules_version": "1.3.6",
    "branding": {
      "name": "BlockSecOps",
      "url": "https://BlockSecOps.com",
      "description": "Enterprise-Grade DevSecOps Platform for Smart Contracts"
    }
  },
  "statistics": {
    "total_findings": 51,
    "severity_counts": {
      "medium": 12,
      "low": 7,
      "high": 23,
      "info": 0,
      "critical": 9
    },
    "unique_detectors": 34
  }
}