{
  "version": "1.3.6",
  "timestamp": "2025-11-18T18:34:47.223147Z",
  "findings": [
    {
      "detector_id": "missing-access-modifiers",
      "message": "Function 'changeThreshold' performs critical operations but lacks access control modifiers",
      "severity": "critical",
      "location": {
        "line": 55,
        "column": 14,
        "length": 15
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier like 'onlyOwner' to function 'changeThreshold'",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-access-modifiers",
      "message": "Function 'addOwner' performs critical operations but lacks access control modifiers",
      "severity": "critical",
      "location": {
        "line": 63,
        "column": 14,
        "length": 8
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier like 'onlyOwner' to function 'addOwner'",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'to' in function 'executeTransaction' is not checked for zero address",
      "severity": "high",
      "location": {
        "line": 35,
        "column": 17,
        "length": 2
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(to != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'owner' in function 'addOwner' is not checked for zero address",
      "severity": "high",
      "location": {
        "line": 63,
        "column": 31,
        "length": 5
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(owner != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'to' of type 'address' may need validation",
      "severity": "low",
      "location": {
        "line": 35,
        "column": 17,
        "length": 2
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(to != address(0), \"Invalid address\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'value' of type 'uint' may need validation",
      "severity": "low",
      "location": {
        "line": 36,
        "column": 17,
        "length": 5
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "Add appropriate range validation for value",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'owner' of type 'address' may need validation",
      "severity": "high",
      "location": {
        "line": 63,
        "column": 31,
        "length": 5
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(owner != address(0), \"Invalid address\");",
        "replacements": []
      }
    },
    {
      "detector_id": "test-governance",
      "message": "Contract uses governance tokens without snapshot protection mechanisms. This enables flash loan attacks where attackers can temporarily acquire tokens to manipulate governance decisions.",
      "severity": "high",
      "location": {
        "line": 24,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Implement snapshot-based voting power using block-based or time-based snapshots.",
        "replacements": []
      }
    },
    {
      "detector_id": "test-governance",
      "message": "Function 'executeTransaction' lacks time-delay protection for governance actions. New token holders can immediately use their voting power, enabling flash loan governance attacks.",
      "severity": "medium",
      "location": {
        "line": 34,
        "column": 0,
        "length": 18
      },
      "cwe": "CWE-662",
      "fix_suggestion": {
        "description": "Implement time-delayed voting rights requiring minimum holding periods.",
        "replacements": []
      }
    },
    {
      "detector_id": "signature-replay",
      "message": "Function 'recoverSigner' verifies signatures without replay protection. Attackers can reuse valid signatures to perform unauthorized actions. This is particularly dangerous in governance systems for vote manipulation.",
      "severity": "high",
      "location": {
        "line": 68,
        "column": 0,
        "length": 13
      },
      "cwe": "CWE-294",
      "fix_suggestion": {
        "description": "Implement a nonce system to prevent signature replay attacks. Include a unique nonce in the signed message and track used nonces.",
        "replacements": []
      }
    },
    {
      "detector_id": "cross-chain-replay",
      "message": "Function 'executeTransaction' generates hash/signature without chain ID protection. This allows the same signature to be replayed on different chains, potentially draining funds on all supported chains.",
      "severity": "critical",
      "location": {
        "line": 34,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-294",
      "fix_suggestion": {
        "description": "Include 'block.chainid' in the hash calculation for function 'executeTransaction'. Example: keccak256(abi.encodePacked(..., block.chainid))",
        "replacements": []
      }
    },
    {
      "detector_id": "dangerous-delegatecall",
      "message": "Function '' contains dangerous delegatecall pattern. Delegatecall is performed without proper access control, potentially accessible by any caller Delegatecall executes arbitrary code in the context of the current contract, allowing complete control over contract state and funds.",
      "severity": "critical",
      "location": {
        "line": 78,
        "column": 5,
        "length": 0
      },
      "cwe": "CWE-829",
      "fix_suggestion": {
        "description": "Restrict delegatecall target in ''. Use whitelist of approved addresses, implement access control, or avoid delegatecall entirely. Example: mapping(address => bool) public approvedTargets; require(approvedTargets[target], \"Unauthorized target\");",
        "replacements": []
      }
    },
    {
      "detector_id": "signature-malleability",
      "message": "Function 'recoverSigner' uses ECDSA signature verification without malleability protection. Uses ecrecover without checking 's' value against secp256k1 curve order ECDSA signatures have two valid forms (s and -s mod n). Without checking that s is in the lower half range, attackers can create alternate valid signatures for replay attacks.",
      "severity": "high",
      "location": {
        "line": 68,
        "column": 14,
        "length": 13
      },
      "cwe": "CWE-347",
      "fix_suggestion": {
        "description": "Add signature malleability check in 'recoverSigner'. Use OpenZeppelin's ECDSA library or add: `require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid signature 's' value\");` This ensures s is in the lower half of the curve order.",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-eip712-domain",
      "message": "Function 'recoverSigner' Uses ecrecover() without proper EIP-712 domain separator. Signatures are vulnerable to replay attacks across contracts and chains.",
      "severity": "high",
      "location": {
        "line": 68,
        "column": 14,
        "length": 13
      },
      "cwe": "CWE-345",
      "fix_suggestion": {
        "description": "Implement proper EIP-712 domain separator:\n1. Define DOMAIN_SEPARATOR with all required fields (name, version, chainId, verifyingContract)\n2. Use structured data hashing with EIP-712\n3. Include domain separator in signature hash: keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, structHash))\n4. Or use OpenZeppelin's EIP712 implementation",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'executeTransaction' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 34,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'executeTransaction'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "nonce-reuse",
      "message": "Function 'executeTransaction' has nonce management vulnerability. Nonce reuse vulnerability marker detected Improper nonce handling enables replay attacks or transaction reordering exploits.",
      "severity": "medium",
      "location": {
        "line": 34,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-294",
      "fix_suggestion": {
        "description": "Fix nonce management in 'executeTransaction'. Increment nonce after validation, use mapping(address => uint256) for per-user nonces, validate nonce before execution, include nonce in signature hash, and implement nonce cancellation mechanism.",
        "replacements": []
      }
    },
    {
      "detector_id": "upgradeable-proxy-issues",
      "message": "Function '' has upgradeable proxy vulnerability. Delegatecall without validating implementation address, can delegate to non-contract or malicious code Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.",
      "severity": "critical",
      "location": {
        "line": 78,
        "column": 5,
        "length": 0
      },
      "cwe": "CWE-665",
      "fix_suggestion": {
        "description": "Fix proxy implementation in ''. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.",
        "replacements": []
      }
    },
    {
      "detector_id": "circular-dependency",
      "message": "Function 'executeTransaction' has circular dependency vulnerability. External contract calls without depth limit, circular calls can cause stack overflow Circular dependencies can cause stack overflow, DOS attacks, or make contracts unupgradeable.",
      "severity": "high",
      "location": {
        "line": 34,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-674",
      "fix_suggestion": {
        "description": "Break circular dependency in 'executeTransaction'. Use events instead of callbacks, implement depth limits for recursive calls, add reentrancy guards, use pull pattern instead of push, implement circuit breakers, and add visited tracking for graph traversal.",
        "replacements": []
      }
    },
    {
      "detector_id": "dos-unbounded-operation",
      "message": "Function '' has DOS vulnerability via unbounded operation. Loop over unbounded array without iteration limit, large arrays cause out-of-gas Can cause out-of-gas errors blocking contract functionality.",
      "severity": "high",
      "location": {
        "line": 24,
        "column": 5,
        "length": 0
      },
      "cwe": "CWE-834",
      "fix_suggestion": {
        "description": "Fix unbounded operation in ''. Add pagination for large loops, implement maximum iteration limits, use pull pattern instead of push, add circuit breakers, batch operations.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function '' contains excessive gas usage pattern. Storage write operation inside loop. Consider using memory array Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 24,
        "column": 5,
        "length": 0
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in ''. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function '' contains excessive gas usage pattern. Array length read in every loop iteration. Cache length in local variable Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 24,
        "column": 5,
        "length": 0
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in ''. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Function 'addOwner' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 63,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'recoverSigner' contains variable shadowing. Local variable 'r' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 68,
        "column": 14,
        "length": 13
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'recoverSigner'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function '' contains variable shadowing. Local variable '_singleton' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 78,
        "column": 5,
        "length": 0
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in ''. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "hardware-wallet-delegation",
      "message": "Delegation target not validated for interface compatibility. Missing interface validation can cause hardware wallet to delegate to incompatible code, bricking the account.",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 40
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "Validate delegation target: (1) Check supportsInterface for EIP-165, (2) Verify required functions exist, (3) Test delegation in simulation first, (4) Implement delegation preview/confirmation, (5) Maintain whitelist of verified delegation targets.",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-transaction-deadline",
      "message": "Function 'executeTransaction' is missing transaction deadline. Missing transaction deadline. Order execution operation 'executeTransaction' has no deadline parameter or expiration validation. Transaction can be executed at any time, potentially at unfavorable conditions This allows MEV bots to delay execution for profit, transactions to execute at stale prices, and users to lose funds due to unfavorable timing. Transactions sitting in mempool can be executed when conditions have significantly changed",
      "severity": "medium",
      "location": {
        "line": 34,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Add deadline to 'executeTransaction'. Implement: (1) Add 'deadline' parameter: function executeTransaction(... uint256 deadline); (2) Validate deadline: require(block.timestamp <= deadline, 'Transaction expired'); (3) For orders: Store expiration and check on execution; (4) Use reasonable deadline in frontend: block.timestamp + 15 minutes; (5) For batch operations: Apply deadline to entire batch; (6) Document deadline behavior for users",
        "replacements": []
      }
    },
    {
      "detector_id": "floating-pragma",
      "message": "Floating pragma detected: pragma solidity ^0.8.19;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.",
      "severity": "low",
      "location": {
        "line": 2,
        "column": 0,
        "length": 24
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Lock pragma to specific version: 'pragma solidity 0.8.19;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-data-availability",
      "message": "Function 'executeTransaction' processes transactions without censorship resistance. Missing timeout mechanism. Should allow force inclusion after sequencer fails to include transaction Lack of force inclusion allows sequencer to censor user transactions indefinitely.",
      "severity": "high",
      "location": {
        "line": 34,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add censorship resistance to 'executeTransaction': (1) Implement force inclusion mechanism via L1, (2) Add timeout after which users can include their own transactions, (3) Track pending L1 to L2 messages with timestamps, (4) Allow anyone to execute forced inclusion after timeout, (5) Emit events for forced inclusion requests.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-data-availability",
      "message": "Function 'executeTransaction' processes transactions without censorship resistance. No message queue detected. Should implement L1 to L2 message queue for force inclusion Lack of force inclusion allows sequencer to censor user transactions indefinitely.",
      "severity": "high",
      "location": {
        "line": 34,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add censorship resistance to 'executeTransaction': (1) Implement force inclusion mechanism via L1, (2) Add timeout after which users can include their own transactions, (3) Track pending L1 to L2 messages with timestamps, (4) Allow anyone to execute forced inclusion after timeout, (5) Emit events for forced inclusion requests.",
        "replacements": []
      }
    },
    {
      "detector_id": "l2-data-availability",
      "message": "Function 'executeTransaction' processes transactions without censorship resistance. No force inclusion mechanism. Users need ability to include transactions via L1 if sequencer censors Lack of force inclusion allows sequencer to censor user transactions indefinitely.",
      "severity": "high",
      "location": {
        "line": 34,
        "column": 14,
        "length": 18
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add censorship resistance to 'executeTransaction': (1) Implement force inclusion mechanism via L1, (2) Add timeout after which users can include their own transactions, (3) Track pending L1 to L2 messages with timestamps, (4) Allow anyone to execute forced inclusion after timeout, (5) Emit events for forced inclusion requests.",
        "replacements": []
      }
    },
    {
      "detector_id": "proxy-storage-collision",
      "message": "Contract 'GnosisSafeProxyVulnerable' has potential proxy storage collision vulnerability. Proxy contract declares storage variables without using EIP-1967 slots, risking collision with implementation contract storage. Storage collisions can corrupt critical state variables and lead to fund loss.",
      "severity": "high",
      "location": {
        "line": 18,
        "column": 10,
        "length": 25
      },
      "cwe": "CWE-1321",
      "fix_suggestion": {
        "description": "Use EIP-1967 standard storage slots for proxy-specific variables. Reserve storage slots using 'bytes32 private constant SLOT = keccak256(...)'. Avoid declaring storage variables at the beginning of proxy contracts. Use upgradeable patterns like OpenZeppelin's transparent proxy.",
        "replacements": []
      }
    },
    {
      "detector_id": "fallback-delegatecall-unprotected",
      "message": "Function '' performs delegatecall in fallback/receive without access control. Fallback/receive function performs delegatecall without validating the caller. Any address can trigger this by calling a non-existent function or sending ETH. This allows any caller to execute arbitrary code by calling non-existent functions or sending ETH to the contract.",
      "severity": "high",
      "location": {
        "line": 78,
        "column": 5,
        "length": 0
      },
      "cwe": "CWE-829",
      "fix_suggestion": {
        "description": "Add access control to fallback function ''. Validate implementation address before delegatecall. Use modifiers like 'onlyOwner' or check msg.sender explicitly. Consider using OpenZeppelin's transparent or UUPS proxy patterns.",
        "replacements": []
      }
    },
    {
      "detector_id": "multisig-bypass",
      "message": "Missing signature malleability protection (duplicate signature acceptance)",
      "severity": "high",
      "location": {
        "line": 0,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-347",
      "fix_suggestion": {
        "description": "Check s-value: require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"Invalid s-value\"); This prevents signature malleability.",
        "replacements": []
      }
    },
    {
      "detector_id": "multisig-bypass",
      "message": "Missing domain separator in signature hash (cross-contract/chain replay)",
      "severity": "medium",
      "location": {
        "line": 0,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-347",
      "fix_suggestion": {
        "description": "Include domain separator: bytes32 domainSeparator = keccak256(abi.encode(TYPEHASH, address(this), block.chainid)); bytes32 hash = keccak256(abi.encodePacked(domainSeparator, data));",
        "replacements": []
      }
    },
    {
      "detector_id": "multisig-bypass",
      "message": "Signatures without expiration/deadline (indefinite validity risk)",
      "severity": "medium",
      "location": {
        "line": 0,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-347",
      "fix_suggestion": {
        "description": "Add expiration: Include deadline in signature data; require(block.timestamp <= deadline, \"Signature expired\"); Prevents execution of stale signatures.",
        "replacements": []
      }
    },
    {
      "detector_id": "multisig-bypass",
      "message": "Missing zero address check after ecrecover (invalid signature counts as address(0))",
      "severity": "high",
      "location": {
        "line": 0,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-347",
      "fix_suggestion": {
        "description": "Validate signer: address signer = ecrecover(hash, v, r, s); require(signer != address(0) && isOwner[signer], \"Invalid signature\");",
        "replacements": []
      }
    },
    {
      "detector_id": "eip7702-delegate-access-control",
      "message": "Missing access control in 'executeTransaction' - allows arbitrary execution",
      "severity": "critical",
      "location": {
        "line": 34,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Fix: Add owner/authorization check:\n\naddress public owner;\n\nfunction execute(address target, bytes calldata data) external payable {\nrequire(msg.sender == owner, \"Not authorized\");\n(bool success, ) = target.call{value: msg.value}(data);\nrequire(success, \"Call failed\");\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "eip7702-storage-collision",
      "message": "EIP-7702 delegate uses storage - verify no collision with EOA state",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Use EIP-7201 namespaced storage to avoid collisions:\n\nbytes32 private constant STORAGE_LOCATION = \nkeccak256(\"myprotocol.delegate.storage\");\n\nstruct DelegateStorage {\naddress owner;\nmapping(address => uint256) balances;\n}\n\nfunction _getStorage() private pure returns (DelegateStorage storage $) {\nassembly { $.slot := STORAGE_LOCATION }\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "logic-error-patterns",
      "message": "Potential division before multiplication - causes precision loss (OWASP 2025)",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "‚ùå PRECISION LOSS ($63.8M in losses):\nuint256 reward = (amount / totalSupply) * rewardRate;\n// Result: 0 if amount < totalSupply!\n\n‚úÖ CORRECT ORDER:\nuint256 reward = (amount * rewardRate) / totalSupply;\n// Maximizes precision, multiply before divide\n\n‚úÖ BEST: Use fixed-point math:\nuint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;\n\nReal incidents:\n- Cork Protocol: $11M (May 2025) - Division rounding\n- SIR.trading: $355K (March 2025) - Reward calculation\n- Multiple 2024 incidents: $63.8M total",
        "replacements": []
      }
    },
    {
      "detector_id": "enhanced-input-validation",
      "message": "Transfer function without zero-value check - validate non-zero amounts",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "‚ùå MISSING ZERO-VALUE CHECK:\nfunction transfer(address to, uint256 amount) external {\n_transfer(msg.sender, to, amount);\n// What if amount is 0? Wastes gas, may break accounting\n}\n\n‚úÖ VALIDATE NON-ZERO:\nfunction transfer(address to, uint256 amount) external {\nrequire(amount > 0, \"Zero amount\");\nrequire(to != address(0), \"Zero address\");\n_transfer(msg.sender, to, amount);\n}\n\n‚úÖ COMPLETE VALIDATION:\nfunction deposit(uint256 amount) external payable {\n// For ERC20 deposits\nrequire(amount > 0, \"Zero amount\");\nrequire(amount <= MAX_DEPOSIT, \"Exceeds maximum\");\n\n// For native ETH deposits\nif (msg.value > 0) {\nrequire(msg.value == amount, \"Value mismatch\");\n}\n\n// Proceed with deposit\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "enhanced-input-validation",
      "message": "Address parameter without zero-address validation",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "‚ùå MISSING ADDRESS VALIDATION:\nfunction setOwner(address newOwner) external {\nowner = newOwner;  // What if newOwner is address(0)?\n}\n\n‚úÖ VALIDATE ADDRESS:\nfunction setOwner(address newOwner) external onlyOwner {\nrequire(newOwner != address(0), \"Zero address\");\nrequire(newOwner != owner, \"Same address\");\nowner = newOwner;\n}\n\n‚úÖ VALIDATE MULTIPLE ADDRESSES:\nfunction initialize(\naddress _token,\naddress _oracle,\naddress _treasury\n) external {\nrequire(_token != address(0), \"Zero token\");\nrequire(_oracle != address(0), \"Zero oracle\");\nrequire(_treasury != address(0), \"Zero treasury\");\n\n// Check for duplicates if needed\nrequire(_token != _oracle, \"Token == oracle\");\nrequire(_token != _treasury, \"Token == treasury\");\n\ntoken = _token;\noracle = _oracle;\ntreasury = _treasury;\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "post-080-overflow",
      "message": "Assembly arithmetic detected - no overflow protection! ($223M Cetus DEX)",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "üö® CRITICAL: Assembly has NO overflow protection!\n\nReal incident: Cetus DEX - $223M loss (May 2025)\nCause: Assembly arithmetic overflow\n\n‚ùå VULNERABLE (Cetus-style vulnerability):\nassembly {\nlet result := add(a, b)  // NO OVERFLOW CHECK!\nlet product := mul(x, y) // NO OVERFLOW CHECK!\nmstore(0x00, result)\n}\n\n‚úÖ SOLUTION 1 - Add manual checks:\nassembly {\nlet result := add(a, b)\n// Manual overflow check\nif lt(result, a) {\nrevert(0, 0)  // Overflow detected\n}\n}\n\n‚úÖ SOLUTION 2 - Use Solidity instead:\n// Let Solidity handle overflow checks\nuint256 result = a + b;  // Automatic overflow check\n\n‚úÖ SOLUTION 3 - SafeMath for assembly:\nfunction safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\nuint256 c;\nassembly {\nc := add(a, b)\n}\nrequire(c >= a, \"Overflow\");  // Check outside assembly\nreturn c;\n}\n\nAssembly arithmetic operations with NO checks:\n- add(a, b)     ‚Üí wraps on overflow\n- sub(a, b)     ‚Üí wraps on underflow\n- mul(a, b)     ‚Üí wraps on overflow\n- div(a, b)     ‚Üí returns 0 if b is 0 (no revert!)\n\n‚ö†Ô∏è Only use assembly arithmetic when absolutely necessary\nand with manual overflow checks!",
        "replacements": []
      }
    },
    {
      "detector_id": "post-080-overflow",
      "message": "Type casting to smaller uint - verify no overflow on downcast",
      "severity": "low",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "Downcasting can silently overflow even in Solidity 0.8.0+!\n\n‚ùå UNSAFE DOWNCAST:\nuint256 bigValue = 1000;\nuint8 smallValue = uint8(bigValue);  // Wraps to 232! (1000 % 256)\n\n‚úÖ SAFE DOWNCAST with validation:\nuint256 bigValue = 1000;\nrequire(bigValue <= type(uint8).max, \"Value too large\");\nuint8 smallValue = uint8(bigValue);  // Safe now\n\n‚úÖ USE SafeCast library (OpenZeppelin):\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nuint256 bigValue = 1000;\nuint8 smallValue = SafeCast.toUint8(bigValue);  // Reverts if > 255\n\nType limits:\n- uint8:   0 to 255\n- uint16:  0 to 65,535\n- uint32:  0 to 4,294,967,295\n- uint64:  0 to 18,446,744,073,709,551,615\n- uint256: 0 to 2^256-1",
        "replacements": []
      }
    }
  ],
  "metadata": {
    "tool_name": "SolidityDefend",
    "tool_version": "1.3.6",
    "scan_type": "static_analysis",
    "language": "solidity",
    "rules_version": "1.3.6",
    "branding": {
      "name": "BlockSecOps",
      "url": "https://BlockSecOps.com",
      "description": "Enterprise-Grade DevSecOps Platform for Smart Contracts"
    }
  },
  "statistics": {
    "total_findings": 43,
    "severity_counts": {
      "critical": 6,
      "info": 0,
      "high": 20,
      "medium": 10,
      "low": 7
    },
    "unique_detectors": 29
  }
}