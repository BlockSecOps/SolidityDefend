{
  "version": "1.3.6",
  "timestamp": "2025-11-18T16:27:51.353580Z",
  "findings": [
    {
      "detector_id": "missing-access-modifiers",
      "message": "Function 'initialize' performs critical operations but lacks access control modifiers",
      "severity": "critical",
      "location": {
        "line": 26,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier like 'onlyOwner' to function 'initialize'",
        "replacements": []
      }
    },
    {
      "detector_id": "unprotected-initializer",
      "message": "Initializer function 'initialize' lacks access control and can be called by anyone",
      "severity": "high",
      "location": {
        "line": 26,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier to 'initialize' or ensure it can only be called once during deployment",
        "replacements": []
      }
    },
    {
      "detector_id": "invalid-state-transition",
      "message": "State variable 'paused' is modified without proper validation or state checks",
      "severity": "high",
      "location": {
        "line": 29,
        "column": 9,
        "length": 14
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "Add proper validation before modifying state variables",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter '_owner' in function 'initialize' is not checked for zero address",
      "severity": "high",
      "location": {
        "line": 26,
        "column": 33,
        "length": 6
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(_owner != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-zero-address-check",
      "message": "Address parameter 'to' in function 'mint' is not checked for zero address",
      "severity": "high",
      "location": {
        "line": 32,
        "column": 27,
        "length": 2
      },
      "cwe": "CWE-476",
      "fix_suggestion": {
        "description": "Add require(to != address(0), \"Zero address not allowed\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter '_owner' of type 'address' may need validation",
      "severity": "high",
      "location": {
        "line": 26,
        "column": 33,
        "length": 6
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(_owner != address(0), \"Invalid address\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'to' of type 'address' may need validation",
      "severity": "low",
      "location": {
        "line": 32,
        "column": 27,
        "length": 2
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(to != address(0), \"Invalid address\");",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'amount' of type 'uint' may need validation",
      "severity": "low",
      "location": {
        "line": 32,
        "column": 39,
        "length": 6
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "require(amount > 0, \"Amount must be positive\");",
        "replacements": []
      }
    },
    {
      "detector_id": "vault-share-inflation",
      "message": "Function 'mint' may be vulnerable to vault share inflation attack. No minimum deposit amount enforced, allowing 1 wei deposit that can be used for share price manipulation First depositor can manipulate share price by depositing 1 wei, donating assets directly to vault, causing rounding errors that steal from subsequent depositors.",
      "severity": "critical",
      "location": {
        "line": 32,
        "column": 14,
        "length": 4
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Protect 'mint' from share inflation attack. Solutions: (1) Mint initial shares to zero address on deployment (dead shares - Uniswap V2 pattern), (2) Implement virtual shares/assets (OpenZeppelin ERC4626 with decimalsOffset), (3) Enforce minimum first deposit amount (>= 1e6 recommended), (4) Use higher precision decimals (1e18 instead of 1e6), (5) Track assets internally instead of using balanceOf, (6) Consider EigenLayer delegation pattern for restaking vaults.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'initialize' has extractable MEV. State changes to global state (totalSupply/reserves/price) visible in public mempool, allowing MEV bots to react and extract value Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 26,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'initialize'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-extractable-value",
      "message": "Function 'mint' has extractable MEV. Public function with value transfer lacks MEV protection (no slippage/deadline checks), enabling front-running and back-running attacks Searchers can extract value through transaction ordering, front-running, or back-running.",
      "severity": "high",
      "location": {
        "line": 32,
        "column": 14,
        "length": 4
      },
      "cwe": "CWE-362",
      "fix_suggestion": {
        "description": "Reduce MEV extractability in 'mint'. Implement: (1) Commit-reveal schemes, (2) Batch processing/auctions, (3) Private transaction pools (Flashbots), (4) Time-weighted mechanisms, (5) MEV-resistant AMM curves, (6) Encrypted mempools.",
        "replacements": []
      }
    },
    {
      "detector_id": "upgradeable-proxy-issues",
      "message": "Function 'initialize' has upgradeable proxy vulnerability. Initialize function lacks initialization guard, can be called multiple times to reset contract state Improper proxy patterns can lead to storage corruption, unauthorized upgrades, or complete contract takeover.",
      "severity": "critical",
      "location": {
        "line": 26,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-665",
      "fix_suggestion": {
        "description": "Fix proxy implementation in 'initialize'. Use storage gaps for future upgrades, implement initializer modifiers, add upgrade delay with timelock, validate implementation addresses, use UUPS pattern with _authorizeUpgrade, and emit events for all upgrades.",
        "replacements": []
      }
    },
    {
      "detector_id": "token-supply-manipulation",
      "message": "Function 'initialize' has token supply manipulation vulnerability. Function directly modifies totalSupply variable, bypasses mint/burn controls for supply manipulation Improper supply controls can lead to unlimited minting, hyperinflation, or complete token devaluation.",
      "severity": "critical",
      "location": {
        "line": 26,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Fix token supply controls in 'initialize'. Implement maximum supply cap, add minting rate limits, require multi-signature for minting, add supply change events, validate burn amounts, and implement supply monitoring.",
        "replacements": []
      }
    },
    {
      "detector_id": "token-supply-manipulation",
      "message": "Function 'mint' has token supply manipulation vulnerability. Mint function lacks maximum supply cap, enables unlimited token minting and hyperinflation Improper supply controls can lead to unlimited minting, hyperinflation, or complete token devaluation.",
      "severity": "critical",
      "location": {
        "line": 32,
        "column": 14,
        "length": 4
      },
      "cwe": "CWE-682",
      "fix_suggestion": {
        "description": "Fix token supply controls in 'mint'. Implement maximum supply cap, add minting rate limits, require multi-signature for minting, add supply change events, validate burn amounts, and implement supply monitoring.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function 'initialize' contains excessive gas usage pattern. Multiple storage reads detected (4). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 26,
        "column": 14,
        "length": 10
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in 'initialize'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "excessive-gas-usage",
      "message": "Function 'mint' contains excessive gas usage pattern. Multiple storage reads detected (5). Cache in memory variable to save gas Excessive gas usage increases transaction costs and may cause out-of-gas errors.",
      "severity": "low",
      "location": {
        "line": 32,
        "column": 14,
        "length": 4
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize gas usage in 'mint'. Consider: (1) Move storage operations outside loops, (2) Cache storage reads in memory, (3) Use events instead of storage for historical data, (4) Pack struct variables efficiently, (5) Use memory arrays for temporary data.",
        "replacements": []
      }
    },
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 24,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 51,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 70,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 88,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Single boolean storage variable. Consider packing multiple bools into uint256 bitmap Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 103,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "inefficient-storage",
      "message": "Inefficient storage pattern detected. Function 'initialize' reads same storage variable multiple times. Cache in memory Inefficient storage layout increases gas costs for all state-modifying operations.",
      "severity": "low",
      "location": {
        "line": 26,
        "column": 0,
        "length": 30
      },
      "cwe": "CWE-400",
      "fix_suggestion": {
        "description": "Optimize storage layout. Consider: (1) Pack variables <32 bytes together in structs, (2) Order struct fields by size (largest to smallest), (3) Use uint256 instead of smaller types for standalone variables, (4) Combine boolean flags into a single uint256 bitmap, (5) Use constants/immutables for unchanging values.",
        "replacements": []
      }
    },
    {
      "detector_id": "centralization-risk",
      "message": "Contract has centralization risk. Contract uses single owner without multi-signature protection. Single private key compromise leads to total contract control Single point of failure can lead to fund loss, governance attacks, or complete system compromise.",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-269",
      "fix_suggestion": {
        "description": "Implement decentralized governance. Use: (1) Multi-signature wallet (Gnosis Safe), (2) Timelock delays for critical operations, (3) DAO governance with voting mechanisms, (4) Role-based access control (OpenZeppelin AccessControl), (5) Emergency pause with multiple approvers.",
        "replacements": []
      }
    },
    {
      "detector_id": "shadowing-variables",
      "message": "Function 'mint' contains variable shadowing. Parameter 'owner' shadows state variable Shadowing can cause confusion and lead to bugs where the wrong variable is accessed.",
      "severity": "medium",
      "location": {
        "line": 32,
        "column": 14,
        "length": 4
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Rename shadowing variables in 'mint'. Use different names for local variables to avoid shadowing state variables. Consider prefixes like '_' for function parameters or descriptive names.",
        "replacements": []
      }
    },
    {
      "detector_id": "aa-initialization-vulnerability",
      "message": "Account abstraction initialization lacks signature verification. Initialization function lacks signature verification Missing signature verification allows anyone to initialize the account with arbitrary parameters, leading to account takeover.",
      "severity": "high",
      "location": {
        "line": 26,
        "column": 0,
        "length": 40
      },
      "cwe": "CWE-306",
      "fix_suggestion": {
        "description": "Implement secure initialization: (1) Add initWithSig function requiring user signature, (2) Verify signature matches expected owner, (3) Use nonce to prevent replay attacks, (4) Implement one-time initialization flag, (5) Consider ERC-4337 EntryPoint-only initialization.",
        "replacements": []
      }
    },
    {
      "detector_id": "aa-initialization-vulnerability",
      "message": "Initialization function missing one-time lock. Initialization function missing one-time execution guard Reinitialization vulnerability allows attacker to reset account parameters and potentially gain control.",
      "severity": "high",
      "location": {
        "line": 26,
        "column": 0,
        "length": 40
      },
      "cwe": "CWE-665",
      "fix_suggestion": {
        "description": "Add initialization protection: (1) Use initialized boolean flag, (2) Require !initialized in init function, (3) Set initialized = true after setup, (4) Consider OpenZeppelin's Initializable, (5) Use initializer modifier pattern.",
        "replacements": []
      }
    },
    {
      "detector_id": "aa-initialization-vulnerability",
      "message": "Initialization sets owner without validation. Owner assignment without address(0) check or signature verification Unvalidated owner parameter allows initialization with attacker-controlled address.",
      "severity": "high",
      "location": {
        "line": 27,
        "column": 0,
        "length": 40
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "Validate owner parameter: (1) Require owner != address(0), (2) Verify signature from owner address, (3) Emit OwnerSet event, (4) Consider two-step ownership transfer, (5) Validate owner in constructor or initWithSig.",
        "replacements": []
      }
    },
    {
      "detector_id": "mev-priority-gas-auction",
      "message": "First-come-first-served mint - creates PGA where users bid up gas to mint first",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 1,
        "length": 3534
      },
      "fix_suggestion": {
        "description": "Use commit-reveal, whitelist, or fair launch mechanism instead of FCFS",
        "replacements": []
      }
    },
    {
      "detector_id": "floating-pragma",
      "message": "Floating pragma detected: pragma solidity ^0.8.19;. Using '^' allows compilation with multiple compiler versions, which may introduce unexpected behavior or security vulnerabilities. Different compiler versions may have different bugs, optimizations, or security fixes.",
      "severity": "low",
      "location": {
        "line": 2,
        "column": 0,
        "length": 24
      },
      "cwe": "CWE-710",
      "fix_suggestion": {
        "description": "Lock pragma to specific version: 'pragma solidity 0.8.19;'. This ensures consistent compilation across environments and prevents unexpected behavior from compiler version differences.",
        "replacements": []
      }
    },
    {
      "detector_id": "storage-layout-upgrade",
      "message": "Storage gap without documentation (gap reduction tracking recommended)",
      "severity": "medium",
      "location": {
        "line": 0,
        "column": 0,
        "length": 20
      },
      "cwe": "CWE-1321",
      "fix_suggestion": {
        "description": "Document gaps: // uint256[50] private __gap; // Reduced by X when adding Y variables. Track gap reductions to prevent double-spending storage slots across upgrades.",
        "replacements": []
      }
    },
    {
      "detector_id": "private-variable-exposure",
      "message": "Sensitive data 'private' in 'private' variable - all blockchain storage is publicly readable",
      "severity": "high",
      "location": {
        "line": 91,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "CRITICAL: 'private' visibility does NOT encrypt data!\n\nAll blockchain storage is publicly readable via:\n- eth_getStorageAt RPC call\n- Block explorers\n- Archive nodes\n\n❌ This is INSECURE:\nstring private password = \"mysecret123\";\n\n✅ Correct approaches:\n\n1. NEVER store secrets on-chain\n2. Store hashes instead:\nbytes32 public passwordHash = keccak256(\"password\");\n\n3. Use commit-reveal for sensitive values:\nbytes32 public commitment = keccak256(abi.encode(value, salt));\n\n4. For truly private data, use off-chain storage or ZK proofs",
        "replacements": []
      }
    },
    {
      "detector_id": "private-variable-exposure",
      "message": "Sensitive data 'private' in 'private' variable - all blockchain storage is publicly readable",
      "severity": "high",
      "location": {
        "line": 109,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "CRITICAL: 'private' visibility does NOT encrypt data!\n\nAll blockchain storage is publicly readable via:\n- eth_getStorageAt RPC call\n- Block explorers\n- Archive nodes\n\n❌ This is INSECURE:\nstring private password = \"mysecret123\";\n\n✅ Correct approaches:\n\n1. NEVER store secrets on-chain\n2. Store hashes instead:\nbytes32 public passwordHash = keccak256(\"password\");\n\n3. Use commit-reveal for sensitive values:\nbytes32 public commitment = keccak256(abi.encode(value, salt));\n\n4. For truly private data, use off-chain storage or ZK proofs",
        "replacements": []
      }
    },
    {
      "detector_id": "logic-error-patterns",
      "message": "Potential division before multiplication - causes precision loss (OWASP 2025)",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "❌ PRECISION LOSS ($63.8M in losses):\nuint256 reward = (amount / totalSupply) * rewardRate;\n// Result: 0 if amount < totalSupply!\n\n✅ CORRECT ORDER:\nuint256 reward = (amount * rewardRate) / totalSupply;\n// Maximizes precision, multiply before divide\n\n✅ BEST: Use fixed-point math:\nuint256 reward = (amount * rewardRate * 1e18) / totalSupply / 1e18;\n\nReal incidents:\n- Cork Protocol: $11M (May 2025) - Division rounding\n- SIR.trading: $355K (March 2025) - Reward calculation\n- Multiple 2024 incidents: $63.8M total",
        "replacements": []
      }
    },
    {
      "detector_id": "enhanced-input-validation",
      "message": "Array access without length validation - can cause out-of-bounds access",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "❌ MISSING ARRAY VALIDATION (OWASP 2025 - $14.6M impact):\nfunction process(uint256[] calldata ids) external {\nfor (uint256 i = 0; i < ids.length; i++) {\n// What if ids is empty? Or too large?\n}\n}\n\n✅ VALIDATE ARRAY LENGTH:\nfunction process(uint256[] calldata ids) external {\n// Check minimum length\nrequire(ids.length > 0, \"Empty array\");\n\n// Check maximum length (prevent DoS)\nrequire(ids.length <= MAX_BATCH_SIZE, \"Batch too large\");\n\nfor (uint256 i = 0; i < ids.length; i++) {\n// Safe to access ids[i]\n}\n}\n\n✅ VALIDATE ARRAY MATCHING:\nfunction batchTransfer(\naddress[] calldata recipients,\nuint256[] calldata amounts\n) external {\n// Arrays must match in length\nrequire(\nrecipients.length == amounts.length,\n\"Length mismatch\"\n);\nrequire(recipients.length > 0, \"Empty arrays\");\nrequire(recipients.length <= MAX_BATCH, \"Too many\");\n\nfor (uint256 i = 0; i < recipients.length; i++) {\n// Safe parallel access\n}\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "enhanced-input-validation",
      "message": "Transfer function without zero-value check - validate non-zero amounts",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "❌ MISSING ZERO-VALUE CHECK:\nfunction transfer(address to, uint256 amount) external {\n_transfer(msg.sender, to, amount);\n// What if amount is 0? Wastes gas, may break accounting\n}\n\n✅ VALIDATE NON-ZERO:\nfunction transfer(address to, uint256 amount) external {\nrequire(amount > 0, \"Zero amount\");\nrequire(to != address(0), \"Zero address\");\n_transfer(msg.sender, to, amount);\n}\n\n✅ COMPLETE VALIDATION:\nfunction deposit(uint256 amount) external payable {\n// For ERC20 deposits\nrequire(amount > 0, \"Zero amount\");\nrequire(amount <= MAX_DEPOSIT, \"Exceeds maximum\");\n\n// For native ETH deposits\nif (msg.value > 0) {\nrequire(msg.value == amount, \"Value mismatch\");\n}\n\n// Proceed with deposit\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "enhanced-input-validation",
      "message": "Address parameter without zero-address validation",
      "severity": "medium",
      "location": {
        "line": 1,
        "column": 0,
        "length": 20
      },
      "fix_suggestion": {
        "description": "❌ MISSING ADDRESS VALIDATION:\nfunction setOwner(address newOwner) external {\nowner = newOwner;  // What if newOwner is address(0)?\n}\n\n✅ VALIDATE ADDRESS:\nfunction setOwner(address newOwner) external onlyOwner {\nrequire(newOwner != address(0), \"Zero address\");\nrequire(newOwner != owner, \"Same address\");\nowner = newOwner;\n}\n\n✅ VALIDATE MULTIPLE ADDRESSES:\nfunction initialize(\naddress _token,\naddress _oracle,\naddress _treasury\n) external {\nrequire(_token != address(0), \"Zero token\");\nrequire(_oracle != address(0), \"Zero oracle\");\nrequire(_treasury != address(0), \"Zero treasury\");\n\n// Check for duplicates if needed\nrequire(_token != _oracle, \"Token == oracle\");\nrequire(_token != _treasury, \"Token == treasury\");\n\ntoken = _token;\noracle = _oracle;\ntreasury = _treasury;\n}",
        "replacements": []
      }
    },
    {
      "detector_id": "jit-liquidity-sandwich",
      "message": "Liquidity becomes active immediately - may enable JIT sandwich attacks",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 3534
      },
      "fix_suggestion": {
        "description": "Consider delaying liquidity activation to the next epoch or block to mitigate JIT attacks",
        "replacements": []
      }
    },
    {
      "detector_id": "pool-donation-enhanced",
      "message": "No minimum deposit requirement - small deposits may round down to zero shares",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 3534
      },
      "fix_suggestion": {
        "description": "Enforce minimum deposit amount or minimum shares minted to prevent rounding attacks",
        "replacements": []
      }
    },
    {
      "detector_id": "pool-donation-enhanced",
      "message": "Pool initialization lacks protection - first depositor can manipulate initial share price",
      "severity": "high",
      "location": {
        "line": 1,
        "column": 1,
        "length": 3534
      },
      "fix_suggestion": {
        "description": "Require minimum initial deposit, mint dead shares on initialization, or use time-delayed activation",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-access-modifiers",
      "message": "Function 'setNewFeature' performs critical operations but lacks access control modifiers",
      "severity": "critical",
      "location": {
        "line": 55,
        "column": 14,
        "length": 13
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier like 'onlyOwner' to function 'setNewFeature'",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'value' of type 'uint' may need validation",
      "severity": "low",
      "location": {
        "line": 55,
        "column": 36,
        "length": 5
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "Add appropriate range validation for value",
        "replacements": []
      }
    },
    {
      "detector_id": "missing-access-modifiers",
      "message": "Function 'setNewFeature' performs critical operations but lacks access control modifiers",
      "severity": "critical",
      "location": {
        "line": 111,
        "column": 14,
        "length": 13
      },
      "cwe": "CWE-284",
      "fix_suggestion": {
        "description": "Add an access control modifier like 'onlyOwner' to function 'setNewFeature'",
        "replacements": []
      }
    },
    {
      "detector_id": "parameter-consistency",
      "message": "Parameter 'value' of type 'uint' may need validation",
      "severity": "low",
      "location": {
        "line": 111,
        "column": 36,
        "length": 5
      },
      "cwe": "CWE-20",
      "fix_suggestion": {
        "description": "Add appropriate range validation for value",
        "replacements": []
      }
    }
  ],
  "metadata": {
    "tool_name": "SolidityDefend",
    "tool_version": "1.3.6",
    "scan_type": "static_analysis",
    "language": "solidity",
    "rules_version": "1.3.6",
    "branding": {
      "name": "BlockSecOps",
      "url": "https://BlockSecOps.com",
      "description": "Enterprise-Grade DevSecOps Platform for Smart Contracts"
    }
  },
  "statistics": {
    "total_findings": 43,
    "severity_counts": {
      "medium": 6,
      "low": 13,
      "info": 0,
      "high": 17,
      "critical": 7
    },
    "unique_detectors": 22
  }
}